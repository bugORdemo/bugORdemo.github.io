[{"title":"A new beginning","url":"/2020/09/14/hello-world/","content":"<p>前站已停止服务，之后的学习笔记将记录于此，以前的笔记也会逐步迁移过来。</p>\n"},{"title":"ZooKeeper简述","url":"/2020/09/23/ZooKeeper%E7%AE%80%E8%BF%B0/","content":"\n        <h1 id=\"ZooKeeper简述\"   >\n          <a href=\"#ZooKeeper简述\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>ZooKeeper简述</h1>\n      <p><strong>分布式协调服务</strong></p>\n<p>ZooKeeper是一种为分布式应用所设计的高可用、高性能且一致的开源<strong>协调服务</strong>，它提供了一项基本服务：<strong>分布式锁服务</strong></p>\n<p>由于ZooKeeper的开源特性，后来我们的开发者在分布式锁的基础上，摸索了出了其他的使用方法：<strong>配置维护、组服务、分布式消息队列、分布式通知/协调</strong>等。</p>\n<a id=\"more\"></a>\n\n<p>ZooKeeper性能上的特点决定了它能够用在大型的、分布式的系统当中。从可靠性方面来说，它并不会因为一个节点的错误而崩溃。</p>\n<p>除此之外，它严格的序列访问控制意味着复杂的控制原语可以应用在客户端上。</p>\n<p>ZooKeeper在一致性、可用性、容错性的保证，也是ZooKeeper的成功之处，它获得的一切成功都与它采用的协议——Zab协议是密不可分的</p>\n<p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a9375160a154a678fe452.png\"  alt=\"41362cd95c66358468e7ca23382281f5.png\">\n      </p>\n\n        <h2 id=\"ZooKeeper数据模型\"   >\n          <a href=\"#ZooKeeper数据模型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>ZooKeeper数据模型</h2>\n      \n        <h3 id=\"ZooKeeper数据模型-1\"   >\n          <a href=\"#ZooKeeper数据模型-1\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>ZooKeeper数据模型</h3>\n      <p>ZooKeeper拥有一个层次的命名空间，和标准的文件系统非常相似，都是采用这种树形层次结构，ZooKeeper树中的每个节点被称为Znode，ZooKeeper树中的每个节点可以拥有子节点<br>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a9375160a154a678fe456.png\"  alt=\"b14ec5b65a54349168a086e6fd425be0.png\">\n      </p>\n<ol>\n<li><p>引用方式<br> Zonde通过路径引用，如同Unix中的文件路径。路径必须是<strong>绝对的</strong>，因此他们必须由<strong>斜杠字符来开头</strong>。除此以外，他们必须是<strong>唯一的</strong>，也就是说每一个路径只有一个表示，因此这些路径不能改变。在ZooKeeper中，路径由Unicode字符串组成，并且有一些限制。</p>\n<p> 字符串”/zookeeper”用以保存管理信息，比如关键配额信息。</p>\n</li>\n<li><p>Znode结构<br> ZooKeeper命名空间中的Znode，兼具文件和目录两种特点。既像文件一样维护着数据、元信息、ACL、时间戳等数据结构，又像目录一样可以作为路径标识的一部分。每个节点称为一个Znode。 每个Znode由3部分组成:</p>\n<ol>\n<li><p>stat：此为状态信息, 描述该Znode的版本, 权限等信息</p>\n</li>\n<li><p>data：与该Znode关联的数据</p>\n</li>\n<li><p>children：该Znode下的子节点</p>\n<p>ZooKeeper虽然可以关联一些数据，但<strong>不要把zookeeper当数据库用</strong>，它用来<strong>管理调度数据</strong>，比如分布式应用中的配置文件信息、状态信息、汇集位置等等。这些数据的共同特性就是它们都是<strong>很小</strong>的数据，通常以KB为大小单位。</p>\n<p>ZooKeeper的服务器和客户端都被设计为严格检查并限制每个Znode的数据大小至<strong>多1M</strong>，但常规使用中应该远小于此值。</p>\n</li>\n</ol>\n</li>\n<li><p>数据访问<br> ZooKeeper中的每个节点存储的数据要被<strong>原子性</strong>的操作。也就是说读操作将获取与节点相关的所有数据，写操作也将替换掉节点的所有数据。</p>\n<p> 另外，每一个节点都拥有自己的ACL(访问控制列表)，这个列表规定了用户的权限，即限定了特定用户对目标节点可以执行的操作。</p>\n</li>\n<li><p>节点类型<br> ZooKeeper中的节点有两种，分别为<strong>临时节点和永久节点</strong>。节点的类型在创建时即被确定，并且不能改变。</p>\n<ol>\n<li><p>临时节点：该节点的生命周期依赖于创建它们的会话。一旦会话(Session)结束，临时节点将被自动删除，当然可以也可以手动删除。虽然每个临时的Znode都会绑定到一个客户端会话，但他们对所有的客户端还是可见的。另外，ZooKeeper的<strong>临时节点不允许拥有子节点</strong>。</p>\n<ol start=\"2\">\n<li>永久节点：该节点的生命周期不依赖于会话，并且只有在客户端显示执行删除操作的时候，他们才能被删除。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>顺序节点<br>当创建Znode的时候，用户可以请求在ZooKeeper的路径结尾添加一个递增的计数。这个计数对于此节点的父节点来说是唯一的，它的格式为”%10d”(10位数字，没有数值的数位用0补充，例如”0000000001”)。当计数值大于232-1时，计数器将溢出。</p>\n</li>\n<li><p>watch<br> 客户端可以在节点上设置watch，我们称之为监视器。当节点状态发生改变时(Znode的增、删、改)将会触发watch所对应的操作。</p>\n<p> 当watch被触发时，ZooKeeper将会向客户端发送且仅发送一条通知，因为watch只能被触发一次，这样可以减少网络流量。</p>\n</li>\n</ol>\n\n        <h3 id=\"ZooKeeper中的时间\"   >\n          <a href=\"#ZooKeeper中的时间\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>ZooKeeper中的时间</h3>\n      <p>ZooKeeper有多种记录时间的形式，其中包含以下几个主要属性：</p>\n<ol>\n<li><p>Zxid<br> 每一个使节点状态改变的操作，都会使节点接收到一个Zxid格式的时间戳，并且这个时间戳<strong>全局有序</strong>。也就是说，每个对节点的改变都将产生一个唯一的Zxid。</p>\n<p> 如果Zxid1的值小于Zxid2的值，那么Zxid1所对应的事件发生在Zxid2所对应的事件之前（谁大谁后发生）。</p>\n<p> 实际上，ZooKeeper的每个节点维护者三个Zxid值，为别为：cZxid、mZxid、pZxid。</p>\n<ol>\n<li><p>cZxid： 对应为该节点的创建时间（Create）</p>\n</li>\n<li><p>mZxid：对应该节点的最近一次修改的时间（Mofify），与其子节点无关</p>\n</li>\n<li><p>pZxid：是与该节点的子节点（或该节点）的最近一次创建、删除的时间戳对应<br> 注：只与本节点 / 该节点的子节点有关，与孙子节点无关。</p>\n<p>Zxid是一个64为的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个 新的epoch。低32位是个<strong>递增计数</strong>。 </p>\n</li>\n</ol>\n</li>\n<li><p>版本号<br> 对节点的每一个操作都将致使这个节点的版本号增加。每个节点维护三个版本号，他们分别为：</p>\n<ol>\n<li>version：节点数据版本号</li>\n<li>cversion：子节点版本号</li>\n<li>aversion：节点所拥有的ACL版本号</li>\n</ol>\n</li>\n</ol>\n<p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a9394160a154a678fee16.png\"  alt=\"5c58466c2019d1b72122f9be4729e981.png\">\n      </p>\n\n        <h2 id=\"简单操作\"   >\n          <a href=\"#简单操作\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>简单操作</h2>\n      <p>create：创建Znode，父Znode必须存在<br>delete：删除Znode，Znode没有子节点<br>exists：测试Znode是否存在，并获取元数据<br>getACL/setACL：获取/设置ACL<br>getChildren：获取Znode所有子节点列表<br>getData/setData：获取/设置数据<br>sync：是客户端的Znode识图与ZooKeeper同步</p>\n<p>更新ZooKeeper操作是有限制的。<strong>delete或setData必须明确要更新的Znode的版本号</strong>，我们可以调用exists找到。如果版本号不匹配，更新将会失败。</p>\n<p>更新ZooKeeper操作是<strong>非阻塞式</strong>的。因此客户端如果失去了一个更新(由于另一个进程在同时更新这个Znode)，他可以在不阻塞其他进程执行的情况下，选择重新尝试或进行其他操作。</p>\n<ol>\n<li>连接到Zookeeper服务<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">zkCli.sh -server localhost:2181</span><br></pre></td></tr></table></div></figure></li>\n<li>使用ls命令查看当前Zookeeper中所包含的内容：ls /<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">[zk: localhost:2181(CONNECTED) 1] ls &#x2F;</span><br><span class=\"line\">[zookeeper]</span><br><span class=\"line\">[zk: localhost:2181(CONNECTED) 2]</span><br></pre></td></tr></table></div></figure></li>\n<li>创建一个新的Znode节点”zk”，以及和它相关字符，执行命令：create /zk myData<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">[zk: localhost:2181(CONNECTED) 2] create &#x2F;zk myData</span><br><span class=\"line\">Created &#x2F;zk</span><br><span class=\"line\">[zk: localhost:2181(CONNECTED) 3] ls &#x2F;</span><br><span class=\"line\">[zk, zookeeper]</span><br></pre></td></tr></table></div></figure></li>\n<li>使用get命令来确认第二步中所创建的Znode是否包含创建的字符串，执行命令：get /zk<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">[zk: localhost:2181(CONNECTED) 4] get &#x2F;zk</span><br><span class=\"line\">myData</span><br><span class=\"line\">cZxid &#x3D; 0x500000006</span><br><span class=\"line\">ctime &#x3D; Fri Sep 18 03:54:20 PDT 2020</span><br><span class=\"line\">mZxid &#x3D; 0x500000006</span><br><span class=\"line\">mtime &#x3D; Fri Sep 18 03:54:20 PDT 2014</span><br><span class=\"line\">pZxid &#x3D; 0x500000006</span><br><span class=\"line\">cversion &#x3D; 0</span><br><span class=\"line\">dataVersion &#x3D; 0</span><br><span class=\"line\">aclVersion &#x3D; 0</span><br><span class=\"line\">ephemeralOwner &#x3D; 0x0</span><br><span class=\"line\">dataLength &#x3D; 6</span><br><span class=\"line\">numChildren &#x3D; 0****</span><br></pre></td></tr></table></div></figure></li>\n<li>通过set命令来对zk所关联的字符串进行设置，执行命令：set /zk hao<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">[zk: localhost:2181(CONNECTED) 5] set &#x2F;zk hao</span><br><span class=\"line\">cZxid &#x3D; 0x500000006</span><br><span class=\"line\">ctime &#x3D; Fri Sep 18 03:54:20 PDT 2014</span><br><span class=\"line\">mZxid &#x3D; 0x500000007</span><br><span class=\"line\">mtime &#x3D; Fri Sep 18 03:55:50 PDT 2014</span><br><span class=\"line\">pZxid &#x3D; 0x500000006</span><br><span class=\"line\">cversion &#x3D; 0</span><br><span class=\"line\">dataVersion &#x3D; 1</span><br><span class=\"line\">aclVersion &#x3D; 0</span><br><span class=\"line\">ephemeralOwner &#x3D; 0x0</span><br><span class=\"line\">dataLength &#x3D; 9</span><br><span class=\"line\">numChildren &#x3D; 0</span><br></pre></td></tr></table></div></figure></li>\n<li>将刚才创建的Znode删除，执行命令：delete /zk，rmr /zk<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">[zk: localhost:2181(CONNECTED) 7] delete &#x2F;zk　</span><br><span class=\"line\"># 整个节点全删除  注意：delete只能删除不包含子节点的节点，如果要删除的节点包含子节点，使用rmr命令</span><br><span class=\"line\">[zk: localhost:2181(CONNECTED) 7] rmr &#x2F;zk</span><br></pre></td></tr></table></div></figure>\n\n</li>\n</ol>\n\n        <h2 id=\"watch\"   >\n          <a href=\"#watch\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>watch</h2>\n      <p>ZooKeeper可以为所有的读操作设置watch，这些读操作包括：exists()、getChildren()及getData()。</p>\n<p>watch事件是<strong>一次性</strong>的触发器，当watch的对象<strong>状态发生改变时</strong>，将会触发此对象上watch所对应的事件。</p>\n<p>watch事件将被异步地发送给客户端，并且ZooKeeper为watch机制提供了有序的一致性保证。理论上，客户端接收watch事件的时间要快于其看到watch对象状态变化的时间。</p>\n\n        <h3 id=\"watch类型\"   >\n          <a href=\"#watch类型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>watch类型</h3>\n      <p>ZooKeeper所管理的watch可以分为两类：</p>\n<ol>\n<li>data  watches：getData和exists负责设置数据watch</li>\n<li>child watches：getChildren负责设置孩子watch</li>\n</ol>\n<p>可以通过操作返回的数据来设置不同的watch：</p>\n<ol>\n<li>getData和exists：返回关于节点的数据信息</li>\n<li>getChildren：返回孩子列表</li>\n</ol>\n<p>因此</p>\n<ol>\n<li><p>一个成功的setData操作将触发Znode的data watch</p>\n</li>\n<li><p>一个成功的create操作将触发Znode的data watch以及child watch</p>\n</li>\n<li><p>一个成功的delete操作将触发Znode的data watch以及child watch</p>\n</li>\n</ol>\n\n        <h3 id=\"watch注册与处触发\"   >\n          <a href=\"#watch注册与处触发\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>watch注册与处触发</h3>\n      <ol>\n<li><p>exists操作上的watch，在被监视的Znode创建、删除或数据更新时被触发。</p>\n</li>\n<li><p>getData操作上的watch，在被监视的Znode删除或数据更新时被触发。在被创建时不能被触发，因为只有Znode一定存在，getData操作才会成功。</p>\n</li>\n<li><p>getChildren操作上的watch，在被监视的Znode的子节点创建或删除，或是这个Znode自身被删除时被触发。可以通过查看watch事件类型来区分是Znode，还是他的子节点被删除：NodeDelete表示Znode被删除，NodeDeletedChanged表示子节点被删除。</p>\n</li>\n</ol>\n\n        <h3 id=\"注意\"   >\n          <a href=\"#注意\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>注意</h3>\n      <p>Zookeeper的watch实际上要处理两类事件：</p>\n<ol>\n<li>连接状态事件(type=None, path=null)<br> 这类事件不需要注册，也不需要我们连续触发，我们只要处理就行了。</li>\n<li>节点事件<br> 节点的建立，删除，数据的修改。它是one time trigger（一次性触发器），我们需要不停的注册触发，还可能发生事件丢失的情况。</li>\n</ol>\n<p>上面2类事件都在Watch中处理，也就是重载的process(Event event)<br>节点事件的触发，通过函数exists，getData或getChildren来处理这类函数，有双重作用：</p>\n<ol>\n<li>注册触发事件</li>\n<li>函数本身的功能<br>函数的本身的功能又可以用异步的回调函数来实现,重载processResult()过程中处理函数本身的的功能。</li>\n</ol>\n\n        <h2 id=\"Zab协议-原子广播\"   >\n          <a href=\"#Zab协议-原子广播\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Zab协议(原子广播)</h2>\n      <p>Zab协议是为分布式协调服务Zookeeper专门设计的一种 支持崩溃恢复 的 原子广播协议 ，是Zookeeper保证数据一致性的核心算法。</p>\n<p>在Zookeeper中主要依赖Zab协议来实现数据一致性，基于该协议，zk实现了一种主备模型（即Leader和Follower模型）的系统架构来保证集群中各个副本之间数据的一致性。</p>\n<p>这里的主备系统架构模型，就是指只有一台客户端（Leader）负责处理外部的写事务请求，然后Leader客户端将数据同步到其他Follower节点。</p>\n<p>特性：</p>\n<ol>\n<li>Zab 协议需要确保那些<strong>已经在 Leader 服务器上提交（Commit）的事务最终被所有的服务器提交</strong></li>\n<li>Zab 协议需要确保<strong>丢弃那些只在 Leader 上被提出而没有被提交的事务</strong><br>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a93b9160a154a678ffa55.png\"  alt=\"825b7933b3d1f5d59897287fdd24d09f.png\">\n      </li>\n</ol>\n\n        <h3 id=\"Zab-协议实现的作用\"   >\n          <a href=\"#Zab-协议实现的作用\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Zab 协议实现的作用</h3>\n      <ol>\n<li><p>使用一个单一的主进程（Leader）来接收并处理客户端的事务请求（也就是写请求），并采用了Zab的原子广播协议，将服务器数据的状态变更以事务proposal （事务提议）的形式广播到所有的副本（Follower）进程上去</p>\n</li>\n<li><p>保证一个全局的变更序列被顺序引用。<br> Zookeeper是一个树形结构，很多操作都要先检查才能确定是否可以执行，比如P1的事务t1可能是创建节点”/a”，t2可能是创建节点”/a/bb”，只有先创建了父节点”/a”，才能创建子节点”/a/b”。<br> 为了保证这一点，Zab要保证同一个Leader发起的事务要按顺序被应用，同时还要保证只有先前Leader的事务被应用之后，新选举出来的Leader才能再次发起事务</p>\n</li>\n<li><p>当主进程出现异常的时候，整个zk集群依旧能正常工作。</p>\n</li>\n</ol>\n\n        <h3 id=\"Zab协议原理\"   >\n          <a href=\"#Zab协议原理\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Zab协议原理</h3>\n      <p>Zab协议要求每个 Leader 都要经历三个阶段：发现，同步，广播。</p>\n<ul>\n<li>发现：要求zookeeper集群必须选举出一个 Leader 进程，同时 Leader 会维护一个 Follower 可用客户端列表。将来客户端可以和这些 Follower节点进行通信。</li>\n<li>同步：Leader 要负责将本身的数据与 Follower 完成同步，做到多副本存储。这样也是提现了CAP中的高可用和分区容错。Follower将队列中未处理完的请求消费完成后，写入本地事务日志中。</li>\n<li>广播：Leader 可以接受客户端新的事务提案请求，将新的提案请求广播给所有的 Follower。</li>\n</ul>\n<hr>\n<p>Zab协议的核心：<strong>定义了事务请求的处理方式</strong></p>\n<ol>\n<li>所有的事务请求必须由一个全局唯一的服务器来协调处理，这样的服务器被叫做 <strong>Leader</strong>服务器。其他剩余的服务器则是 Follower服务器。</li>\n<li>Leader服务器负责将一个客户端事务请求，转换成一个事务提案，并将该提案分发给集群中所有的Follower服务器，也就是向所有Follower节点发送数据广播请求（或数据复制）</li>\n<li>分发之后Leader服务器需要等待所有Follower服务器的反馈（Ack请求），在Zab协议中，只要<strong>超过半数</strong>的Follower服务器进行了正确的反馈后（也就是收到半数以上的Follower的Ack请求），那么 Leader 就会再次向所有的 Follower服务器发送Commit消息，要求其将上一个 事务提案进行提交。</li>\n</ol>\n<ul>\n<li>一句话：Leader统提案，半数以上Follower同意就执行</li>\n</ul>\n<p>注意：除了Leader和Follower之外还有一个Observer，Observer可以接受客户端的连接，并将写请求转发给Leader节点，但是bserver不参加投票</p>\n\n        <h3 id=\"Zab协议内容\"   >\n          <a href=\"#Zab协议内容\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Zab协议内容</h3>\n      <p>Zab 协议包括两种基本的模式：<strong>崩溃恢复</strong> 和 <strong>消息广播</strong></p>\n<p>当整个集群启动过程中，或者当 Leader 服务器出现网络中断、崩溃退出或重启等异常时，Zab协议就会进入<strong>崩溃恢复模式</strong>，选举产生新的Leader。当选举产生了新的 Leader，同时集群中有<strong>过半的</strong>机器与该 Leader 服务器<strong>完成了状态同步</strong>（即数据同步）之后，Zab协议就会退出崩溃恢复模式，进入消息广播模式。</p>\n<p>这时，如果有一台遵守Zab协议的服务器加入集群，因为此时集群中已经存在一个Leader服务器在广播消息，那么该新加入的服务器自动进入恢复模式：找到Leader服务器，并且完成数据同步。同步完成后，作为新的Follower一起参与到消息广播流程中。</p>\n<p>在整个消息广播中，Leader会将每一个事务请求转换成对应的提案来进行广播，并且在广播之前，Leader服务器会首先为这个事务提案分配一个<strong>全局单递增的唯一ID</strong>，称之为事务ID（即zxid），由于Zab协议需要保证每一个消息的严格的顺序关系，因此必须将每一个提案按照其zxid的先后顺序进行排序和处理。</p>\n\n        <h4 id=\"消息广播\"   >\n          <a href=\"#消息广播\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>消息广播</h4>\n      <p>在zookeeper集群中，数据副本的传递策略就是采用消息广播模式.</p>\n<p>Zab协议中 Leader 等待 Follower 的ACK反馈消息是指“只要<strong>半数以上</strong>的Follower成功反馈即可，不需要收到全部Follower反馈”</p>\n<p>zookeeper 采用 Zab 协议的核心，就是只要有一台服务器提交了 Proposal，就要确保所有的服务器最终都能正确提交 Proposal。这也是 CAP/BASE 实现最终一致性的一个体现。</p>\n<p>Leader 服务器与每一个 Follower 服务器之间都维护了一个单独的<strong>FIFO消息队列</strong>进行收发消息，使用队列消息可以做到异步解耦。 Leader 和 Follower 之间只需要往队列中发消息即可。如果使用同步的方式会引起阻塞，性能要下降很多。</p>\n<p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a93b9160a154a678ffa44.png\"  alt=\"7a89f2824c5afa2da102f1fa4f582ac0.png\">\n      </p>\n\n        <h4 id=\"崩溃恢复\"   >\n          <a href=\"#崩溃恢复\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>崩溃恢复</h4>\n      <p>一旦 Leader 服务器出现崩溃或者由于网络原因导致 Leader 服务器失去了与过半 Follower 的联系，那么就会进入崩溃恢复模式。</p>\n<p>崩溃恢复主要包括两部分：Leader选举 和 数据恢复</p>\n<p>Zab 协议崩溃恢复要求满足以下两个要求：</p>\n<ol>\n<li>确保已经被 Leader 提交的 Proposal 必须最终被所有的 Follower 服务器提交</li>\n<li>确保丢弃已经被 Leader 提出的但是没有被提交的 Proposal</li>\n</ol>\n<p>所以<br>Zab协议需要保证选举出来的Leader需要满足以下条件：</p>\n<ol>\n<li>新选举出来的 Leader 不能包含未提交的 Proposal 。即新选举的 Leader 必须都是已经提交了 Proposal 的 Follower 服务器节点</li>\n<li>新选举的 Leader 节点中含有最大的 zxid </li>\n</ol>\n<p>Zab 如何数据同步？</p>\n<ol>\n<li><p>完成 Leader 选举后（新的 Leader 具有最高的zxid），在正式开始工作之前（接收事务请求，然后提出新的 Proposal），Leader 服务器会首先确认事务日志中的所有的 Proposal 是否已经被集群中过半的服务器 Commit。</p>\n</li>\n<li><p>Leader 服务器需要确保所有的 Follower 服务器能够接收到每一条事务的 Proposal ，并且能将所有已经提交的事务 Proposal 应用到内存数据中。等到 Follower 将所有尚未同步的事务 Proposal 都从 Leader 服务器上同步过来并且应用到内存数据中以后，Leader 才会把该 Follower 加入到真正可用的 Follower 列表中。</p>\n</li>\n</ol>\n<p>当一个包含了上一个 Leader 周期中尚未提交过的事务 Proposal 的服务器启动时，当这台机器加入集群中，以 Follower 角色连上 Leader 服务器后，Leader 服务器会根据自己服务器上最后提交的 Proposal 来和 Follower 服务器的 Proposal 进行比对，比对的结果肯定是 Leader 要求 Follower 进行一个回退操作，回退到一个确实已经被集群中过半机器 Commit 的最新 Proposal。</p>\n<p>成为 Leader 的条件：</p>\n<ol>\n<li>选 epoch 最大的</li>\n<li>若 epoch 相等，选 zxid 最大的</li>\n<li>若 epoch 和 zxid 相等，选择 server_id 最大的（zoo.cfg中的myid）</li>\n</ol>\n\n        <h2 id=\"应用\"   >\n          <a href=\"#应用\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>应用</h2>\n      \n        <h3 id=\"通过对集群进行Master选举，来解决分布式系统中的单点故障\"   >\n          <a href=\"#通过对集群进行Master选举，来解决分布式系统中的单点故障\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>通过对集群进行Master选举，来解决分布式系统中的单点故障</h3>\n      <p>通常分布式系统采用主从模式，就是一个主控机连接多个处理节点。主节点负责分发任务，从节点负责处理任务，当我们的主节点发生故障时，那么整个系统就都瘫痪了，这种故障就是单点故障。</p>\n<hr>\n<p>在引入了Zookeeper以后我们启动了两个主节点，”主节点-A”和”主节点-B”他们启动以后，都向ZooKeeper去注册一个节点。</p>\n<p>我们假设”主节点-A”锁注册地节点是”master-00001”，”主节点-B”注册的节点是”master-00002”，注册完以后进行选举，编号最小的节点将在选举中获胜获得锁成为主节点，也就是我们的”主节点-A”将会获得锁成为主节点，然后”主节点-B”将被阻塞成为一个备用节点。那么，通过这种方式就完成了对两个Master进程的调度。</p>\n<p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a93b9160a154a678ffa46.png\"  alt=\"f47b0b262860510edc1033f44d83eef3.png\">\n      </p>\n<p>如果”主节点-A”挂了，这时候他所注册的节点将被自动删除，ZooKeeper会自动感知节点的变化，然后再次发出选举，这时候”主节点-B”将在选举中获胜，替代”主节点-A”成为主节点。</p>\n<p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a93b9160a154a678ffa49.png\"  alt=\"f38de3cc2959b06cddb54f6ece6d08d1.png\">\n      </p>\n<p>如果主节点恢复了，他会再次向ZooKeeper注册一个节点，这时候他注册的节点将会是”master-00003”，ZooKeeper会感知节点的变化再次发动选举，这时候”主节点-B”在选举中会再次获胜继续担任”主节点”，”主节点-A”会担任备用节点。<br>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a93b9160a154a678ffa4f.png\"  alt=\"e01900d9810a739219665d627b304a0b.png\">\n      </p>\n","categories":["ZooKeeper"],"tags":["ZooKeeper"]},{"title":"一些Redis问题","url":"/2020/09/23/%E4%B8%80%E4%BA%9BRedis%E9%97%AE%E9%A2%98/","content":"\n        <h1 id=\"Redis一些问题\"   >\n          <a href=\"#Redis一些问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Redis一些问题</h1>\n      \n        <h2 id=\"缓存击穿\"   >\n          <a href=\"#缓存击穿\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>缓存击穿</h2>\n      <p>缓存击穿是指缓存中没有但数据库中有的数据（一般是<strong>缓存时间到期</strong>，曾经有过，key过期了或者LRU/LFU）</p>\n<p>这时由于<strong>并发用户特别多</strong>，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力</p>\n<ul>\n<li><strong>在高并发情况下，KEY的过期造成并发访问数据库</strong>（少量的key，高并发去请求一个key）</li>\n</ul>\n<a id=\"more\"></a>\n\n\n        <h3 id=\"解决方案\"   >\n          <a href=\"#解决方案\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>解决方案</h3>\n      <ol>\n<li><p>设置热点数据永远不过期</p>\n</li>\n<li><p>加锁<br> 可以使用setnx实现</p>\n<p> 当并发过来时</p>\n<ol>\n<li>get key  get到直接返回，get不到向下走</li>\n<li>setnx 设置key，就是抢这把锁，谁set成功了就是抢到了，然后去访问数据库</li>\n<li>分两种情况<ol>\n<li>抢到的去访问DB，返回结果并set</li>\n<li>没抢到的sleep一会，再从第一步开始，此时应该可以get到了并返回</li>\n</ol>\n</li>\n</ol>\n<ul>\n<li>问题1：如果第一个挂了（拿到锁的）怎么办<ul>\n<li>可以设置锁的过期时间</li>\n</ul>\n</li>\n<li>问题2：没挂，但是锁超时了怎么办<ul>\n<li>使用多线程，一个线程去DB，一个线程监控是否取回来了，去更新锁时间</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a92ed160a154a678fb948.png\"  alt=\"64dee02b699d5b760620407bdf9eb31b.png\">\n      </p>\n\n        <h2 id=\"缓存穿透\"   >\n          <a href=\"#缓存穿透\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>缓存穿透</h2>\n      <p> 缓存穿透是指<strong>缓存和数据库中都没有的数据</strong>，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。</p>\n\n        <h3 id=\"解决方案-1\"   >\n          <a href=\"#解决方案-1\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>解决方案</h3>\n      <ol>\n<li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截；</li>\n<li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null</li>\n<li>过滤器：布隆过滤器、布谷鸟过滤器…</li>\n</ol>\n<p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a92ed160a154a678fb938.png\"  alt=\"b62f8872daee92440c63835a06d81380.png\">\n      </p>\n\n        <h2 id=\"缓存雪崩\"   >\n          <a href=\"#缓存雪崩\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>缓存雪崩</h2>\n      <p>缓存雪崩是指<strong>缓存中数据大批量过期</strong>，而查询数据量巨大，引起数据库压力过大甚至宕机。</p>\n<p>和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p>\n\n        <h3 id=\"解决方案-2\"   >\n          <a href=\"#解决方案-2\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>解决方案</h3>\n      <ul>\n<li>设置热点数据永远不过期</li>\n</ul>\n<p>雪崩问题要注意：<strong>是否是时点性的</strong>，比如每天0点都要重置的数据</p>\n<p>不是时点性的：设置随机过期时间，防止同一时间大量数据过期现象发生</p>\n<p>是时点性的：<br>    1. 强依赖缓存击穿的方案<br>        2. 业务层加判断，时点延迟（请求随机延迟几毫秒）<br>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a92ed160a154a678fb93e.png\"  alt=\"3b14b91d2bd0b67bd98e57ebbd132e84.png\">\n      </p>\n\n        <h2 id=\"Redis做分布式锁\"   >\n          <a href=\"#Redis做分布式锁\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Redis做分布式锁</h2>\n      <ul>\n<li><p>可以使用setnx</p>\n</li>\n<li><p>可能会挂，添加过期时间</p>\n</li>\n<li><p>没干完呢，锁到期了，过期时间到期了，可以使用多线程（守护线程），延长过期时间</p>\n</li>\n<li><p><strong>zookeeper做分布式锁</strong> </p>\n</li>\n</ul>\n\n        <h2 id=\"redis-API\"   >\n          <a href=\"#redis-API\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>redis API</h2>\n      <ol>\n<li>Jedis</li>\n<li>Lettuce</li>\n<li>Redisson</li>\n</ol>\n<p>Jedis中的方法调用是比较底层的暴露的Redis的API，也即Jedis中的Java方法基本和Redis的API保持着一致，了解Redis的API，也就能熟练的使用Jedis。而Redisson中的方法则是进行比较高的抽象，每个方法调用可能进行了一个或多个Redis方法调用。</p>\n","categories":["Redis"],"tags":["Redis"]},{"title":"Redis集群","url":"/2020/09/23/Redis%E9%9B%86%E7%BE%A4/","content":"\n        <h1 id=\"Redis集群\"   >\n          <a href=\"#Redis集群\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Redis集群</h1>\n      <p>集群，即Redis Cluster。集群由多个节点(Node)组成，Redis的数据分布在这些节点中。</p>\n<p>集群中的节点分为主节点和从节点：只有主节点负责读写请求和集群信息的维护；从节点只进行主节点数据和状态信息的复制。</p>\n<p>集群的作用，可以归纳为两点：</p>\n<a id=\"more\"></a>\n\n<ol>\n<li><p>数据分区：数据分区(或称数据分片)是集群最核心的功能</p>\n<p> 集群将数据分散到多个节点，一方面突破了Redis单机内存大小的限制，存储容量大大增加；另一方面每个主节点都可以对外提供读服务和写服务，大大提高了集群的响应能力。</p>\n</li>\n<li><p>高可用：集群支持主从复制和主节点的自动故障转移（与哨兵类似）；当任一节点发生故障时，集群仍然可以对外提供服务。</p>\n</li>\n</ol>\n<blockquote>\n<p>搭建、具体原理、客服端访问集群等详见：<span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.cnblogs.com/kismetv/p/9853040.html\" >https://www.cnblogs.com/kismetv/p/9853040.html</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n</blockquote>\n\n        <h2 id=\"集群的基本原理\"   >\n          <a href=\"#集群的基本原理\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>集群的基本原理</h2>\n      <p>集群最核心的功能是<strong>数据分区</strong></p>\n\n        <h3 id=\"数据分区方案\"   >\n          <a href=\"#数据分区方案\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>数据分区方案</h3>\n      <p>衡量数据分区方法好坏的标准有很多，其中比较重要的两个因素是<br>    1. 数据分布是否均匀<br>    2. 增加或删减节点对数据分布的影响</p>\n<p>数据分区根据数据可否拆分分为两类：可拆分、不可拆分</p>\n<p>可拆分的数据可以根据业务逻辑进行拆分</p>\n<p>不可拆分的有以下几种常用拆分方式：</p>\n<p>哈希取余分区、随机分区、一致性哈希分区、带虚拟节点的一致性哈希分区</p>\n\n        <h4 id=\"随机分区\"   >\n          <a href=\"#随机分区\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>随机分区</h4>\n      <p>对数据随机拆分，应用在比较特殊的场景。比如：消息队列.</p>\n\n        <h4 id=\"哈希取余分区\"   >\n          <a href=\"#哈希取余分区\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>哈希取余分区</h4>\n      <p>计算key的hash值，然后对节点数量进行取余，从而决定数据映射到哪个节点上。</p>\n<p>该方案最大的问题是：当新增或删减节点时，节点数量发生变化，系统中所有的数据都需要重新计算映射关系，引发大规模数据迁移。</p>\n\n        <h4 id=\"一致性哈希分区\"   >\n          <a href=\"#一致性哈希分区\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>一致性哈希分区</h4>\n      <p>一致性哈希算法将整个哈希值空间组织成一个虚拟的圆环，如下图所示，范围为0-2^32-1；<br>对于每个数据，根据key计算hash值，确定数据在环上的位置，然后从此位置沿环顺时针行走，找到的第一台服务器就是其应该映射到的服务<br>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a9276160a154a678f90b0.png\"  alt=\"05f4fff3be104b150815c7f4c8559701.png\">\n      </p>\n<p>与哈希取余分区相比，一致性哈希分区将增减节点的影响限制在相邻节点。</p>\n<p>以上图为例，如果在node1和node2之间增加node5，则只有node2中的一部分数据会迁移到node5；如果去掉node2，则原node2中的数据只会迁移到node4中，只有node4会受影响。</p>\n<p>一致性哈希分区的主要问题在于，当节点数量较少时，增加或删减节点，对单个节点的影响可能很大，造成数据的严重不平衡。以上图为例，如果去掉node2，node4中的数据由总数据的1/4左右变为1/2左右，与其他节点相比负载过高。</p>\n\n        <h4 id=\"带虚拟节点的一致性哈希分区\"   >\n          <a href=\"#带虚拟节点的一致性哈希分区\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>带虚拟节点的一致性哈希分区</h4>\n      <p>该方案在一致性哈希分区的基础上，引入了虚拟节点的概念。Redis集群使用的便是该方案，其中的虚拟节点称为槽（slot）。</p>\n<p>槽是介于数据和实际节点之间的虚拟概念；每个实际节点包含一定数量的槽，每个槽包含哈希值在一定范围内的数据。引入槽以后，数据的映射关系由数据hash-&gt;实际节点，变成了数据hash-&gt;槽-&gt;实际节点。</p>\n<p><strong>在使用了槽的一致性哈希分区中，槽是数据管理和迁移的基本单位。槽解耦了数据和实际节点之间的关系，增加或删除节点对系统的影响很小</strong>。以上图为例，系统中有4个实际节点，假设为其分配16个槽(0-15)； 槽0-3位于node1，4-7位于node2，以此类推。如果此时删除node2，只需要将槽4-7重新分配即可，例如槽4-5分配给node1，槽6分配给node3，槽7分配给node4；可以看出删除node2后，数据在其他节点的分布仍然较为均衡。</p>\n<p>槽的数量一般远小于2^32，远大于实际节点的数量；在Redis集群中，<strong>槽的默认数量为16384</strong>。</p>\n<p>下面这张图很好的总结了Redis集群将数据映射到实际节点的过程：<br>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a9276160a154a678f90a6.png\"  alt=\"00e2fdb3f2c1128c2e4a831a0185f555.png\">\n      </p>\n<ol>\n<li>Redis对数据的特征值（一般是key）计算哈希值，使用的算法是CRC16。</li>\n<li>根据哈希值，计算数据属于哪个槽。</li>\n<li>根据槽与节点的映射关系，计算数据属于哪个节点。</li>\n</ol>\n\n        <h3 id=\"节点通信机制\"   >\n          <a href=\"#节点通信机制\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>节点通信机制</h3>\n      <p>在哨兵系统中，节点分为数据节点和哨兵节点：前者存储数据，后者实现额外的控制功能。</p>\n<p>在集群中，没有数据节点与非数据节点之分：所有的节点都存储数据，也都参与集群状态的维护。</p>\n<p>为此，集群中的每个节点，都提供了两个TCP端口：</p>\n<ol>\n<li>普通端口：即我们在前面指定的端口(7000等)。普通端口主要用于为客户端提供服务（与单机节点类似）；但在节点间数据迁移时也会使用。</li>\n<li>集群端口：端口号是普通端口+10000（10000是固定值，无法改变），如7000节点的集群端口为17000。集群端口只用于节点之间的通信，如搭建集群、增减节点、故障转移等操作时节点间的通信；不要使用客户端连接集群接口。为了保证集群可以正常工作，在配置防火墙时，要同时开启普通端口和集群端口。</li>\n</ol>\n\n        <h4 id=\"Gossip协议\"   >\n          <a href=\"#Gossip协议\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Gossip协议</h4>\n      <p>节点间通信，按照通信协议可以分为几种类型：单对单、广播、Gossip协议等。重点是广播和Gossip的对比。</p>\n<p>广播是指向集群内所有节点发送消息；优点是集群的收敛速度快(集群收敛是指集群内所有节点获得的集群信息是一致的)，缺点是每条消息都要发送给所有节点，CPU、带宽等消耗较大。</p>\n<p>Gossip协议的特点是：在节点数量有限的网络中，每个节点都“随机”的与部分节点通信（并不是真正的随机，而是根据特定的规则选择通信的节点），经过一番杂乱无章的通信，每个节点的状态很快会达到一致。Gossip协议的优点有负载(比广播)低、去中心化、容错性高(因为通信有冗余)等；缺点主要是集群的收敛速度慢。</p>\n\n        <h4 id=\"消息类型\"   >\n          <a href=\"#消息类型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>消息类型</h4>\n      <p>集群中的节点采用固定频率（每秒10次）的定时任务进行通信相关的工作：<br>    判断是否需要发送消息及消息类型、确定接收节点、发送消息等。如果集群状态发生了变化，如增减节点、槽状态变更，通过节点间的通信，所有节点会很快得知整个集群的状态，使集群收敛。</p>\n<p>节点间发送的消息主要分为5种：meet消息、ping消息、pong消息、fail消息、publish消息。不同的消息类型，通信协议、发送的频率和时机、接收节点的选择等是不同的。</p>\n<ol>\n<li>MEET消息：在节点握手阶段，当节点收到客户端的CLUSTER MEET命令时，会向新加入的节点发送MEET消息，请求新节点加入到当前集群；新节点收到MEET消息后会回复一个PONG消息。</li>\n<li>PING消息：集群里每个节点每秒钟会选择部分节点发送PING消息，接收者收到消息后会回复一个PONG消息。PING消息的内容是自身节点和部分其他节点的状态信息；作用是彼此交换信息，以及检测节点是否在线。PING消息使用Gossip协议发送，接收节点的选择兼顾了收敛速度和带宽成本，具体规则如下：<ol>\n<li>随机找5个节点，在其中选择最久没有通信的1个节点</li>\n<li>扫描节点列表，选择最近一次收到PONG消息时间大于cluster_node_timeout/2的所有节点，防止这些节点长时间未更新。</li>\n</ol>\n</li>\n<li>PONG消息：PONG消息封装了自身状态数据。可以分为两种：<ol>\n<li>第一种是在接到MEET/PING消息后回复的PONG消息；</li>\n<li>第二种是指节点向集群广播PONG消息，这样其他节点可以获知该节点的最新信息，例如故障恢复后新的主节点会广播PONG消息。</li>\n</ol>\n</li>\n<li>FAIL消息：当一个主节点判断另一个主节点进入FAIL状态时，会向集群广播这一FAIL消息；接收节点会将这一FAIL消息保存起来，便于后续的判断。</li>\n<li>PUBLISH消息：节点收到PUBLISH命令后，会先执行该命令，然后向集群广播这一消息，接收节点也会执行该PUBLISH命令。</li>\n</ol>\n\n        <h2 id=\"集群方案设计\"   >\n          <a href=\"#集群方案设计\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>集群方案设计</h2>\n      <p>设计集群方案时，至少要考虑以下因素：</p>\n<ol>\n<li><p>高可用要求：根据故障转移的原理，至少需要3个主节点才能完成故障转移，且3个主节点不应在同一台物理机上；每个主节点至少需要1个从节点，且主从节点不应在一台物理机上；因此高可用集群至少包含6个节点。</p>\n</li>\n<li><p>数据量和访问量：估算应用需要的数据量和总访问量(考虑业务发展，留有冗余)，结合每个主节点的容量和能承受的访问量(可以通过benchmark得到较准确估计)，计算需要的主节点数量。</p>\n</li>\n<li><p>节点数量限制：Redis官方给出的节点数量限制为1000，主要是考虑节点间通信带来的消耗。在实际应用中应尽量避免大集群；如果节点数量不足以满足应用对Redis数据量和访问量的要求，可以考虑：</p>\n<ol>\n<li>业务分割，大集群分为多个小集群；</li>\n<li>减少不必要的数据；</li>\n<li>调整数据过期策略等。</li>\n</ol>\n</li>\n<li><p>适度冗余：Redis可以在不影响集群服务的情况下增加节点，因此节点数量适当冗余即可，不用太大。</p>\n</li>\n</ol>\n\n        <h2 id=\"实践须知\"   >\n          <a href=\"#实践须知\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>实践须知</h2>\n      \n        <h3 id=\"集群伸缩\"   >\n          <a href=\"#集群伸缩\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>集群伸缩</h3>\n      <p>实践中常常需要对集群进行伸缩，如访问量增大时的扩容操作。</p>\n<p>Redis集群可以在不影响对外服务的情况下实现伸缩；</p>\n<p><strong>伸缩的核心是槽迁移：修改槽与节点的对应关系，实现槽(即数据)在节点之间的移动</strong>。例如，如果槽均匀分布在集群的3个节点中，此时增加一个节点，则需要从3个节点中分别拿出一部分槽给新节点，从而实现槽在4个节点中的均匀分布。</p>\n<p>详见：<span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.cnblogs.com/kismetv/p/9853040.html\" >https://www.cnblogs.com/kismetv/p/9853040.html</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n\n        <h4 id=\"ASK错误\"   >\n          <a href=\"#ASK错误\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>ASK错误</h4>\n      <p>集群伸缩的核心是槽迁移。在槽迁移过程中，如果客户端向源节点发送命令，源节点执行流程如下：</p>\n<p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a9276160a154a678f90a8.png\"  alt=\"732dbf550bdcbc2806cca931d2797e3a.png\">\n      </p>\n<p>客户端收到ASK错误后，从中读取目标节点的地址信息，并向目标节点重新发送请求，就像收到MOVED错误时一样。</p>\n<p>但是二者有很大区别：ASK错误说明数据正在迁移，不知道何时迁移完成，因此重定向是临时的，SMART客户端不会刷新slots缓存；MOVED错误重定向则是(相对)永久的，SMART客户端会刷新slots缓存。</p>\n\n        <h3 id=\"故障转移\"   >\n          <a href=\"#故障转移\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>故障转移</h3>\n      <p>通过定时任务发送PING消息检测其他节点状态；节点下线分为主观下线和客观下线；客观下线后选取从节点进行故障转移。</p>\n<p>与哨兵一样，集群只实现了主节点的故障转移；从节点故障时只会被下线，不会进行故障转移。因此，使用集群时，应谨慎使用读写分离技术，因为从节点故障会导致读服务不可用，可用性变差。</p>\n\n        <h4 id=\"注意事项\"   >\n          <a href=\"#注意事项\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>注意事项</h4>\n      <ol>\n<li><p>节点数量：在故障转移阶段，需要由主节点投票选出哪个从节点成为新的主节点；从节点选举胜出需要的票数为N/2+1；其中N为主节点数量(包括故障主节点)，但故障主节点实际上不能投票。因此为了能够在故障发生时顺利选出从节点，集群中至少需要3个主节点(且部署在不同的物理机上)。</p>\n</li>\n<li><p>故障转移时间：从主节点故障发生到完成转移，所需要的时间主要消耗在主观下线识别、主观下线传播、选举延迟等几个环节；具体时间与参数cluster-node-timeout有关</p>\n<p> 一般来说：故障转移时间(毫秒) ≤ 1.5 * cluster-node-timeout + 1000<br> cluster-node-timeout的默认值为15000ms(15s)，因此故障转移时间会在20s量级。</p>\n</li>\n</ol>\n\n        <h3 id=\"集群的限制及应对方法\"   >\n          <a href=\"#集群的限制及应对方法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>集群的限制及应对方法</h3>\n      <p>由于集群中的数据分布在不同节点中，导致一些功能受限，包括：</p>\n<ol>\n<li><p>key批量操作受限：例如mget、mset操作，只有当操作的key都位于一个槽时，才能进行。针对该问题，一种思路是在客户端记录槽与key的信息，每次针对特定槽执行mget/mset；另外一种思路是使用Hash Tag，下面介绍。</p>\n</li>\n<li><p>keys/flushall等操作：keys/flushall等操作可以在任一节点执行，但是结果只针对当前节点，例如keys操作只返回当前节点的所有键。针对该问题，可以在客户端使用cluster nodes获取所有节点信息，并对其中的所有主节点执行keys/flushall等操作。</p>\n</li>\n<li><p>事务/Lua脚本：集群支持事务及Lua脚本，但前提条件是所涉及的key必须在同一个节点。Hash Tag可以解决该问题。</p>\n</li>\n<li><p>数据库：单机Redis节点可以支持16个数据库，集群模式下只支持一个，即db0。</p>\n</li>\n<li><p>复制结构：只支持一层复制结构，不支持嵌套。</p>\n</li>\n</ol>\n\n        <h3 id=\"Hash-Tag\"   >\n          <a href=\"#Hash-Tag\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Hash Tag</h3>\n      <p>Hash Tag原理是：当一个key包含 {} 的时候，不对整个key做hash，而仅对 {} 包括的字符串做hash。</p>\n<p>Hash Tag可以让不同的key拥有相同的hash值，从而分配在同一个槽里；这样针对不同key的批量操作(mget/mset等)，以及事务、Lua脚本等都可以支持。</p>\n<p>不过Hash Tag可能会带来数据分配不均的问题，这时需要：<br>    1. 调整不同节点中槽的数量，使数据分布尽量均匀；<br>    2. 避免对热点数据使用Hash Tag，导致请求分布不均。.</p>\n<p>下面是使用Hash Tag的一个例子；通过对product加Hash Tag，可以将所有产品信息放到同一个槽中，便于操作<br>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a9276160a154a678f90ab.png\"  alt=\"b6d7901eaa7a045e87b1326154f2bb56.png\">\n      </p>\n\n        <h3 id=\"参数优化\"   >\n          <a href=\"#参数优化\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>参数优化</h3>\n      <ol>\n<li><p>cluster_node_timeout</p>\n<p> cluster_node_timeout参数在前面已经初步介绍；它的默认值是15s，影响包括：</p>\n<ol>\n<li><p>影响PING消息接收节点的选择：值越大对延迟容忍度越高，选择的接收节点越少，可以降低带宽，但会降低收敛速度；应根据带宽情况和应用要求进行调整。</p>\n</li>\n<li><p>影响故障转移的判定和时间：值越大，越不容易误判，但完成转移消耗时间越长；应根据网络状况和应用要求进行调整。</p>\n</li>\n</ol>\n</li>\n<li><p>cluster-require-full-coverage</p>\n<p> 前面提到，只有当16384个槽全部分配完毕时，集群才能上线。这样做是为了保证集群的完整性，但同时也带来了新的问题：当主节点发生故障而故障转移尚未完成，原主节点中的槽不在任何节点中，此时会集群处于下线状态，无法响应客户端的请求。</p>\n<p> cluster-require-full-coverage参数可以改变这一设定：如果设置为no，则当槽没有完全分配时，集群仍可以上线。参数默认值为yes，如果应用对可用性要求较高，可以修改为no，但需要自己保证槽全部分配。</p>\n</li>\n</ol>\n\n        <h2 id=\"redis代理\"   >\n          <a href=\"#redis代理\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>redis代理</h2>\n      <p>无论是为了解决redis的高可用问题、还是为了可扩展性、或者是为了维护方便，用一款redis代理都是上佳的选择</p>\n<p>详见：<span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://blog.csdn.net/rebaic/article/details/76384028\" >https://blog.csdn.net/rebaic/article/details/76384028</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n<ul>\n<li>predixy</li>\n<li>twemproxy</li>\n<li>codis</li>\n<li>redis-cerberus</li>\n</ul>\n","categories":["Redis"],"tags":["Redis"]},{"title":"Redis的集群：主从复制、CAP","url":"/2020/09/23/redis%E7%9A%84%E9%9B%86%E7%BE%A4%EF%BC%9A%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E3%80%81CAP/","content":"\n        <h1 id=\"Redis的集群：主从复制、CAP\"   >\n          <a href=\"#Redis的集群：主从复制、CAP\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Redis的集群：主从复制、CAP</h1>\n      \n        <h2 id=\"CAP\"   >\n          <a href=\"#CAP\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>CAP</h2>\n      <p>指的是在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）。<br>CAP 原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾</p>\n<a id=\"more\"></a>\n\n\n<ul>\n<li>一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）</li>\n<li>可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</li>\n<li>分区容忍性（P）：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。</li>\n</ul>\n\n        <h3 id=\"CAP的取舍\"   >\n          <a href=\"#CAP的取舍\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>CAP的取舍</h3>\n      <ol>\n<li>满足CA舍弃P，也就是满足一致性和可用性，舍弃容错性。<br> 意味着你的系统不是分布式的了，因为涉及分布式的想法就是把功能分开，部署到不同的机器上。</li>\n<li>满足CP舍弃A，也就是满足一致性和容错性，舍弃可用性。<br> 如果系统允许有段时间的访问失效等问题，这个是可以满足的。比如多个人并发买票，后台网络出现故障，你买的时候系统就崩溃了。</li>\n<li>满足AP舍弃C，也就是满足可用性和容错性，舍弃一致性。<br> 意味着你的系统在并发访问的时候可能会出现数据不一致的情况。</li>\n</ol>\n<p>实时证明，大多数都是<strong>牺牲了一致性</strong>。比如12306、淘宝，假如你买火车票，本来你看到的是还有一张票，其实在这个时刻已经被买走了，你填好了信息准备买的时候发现系统提示你没票了。这就是牺牲了一致性。<br>但是不是说牺牲一致性一定是最好的。就好比mysql中的事务机制，张三给李四转了100块钱，这时候必须保证张三的账户上少了100，李四的账户多了100。因此需要数据的一致性，而且什么时候转钱都可以，也需要可用性。但是可以转钱失败是可以允许的。</p>\n<p><strong>总结：视情况而定</strong></p>\n\n        <h2 id=\"主从复制\"   >\n          <a href=\"#主从复制\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>主从复制</h2>\n      <p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。</p>\n\n        <h3 id=\"主从复制的作用\"   >\n          <a href=\"#主从复制的作用\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>主从复制的作用</h3>\n      <ol>\n<li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li>\n<li>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</li>\n<li>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li>\n<li>高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li>\n</ol>\n\n        <h3 id=\"基本操作\"   >\n          <a href=\"#基本操作\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>基本操作</h3>\n      <ol>\n<li>建立复制<ul>\n<li>主从复制的开启，完全是在从节点发起的；不需要在主节点做任何事情。</li>\n</ul>\n<ol>\n<li>配置文件<br> 在从服务器的配置文件中加入：slaveof <masterip> <masterport> （ip、端口号）<br> 例：slaveof 127.0.0.1 6379</li>\n<li>启动命令<br> redis-server启动命令后加入 –slaveof <masterip> <masterport></li>\n<li>客户端命令<br> Redis服务器启动后，直接通过客户端执行命令：slaveof <masterip> <masterport>，则该Redis实例成为从节点。</li>\n</ol>\n</li>\n<li>断开复制<br>可以通过slaveof no one断开。需要注意的是，从节点断开复制后，不会删除已有的数据，只是不再接受主节点新的数据变化。</li>\n</ol>\n\n        <h3 id=\"原理\"   >\n          <a href=\"#原理\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>原理</h3>\n      <p>主从复制过程大体可以分为3个阶段：连接建立阶段（即准备阶段）、数据同步阶段、命令传播阶段</p>\n\n        <h4 id=\"连接建立阶段\"   >\n          <a href=\"#连接建立阶段\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>连接建立阶段</h4>\n      <p>该阶段的主要作用是在主从节点之间建立连接，为数据同步做好准备</p>\n<ol>\n<li>保存主节点信息<br> 从节点服务器内部维护了两个字段，即masterhost和masterport字段，用于存储主节点的ip和port信息。<br> \n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a9137160a154a678f2405.png\"  alt=\"4c856835906262335cf9c2594aa80585.png\">\n      </li>\n<li>建立socket连接<br> 从节点每秒1次调用复制定时函数replicationCron()，如果发现了有主节点可以连接，便会根据主节点的ip和port，创建socket连接。如果连接成功，则：<br> 从节点：为该socket建立一个专门处理复制工作的文件事件处理器，负责后续的复制工作，如接收RDB文件、接收命令传播等。<br> 主节点：接收到从节点的socket连接后（即accept之后），为该socket创建相应的客户端状态，<strong>并将从节点看做是连接到主节点的一个客户端，后面的步骤会以从节点向主节点发送命令请求的形式来进行</strong>。<br> 这个过程中，从节点打印日志如下：<br> \n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a9136160a154a678f23f8.png\"  alt=\"5fa140714495faa19eebc329da1b4643.png\">\n      </li>\n<li>发送ping命令<br> 从节点成为主节点的客户端之后，发送ping命令进行首次请求，目的是：检查socket连接是否可用，以及主节点当前是否能够处理请求。<br> 从节点发送ping命令后，可能出现3种情况：<ol>\n<li>返回pong：说明socket连接正常，且主节点当前可以处理请求，复制过程继续。 </li>\n<li>超时：一定时间后从节点仍未收到主节点的回复，说明socket连接不可用，则从节点断开socket连接，并重连。</li>\n<li>返回pong以外的结果：如果主节点返回其他结果，如正在处理超时运行的脚本，说明主节点当前无法处理命令，则从节点断开socket连接，并重连。</li>\n</ol>\n</li>\n</ol>\n<pre><code>![ace63fa223d277b8c66226538c249f85.png](https://pic.downk.cc/item/5f6a9136160a154a678f23fb.png)</code></pre>\n<ol start=\"4\">\n<li>身份验证<br> 如果从节点中设置了masterauth选项，则从节点需要向主节点进行身份验证；<br> 没有设置该选项，则不需要验证。<br> 从节点进行身份验证是通过向主节点发送auth命令进行的，auth命令的参数即为配置文件中的masterauth的值。<br> 如果主节点设置密码的状态，与从节点masterauth的状态一致（一致是指都存在，且密码相同，或者都不存在），则身份验证通过，复制过程继续；如果不一致，则从节点断开socket连接，并重连。</li>\n<li>发送从节点端口信息<br> 身份验证之后，从节点会向主节点发送其监听的端口号，主节点将该信息保存到该从节点对应的客户端的slave_listening_port字段中；该端口信息除了在主节点中执行info Replication时显示以外，没有其他作用。</li>\n</ol>\n\n        <h4 id=\"数据同步阶段\"   >\n          <a href=\"#数据同步阶段\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>数据同步阶段</h4>\n      <p>主从节点之间的连接建立以后，便可以开始进行数据同步，该阶段可以理解为从节点数据的初始化。具体执行的方式是：从节点向主节点发送psync命令（Redis2.8以前是sync命令），开始同步</p>\n<p>数据同步阶段是主从复制最核心的阶段，根据主从节点当前状态的不同，可以分为<strong>全量复制和部分复制</strong>，后面详解</p>\n<p>需要注意的是，在数据同步阶段之前，从节点是主节点的客户端，主节点不是从节点的客户端；而到了这一阶段及以后，主从节点互为客户端。</p>\n<p>原因在于：在此之前，主节点只需要响应从节点的请求即可，不需要主动发请求，而在数据同步阶段和后面的命令传播阶段，主节点需要主动向从节点发送请求（如推送缓冲区中的写命令），才能完成复制。</p>\n\n        <h4 id=\"命令传播阶段\"   >\n          <a href=\"#命令传播阶段\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>命令传播阶段</h4>\n      <p>数据同步阶段完成后，主从节点进入命令传播阶段；在这个阶段主节点将自己执行的写命令发送给从节点，从节点接收命令并执行，从而保证主从节点数据的一致性。</p>\n<p>需要注意的是，命令传播是异步的过程，即主节点发送写命令后并不会等待从节点的回复；因此实际上主从节点之间很难保持实时的一致性，延迟在所难免。数据不一致的程度，与主从节点之间的网络状况、主节点写命令的执行频率、以及主节点中的repl-disable-tcp-nodelay配置等有关</p>\n<p>repl-disable-tcp-nodelay no：该配置作用于命令传播阶段，控制主节点是否禁止与从节点的TCP_NODELAY；默认no，即不禁止TCP_NODELAY。当设置为yes时，TCP会对包进行合并从而减少带宽，但是发送的频率会降低，从节点数据延迟增加，一致性变差；具体发送频率与Linux内核的配置有关，默认配置为40ms。当设置为no时，TCP会立马将主节点的数据发送给从节点，带宽增加但延迟变小。<br>一般来说，只有当应用对Redis数据不一致的容忍度较高，且主从节点之间网络状况不好时，才会设置为yes，多数情况使用默认值no。</p>\n\n        <h3 id=\"全量复制和部分-增量-复制（数据同步阶段）\"   >\n          <a href=\"#全量复制和部分-增量-复制（数据同步阶段）\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>全量复制和部分(增量)复制（数据同步阶段）</h3>\n      <p>全量复制：用于初次复制或其他无法进行部分复制的情况，将主节点中的所有数据都发送给从节点，是一个非常重型的操作。</p>\n<p>部分复制：用于网络中断等情况后的复制，只将中断期间主节点执行的写命令发送给从节点，与全量复制相比更加高效。需要注意的是，如果网络中断时间过长，导致主节点没有能够完整地保存中断期间执行的写命令，则无法进行部分复制，仍使用全量复制。</p>\n\n        <h4 id=\"全量复制\"   >\n          <a href=\"#全量复制\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>全量复制</h4>\n      <p>全量复制是非常重型的操作：</p>\n<ol>\n<li>主节点通过bgsave命令fork子进程进行RDB持久化，该过程是非常消耗CPU、内存(页表复制)、硬盘IO的</li>\n<li>主节点通过网络将RDB文件发送给从节点，对主从节点的带宽都会带来很大的消耗</li>\n<li>从节点清空老数据、载入新RDB文件的过程是阻塞的，无法响应客户端的命令；如果从节点执行bgrewriteaof，也会带来额外的消耗</li>\n</ol>\n\n        <h4 id=\"部分-增量-复制\"   >\n          <a href=\"#部分-增量-复制\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>部分(增量)复制</h4>\n      <p>部分复制的实现，依赖于三个重要的概念：</p>\n<ol>\n<li><p>复制偏移量<br> 主节点和从节点分别维护一个复制偏移量（offset），代表的是主节点向从节点传递的字节数。主节点每次向从节点传播N个字节数据时，主节点的offset增加N；从节点每次收到主节点传来的N个字节数据时，从节点的offset增加N。</p>\n<p> offset用于判断主从节点的数据库状态是否一致：如果二者offset相同，则一致；如果offset不同，则不一致，此时可以根据两个offset找出从节点缺少的那部分数据。</p>\n</li>\n<li><p>复制积压缓冲区<br> 复制积压缓冲区是由主节点维护的、固定长度的、先进先出(FIFO)队列，默认大小1MB；当主节点开始有从节点时创建，其作用是备份主节点最近发送给从节点的数据。</p>\n<p> 注意，无论主节点有一个还是多个从节点，都只需要一个复制积压缓冲区。</p>\n<p> 在命令传播阶段，主节点除了将写命令发送给从节点，还会发送一份给复制积压缓冲区，作为写命令的备份；除了存储写命令，复制积压缓冲区中还存储了其中的每个字节对应的复制偏移量（offset）。</p>\n<p> 由于复制积压缓冲区定长且是先进先出，所以它保存的是主节点最近执行的写命令；时间较早的写命令会被挤出缓冲区。</p>\n<p> 由于该缓冲区长度固定且有限，因此可以备份的写命令也有限，当主从节点offset的差距过大超过缓冲区长度时，将无法执行部分复制，只能执行全量复制</p>\n</li>\n<li><p>服务器运行ID(runid)<br> 每个Redis节点(无论主从)，在启动时都会自动生成一个随机ID(每次启动都不一样)，由40个随机的十六进制字符组成；runid用来唯一识别一个Redis节点。通过info Server命令，可以查看节点的runid：<br> \n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a9157160a154a678f2fd2.png\"  alt=\"9bee1df4c993279bce6f74c65911aa42.png\">\n      <br> 主从节点初次复制时，主节点将自己的runid发送给从节点，从节点将这个runid保存起来；当断线重连时，从节点会将这个runid发送给主节点；主节点根据runid判断能否进行部分复制：</p>\n<p> 如果从节点保存的runid与主节点现在的runid相同，说明主从节点之前同步过，主节点会继续尝试使用部分复制(到底能不能部分复制还要看offset和复制积压缓冲区的情况)；</p>\n<p> 如果从节点保存的runid与主节点现在的runid不同，说明从节点在断线前同步的Redis节点并不是当前的主节点，只能进行全量复制。</p>\n</li>\n</ol>\n\n        <h3 id=\"心跳机制（命令传播阶段）\"   >\n          <a href=\"#心跳机制（命令传播阶段）\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>心跳机制（命令传播阶段）</h3>\n      <p>在命令传播阶段，除了发送写命令，主从节点还维持着心跳机制：PING和REPLCONF ACK。心跳机制对于主从复制的超时判断、数据安全等有作用。</p>\n<ol>\n<li><p>主-&gt;从：PING<br> 每隔指定的时间，主节点会向从节点发送PING命令，这个PING命令的作用，主要是为了让从节点进行超时判断。</p>\n<p> PING发送的频率由repl-ping-slave-period参数控制，单位是秒，默认值是10s。</p>\n</li>\n<li><p>从-&gt;主：REPLCONF ACK<br> 在命令传播阶段，从节点会向主节点发送REPLCONF ACK命令，频率是每秒1次；命令格式为：REPLCONF ACK {offset}，其中offset指从节点保存的复制偏移量</p>\n</li>\n</ol>\n\n        <h3 id=\"相关配置\"   >\n          <a href=\"#相关配置\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>相关配置</h3>\n      <ol>\n<li><p>与主从节点都有关的配置</p>\n<ol>\n<li>slaveof <masterip> <masterport>：Redis启动时起作用；作用是建立复制关系，开启了该配置的Redis服务器在启动后成为从节点。该注释默认注释掉，即Redis服务器默认都是主节点。</li>\n<li>repl-timeout 60：与各个阶段主从节点连接超时判断有关，见前面的介绍。</li>\n</ol>\n</li>\n<li><p>主节点相关配置</p>\n<ol>\n<li><p>repl-diskless-sync no：作用于全量复制阶段，控制主节点是否使用diskless复制（无盘复制）。所谓diskless复制，是指在全量复制时，主节点不再先把数据写入RDB文件，而是直接写入slave的socket中，整个过程中不涉及硬盘；diskless复制在磁盘IO很慢而网速很快时更有优势。</p>\n</li>\n<li><p>repl-diskless-sync-delay 5：该配置作用于全量复制阶段，当主节点使用diskless复制时，该配置决定主节点向从节点发送之前停顿的时间，单位是秒；只有当diskless复制打开时有效，默认5s。之所以设置停顿时间，是基于以下两个考虑：(1)向slave的socket的传输一旦开始，新连接的slave只能等待当前数据传输结束，才能开始新的数据传输 (2)多个从节点有较大的概率在短时间内建立主从复制。</p>\n</li>\n<li><p>client-output-buffer-limit slave 256MB 64MB 60：与全量复制阶段主节点的缓冲区大小有关，见前面的介绍。</p>\n</li>\n<li><p>repl-disable-tcp-nodelay no：与命令传播阶段的延迟有关，见前面的介绍。</p>\n</li>\n<li><p>masterauth <master-password>：与连接建立阶段的身份验证有关，见前面的介绍。</p>\n</li>\n<li><p>repl-ping-slave-period 10：与命令传播阶段主从节点的超时判断有关，见前面的介绍。</p>\n</li>\n<li><p>repl-backlog-size 1mb：复制积压缓冲区的大小，见前面的介绍。</p>\n</li>\n<li><p>repl-backlog-ttl 3600：当主节点没有从节点时，复制积压缓冲区保留的时间，这样当断开的从节点重新连进来时，可以进行部分复制；默认3600s。如果设置为0，则永远不会释放复制积压缓冲区。</p>\n</li>\n<li><p>min-slaves-to-write 3与min-slaves-max-lag 10：规定了主节点的最小从节点数目，及对应的最大延迟，见前面的介绍。</p>\n</li>\n</ol>\n</li>\n<li><p>从节点相关配置</p>\n<ol>\n<li>slave-serve-stale-data yes：与从节点数据陈旧时是否响应客户端命令有关，见前面的介绍。</li>\n<li>slave-read-only yes：从节点是否只读；默认是只读的。由于从节点开启写操作容易导致主从节点的数据不一致，因此该配置尽量不要修改。</li>\n</ol>\n</li>\n</ol>\n\n        <h3 id=\"哨兵-（Sentinel）\"   >\n          <a href=\"#哨兵-（Sentinel）\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>哨兵 （Sentinel）</h3>\n      <p>主从复制的故障恢复无法自动化，哨兵实现了自动化的故障恢复。缺陷：写操作无法负载均衡；存储能力受到单机的限制。</p>\n<p><strong>哨兵的核心功能是主节点的自动故障转移。</strong><br>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a917a160a154a678f3ae0.png\"  alt=\"9d70590cb86e7852c84e4921c16e3e87.png\">\n      </p>\n<p>哨兵系统由一个或多个哨兵节点组成，哨兵节点是特殊的redis节点，不存储数据</p>\n\n        <h4 id=\"部署\"   >\n          <a href=\"#部署\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>部署</h4>\n      <ol>\n<li><p>部署主从节点<br> 哨兵系统中的主从节点，与普通的主从节点配置是一样的，并不需要做任何额外配置。下面分别是主节点（port=6379）和2个从节点（port=6380/6381）的配置文件<br> \n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a917a160a154a678f3ae3.png\"  alt=\"98b77293fb32b89404248224b96b55b5.png\">\n      </p>\n</li>\n<li><p>部署哨兵节点<br> 3个哨兵节点的配置几乎是完全一样的，主要区别在于端口号的不同（26379/26380/26381），下面以26379节点为例介绍节点的配置和启动方式<br> \n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a917a160a154a678f3ae7.png\"  alt=\"6acf94e9c3ac54485cd2a80b1b59b014.png\">\n      </p>\n<p> 其中，sentinel monitor mymaster 192.168.92.128 6379 2 配置的含义是：该哨兵节点监控192.168.92.128:6379这个主节点，该主节点的名称是mymaster，最后的2的含义与主节点的故障判定有关：至少需要2个哨兵节点同意，才能判定主节点故障并进行故障转移。</p>\n<p> \n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a917a160a154a678f3aea.png\"  alt=\"f9d444a1ed9260c268d987221dcb4386.png\">\n      </p>\n<p> 按照上述方式配置和启动之后，整个哨兵系统就启动完毕了。可以通过redis-cli连接哨兵节点进行验证，如下图所示：可以看出26379哨兵节点已经在监控mymaster主节点(即192.168.92.128:6379)，并发现了其2个从节点和另外2个哨兵节点<br> \n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a917a160a154a678f3af0.png\"  alt=\"d97f2bba09665ed9718dea8fa3cd5517.png\">\n      </p>\n</li>\n<li><p>演示故障转移</p>\n<ol>\n<li>首先，使用kill命令杀掉主节点<br>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a91c6160a154a678f5458.png\"  alt=\"443abab5ca3bd4fdad4b178cb21d945a.png\">\n      </li>\n<li>如果此时立即在哨兵节点中使用info Sentinel命令查看，会发现主节点还没有切换过来，因为哨兵发现主节点故障并转移，需要一段时间<br>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a91c6160a154a678f545d.png\"  alt=\"fcf4629928160c2cc5f00792a408bc85.png\">\n      </li>\n<li>一段时间以后，再次在哨兵节点中执行info Sentinel查看，发现主节点已经切换成6380节点<br>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a91c6160a154a678f5450.png\"  alt=\"544eb50b4d28397f02860a4e966526a1.png\">\n      <br>但是同时可以发现，哨兵节点认为新的主节点仍然有2个从节点，这是因为哨兵在将6380切换成主节点的同时，将6379节点置为其从节点；<br>虽然6379从节点已经挂掉，但是由于哨兵并不会对从节点进行客观下线，因此认为该从节点一直存在。当6379节点重新启动后，会自动变成6380节点的从节点。</li>\n<li>在故障转移阶段，哨兵和主从节点的配置文件都会被改写<ol>\n<li>对于主从节点，主要是slaveof配置的变化：新的主节点没有了slaveof配置，其从节点则slaveof新的主节点。</li>\n<li>对于哨兵节点，除了主从节点信息的变化，纪元(epoch)也会变化，下图中可以看到纪元相关的参数都+1了<br>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a91c6160a154a678f5452.png\"  alt=\"0733288d4f4e9ddd77201b32fcd0ad03.png\">\n      </li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n\n        <h4 id=\"总结\"   >\n          <a href=\"#总结\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>总结</h4>\n      <ol>\n<li><p>哨兵系统中的主从节点，与普通的主从节点并没有什么区别，故障发现和转移是由哨兵来控制和完成的。</p>\n</li>\n<li><p>哨兵节点本质上是redis节点。</p>\n</li>\n<li><p>每个哨兵节点，只需要配置监控主节点，便可以自动发现其他的哨兵节点和从节点。</p>\n</li>\n<li><p>在哨兵节点启动和故障转移阶段，各个节点的配置文件会被重写(config rewrite)。</p>\n</li>\n<li><p>一个哨兵可以监控多个主节点，通过配置多条sentinel monitor即可实现</p>\n</li>\n</ol>\n\n        <h4 id=\"实践建议\"   >\n          <a href=\"#实践建议\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>实践建议</h4>\n      <ol>\n<li><p>哨兵节点的数量应不止一个，一方面增加哨兵节点的冗余，避免哨兵本身成为高可用的瓶颈；另一方面减少对下线的误判。此外，这些不同的哨兵节点应部署在不同的物理机上。</p>\n</li>\n<li><p>哨兵节点的数量应该是<strong>奇数</strong>，便于哨兵通过投票做出“决策”：领导者选举的决策、客观下线的决策等。</p>\n</li>\n<li><p>各个哨兵节点的配置应一致，包括硬件、参数等；此外，所有节点都应该使用ntp或类似服务，保证时间准确、一致。</p>\n</li>\n<li><p>哨兵的配置提供者和通知客户端功能，需要客户端的支持才能实现，如Jedis；如果开发者使用的库未提供相应支持，则可能需要开发者自己实现。</p>\n</li>\n<li><p>当哨兵系统中的节点在docker（或其他可能进行端口映射的软件）中部署时，应特别注意端口映射可能会导致哨兵系统无法正常工作，因为哨兵的工作基于与其他节点的通信，而docker的端口映射可能导致哨兵无法连接到其他节点。例如，哨兵之间互相发现，依赖于它们对外宣称的IP和port，如果某个哨兵A部署在做了端口映射的docker中，那么其他哨兵使用A宣称的port无法连接到A。</p>\n</li>\n</ol>\n\n        <h4 id=\"详细研究阅读\"   >\n          <a href=\"#详细研究阅读\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>详细研究阅读</h4>\n      <p><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.cnblogs.com/kismetv/p/9236731.html\" >https://www.cnblogs.com/kismetv/p/9236731.html</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span><br>深入学习Redis（3）：主从复制</p>\n<p><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.cnblogs.com/kismetv/p/9609938.html\" >https://www.cnblogs.com/kismetv/p/9609938.html</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span><br>深入学习Redis（4）：哨兵</p>\n","categories":["Redis"],"tags":["Redis"]},{"title":"Redis的持久化RDB、fork、copyonwrite、AOF、RDB&AOF混合使用","url":"/2020/09/23/redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96RDB%E3%80%81fork%E3%80%81copyonwrite%E3%80%81AOF%E3%80%81RDB-AOF%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8/","content":"\n        <h1 id=\"Redis的持久化RDB、fork、copyonwrite、AOF、RDB-amp-AOF混合使用\"   >\n          <a href=\"#Redis的持久化RDB、fork、copyonwrite、AOF、RDB-amp-AOF混合使用\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Redis的持久化RDB、fork、copyonwrite、AOF、RDB&amp;AOF混合使用</h1>\n      \n        <h2 id=\"RDB持久化\"   >\n          <a href=\"#RDB持久化\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>RDB持久化</h2>\n      <p>RDB是Redis用来进行持久化的一种方式，是把当前内存中的数据集快照写入磁盘，恢复时是将快照文件直接读到内存里</p>\n\n        <h3 id=\"触发方式\"   >\n          <a href=\"#触发方式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>触发方式</h3>\n      <p>RDB 有两种触发方式，分别是自动触发和手动触发</p>\n<a id=\"more\"></a>\n\n<ol>\n<li>自动触发<ul>\n<li>在 redis.conf 配置文件中的 SNAPSHOTTING 下<ol>\n<li>save：用来配置触发 Redis的 RDB 持久化条件，也就是什么时候将内存中的数据保存到硬盘。比如“save m n”。表示m秒内数据有n次修改时，自动触发bgsave。如果不需要持久化，那么你可以注释掉所有的 save 行来停用保存功能，也可以直接一个空字符串来实现停用：save “”<br>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a9090160a154a678eeb3d.png\"  alt=\"a550fbdd95d0f98886d59549dfd68eea.png\">\n      </li>\n<li>stop-writes-on-bgsave-error ：默认值为yes。当启用了RDB且最后一次后台保存数据失败，Redis是否停止接收数据。这会让用户意识到数据没有正确持久化到磁盘上，否则没有人会注意到灾难（disaster）发生了。如果Redis重启了，那么又可以重新开始接收数据了</li>\n<li>rdbcompression ；默认值是yes。对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能，但是存储在磁盘上的快照会比较大。</li>\n<li>rdbchecksum ：默认值是yes。在存储快照后，我们还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。</li>\n<li>dbfilename ：设置快照的文件名，默认是 dump.rdb </li>\n<li>dir：设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名。默认是和当前配置文件保存在同一目录。</li>\n</ol>\n</li>\n<li>也就是说通过在配置文件中配置的 save 方式，当实际操作满足该配置形式时就会进行 RDB 持久化，将当前的内存快照保存在 dir 配置的目录中，文件名由配置的 dbfilename 决定。</li>\n</ul>\n</li>\n<li>手动触发<ol>\n<li>save<br> 该命令会阻塞当前Redis服务器，执行save命令期间，Redis不能处理其他命令，直到RDB过程完成为止。场景：关机维护</li>\n<li>bgsave<br> 执行该命令时，Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。具体操作是Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。<br> 基本上 Redis 内部所有的RDB操作都是采用 bgsave 命令。</li>\n</ol>\n</li>\n</ol>\n\n        <h3 id=\"恢复数据\"   >\n          <a href=\"#恢复数据\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>恢复数据</h3>\n      <p>将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可，redis就会自动加载文件数据至内存了。Redis 服务器在载入 RDB 文件期间，会一直处于阻塞状态，直到载入工作完成为止。　　<br>获取 redis 的安装目录可以使用 config get dir 命令<br>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a9060160a154a678edbd7.png\"  alt=\"4e0051fc9660d2ba8dec2f2829a57638.png\">\n      <br>载入的标识是如下命令：<br>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a9060160a154a678edbcd.png\"  alt=\"3d1e30c7dec6765e2ece8e0b29b30d8f.png\">\n      </p>\n\n        <h3 id=\"优劣势\"   >\n          <a href=\"#优劣势\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>优劣势</h3>\n      <ul>\n<li>优势<ol>\n<li>RDB是一个非常紧凑(compact)的文件，它保存了redis在某个时间点上的数据集。这种文件非常适合用于进行备份和灾难恢复。　　</li>\n<li>生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。　　</li>\n<li>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。　　</li>\n</ol>\n</li>\n<li>劣势　　<ol>\n<li>RDB方式数据没办法做到实时持久化/秒级持久化。因为bgsave每次运行都要执行fork操作创建子进程，属于重量级操作，如果不采用压缩算法(内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑)，频繁执行<strong>成本过高</strong>(<strong>影响性能</strong>)　　</li>\n<li>RDB文件使用特定二进制格式保存，Redis版本演进过程中有多个格式的RDB版本，存在老版本Redis服务无法兼容新版RDB格式的问题(<strong>版本不兼容</strong>)　　</li>\n<li>在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改(<strong>数据有丢失</strong>)</li>\n<li>不支持拉链，只有一个dump.rdb，需要人工维护，比如每天拷出来</li>\n</ol>\n</li>\n</ul>\n<p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a9060160a154a678edbd0.png\"  alt=\"794f18b9759fe063c0978938faf1021d.png\">\n      </p>\n\n        <h2 id=\"fork-、copyonwrite\"   >\n          <a href=\"#fork-、copyonwrite\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>fork()、copyonwrite</h2>\n      <p>fork（）函数通过系统调用创建一个与原来进程几乎完全相同的进程</p>\n<p>RDB就是利用了fork()，在继续提供服务的同时，另一个进程进行持久化，创建子进程并不发生复制。父子进程中的值指向的内存地址是同一个，但是当其中一个进程改变这个值时，会复制一份发生改变并将指针指向新的地址，不影响另一个进程，这就是copy on write。</p>\n<p>速度快了，占用空间小了</p>\n<ul>\n<li>copy on write是内核机制</li>\n</ul>\n\n        <h2 id=\"AOF\"   >\n          <a href=\"#AOF\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>AOF</h2>\n      <p>AOF 是通过保存Redis服务器所执行的写命令来记录数据库状态<br>比如对于如下命令：<br>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a90a6160a154a678ef26b.png\"  alt=\"0e7a158d6187b4ae63d6e9c9e7a5004a.png\">\n      </p>\n<ul>\n<li>RDB 持久化方式就是将 str1,str2,str3 这三个键值对保存到 RDB文件中</li>\n<li>AOF 持久化则是将执行的 set,sadd,lpush 三个命令保存到 AOF 文件中</li>\n</ul>\n\n        <h3 id=\"配置\"   >\n          <a href=\"#配置\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>配置</h3>\n      <p>在 redis.conf 配置文件的 APPEND ONLY MODE 下：<br>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a90a6160a154a678ef267.png\"  alt=\"328d63bce0356e7717c7112cc67c7ddf.png\">\n      </p>\n<ol>\n<li><p>appendonly：默认值为no，redis默认是rdb方式持久化，要开启AOF持久化方式，需要将appendonly修改为yes。</p>\n</li>\n<li><p>appendfilename ：aof文件名，默认是”appendonly.aof”</p>\n</li>\n<li><p>appendfsync：aof持久化策略的配置；</p>\n<ol>\n<li>no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快，但是不太安全；</li>\n<li>always表示每次写入都执行fsync，以保证数据同步到磁盘，效率很低；</li>\n<li>everysec表示每秒执行一次fsync，可能会导致丢失这1s数据。通常选择 everysec ，兼顾安全性和效率，也是默认值。</li>\n</ol>\n</li>\n<li><p>no-appendfsync-on-rewrite：在aof重写或者写入rdb文件的时候，会执行大量IO，此时对于everysec和always的aof模式来说，执行fsync会造成阻塞过长时间，no-appendfsync-on-rewrite默认为no。如果对延迟要求很高的应用，这个字段可以设置为yes，否则还是设置为no，这样对持久化特性来说这是更安全的选择。   设置为yes表示rewrite期间对新写操作不fsync,暂时存在内存中,等rewrite完成后再写入，默认为no，建议yes。Linux的默认fsync策略是30秒。可能丢失30秒数据。默认值为no。</p>\n</li>\n<li><p>auto-aof-rewrite-percentage：默认值100。aof自动重写配置，当目前aof文件大小超过上一次重写的aof文件大小的百分之多少进行重写，即当aof文件增长到一定大小的时候，Redis能够调用bgrewriteaof对日志文件进行重写。当前AOF文件大小是上次日志重写得到AOF文件大小的二倍（设置为100）时，自动启动新的日志重写过程。</p>\n</li>\n<li><p>auto-aof-rewrite-min-size：64mb。设置允许重写的最小aof文件大小，避免了达到约定百分比但尺寸仍然很小的情况还要重写。</p>\n</li>\n<li><p>aof-load-truncated：aof文件可能在尾部是不完整的，当redis启动的时候，aof文件的数据被载入内存。重启可能发生在redis所在的主机操作系统宕机后，尤其在ext4文件系统没有加上data=ordered选项，出现这种现象  redis宕机或者异常终止不会造成尾部不完整现象，可以选择让redis退出，或者导入尽可能多的数据。如果选择的是yes，当截断的aof文件被导入的时候，会自动发布一个log给客户端然后load。如果是no，用户必须手动redis-check-aof修复AOF文件才可以。默认值为 yes。</p>\n</li>\n</ol>\n\n        <h3 id=\"开启AOF\"   >\n          <a href=\"#开启AOF\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>开启AOF</h3>\n      <p>将 redis.conf 的 appendonly 配置改为 yes 即可。</p>\n\n        <h3 id=\"AOF-文件恢复\"   >\n          <a href=\"#AOF-文件恢复\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>AOF 文件恢复</h3>\n      <p>重启 Redis 之后就会进行 AOF 文件的载入。　　<br>异常修复命令：redis-check-aof –fix 进行修复</p>\n\n        <h3 id=\"AOF-重写\"   >\n          <a href=\"#AOF-重写\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>AOF 重写</h3>\n      <p>由于AOF持久化是Redis不断将写命令记录到 AOF 文件中，随着Redis不断的进行，AOF 的文件会越来越大，文件越大，占用服务器内存越大以及 AOF 恢复要求时间越长。<br>为了解决这个问题，Redis新增了重写机制，当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。<br>可以使用命令 bgrewriteaof 来重写。</p>\n<p>比如对于如下命令：<br>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a90e0160a154a678f054d.png\"  alt=\"6bacc180b2f3ea7764576f7b6127a287.png\">\n      <br>如果不进行 AOF 文件重写，那么 AOF 文件将保存四条 SADD 命令，如果使用AOF 重写，那么AOF 文件中将只会保留下面一条命令：</p>\n<figure class=\"highlight plain\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">sadd animals &quot;dog&quot; &quot;tiger&quot; &quot;panda&quot; &quot;lion&quot; &quot;cat&quot;</span><br></pre></td></tr></table></div></figure>\n<ul>\n<li>默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发</li>\n</ul>\n<p>Redis 是单线程工作，如果 重写 AOF 需要比较长的时间，那么在重写 AOF 期间，Redis将长时间无法处理其他的命令，这显然是不能忍受的。Redis为了克服这个问题，解决办法是将 AOF 重写程序放到子程序中进行，这样有两个好处：</p>\n<ol>\n<li>子进程进行 AOF 重写期间，服务器进程（父进程）可以继续处理其他命令。　　</li>\n<li>子进程带有父进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。　　</li>\n</ol>\n<p>使用子进程解决了上面的问题，但是新问题也产生了：因为子进程在进行 AOF 重写期间，服务器进程依然在处理其它命令，这新的命令有可能也对数据库进行了修改操作，使得当前数据库状态和重写后的 AOF 文件状态不一致。　　<br>为了解决这个数据状态不一致的问题，Redis 服务器设置了一个 AOF 重写缓冲区，这个缓冲区是在创建子进程后开始使用，当Redis服务器执行一个写命令之后，就会将这个写命令也发送到 AOF 重写缓冲区。<br>当子进程完成 AOF 重写之后，就会给父进程发送一个信号，父进程接收此信号后，就会调用函数将 AOF 重写缓冲区的内容都写到新的 AOF 文件中。这样将 AOF 重写对服务器造成的影响降到了最低。</p>\n\n        <h3 id=\"AOF的优缺点\"   >\n          <a href=\"#AOF的优缺点\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>AOF的优缺点</h3>\n      <p>优点：</p>\n<ol>\n<li>AOF 持久化的方法提供了多种的同步频率，即使使用默认的同步频率每秒同步一次，Redis 最多也就丢失 1 秒的数据而已(<strong>丢失数据少</strong>)　　</li>\n<li>AOF 文件使用 Redis 命令追加的形式来构造，因此，即使 Redis 只能向 AOF 文件写入命令的片断，使用 redis-check-aof 工具也很容易修正 AOF 文件。</li>\n<li>AOF 文件的格式可读性较强，容易修正。例如，如果我们不小心错用了 FLUSHALL 命令，在重写还没进行时，我们可以手工将最后的 FLUSHALL 命令去掉，然后再使用 AOF 来恢复数据。</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>AOF 文件比 RDF 文件体积更大</li>\n<li>虽然 AOF 提供了多种同步的频率，默认情况下，每秒同步一次的频率也具有较高的性能。但在 Redis 的负载较高时，RDB 比 AOF 具好更好的性能保证。（RDB 比 AOF性能高）</li>\n<li>RDB 使用快照的形式来持久化整个 Redis 数据，而 AOF 只是将每次执行的命令追加到 AOF 文件中，因此从理论上说，<strong>RDB 比 AOF 方式更健壮</strong>。官方文档也指出，AOF 的确也存在一些 BUG，这些 BUG 在 RDB 没有存在。 　　</li>\n</ol>\n\n        <h3 id=\"如何选择AOF-和-RDB\"   >\n          <a href=\"#如何选择AOF-和-RDB\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>如何选择AOF 和 RDB</h3>\n      <p>如果可以忍受一小段时间内数据的丢失，毫无疑问使用 RDB 是最好的，定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快，而且使用 RDB 还可以避免 AOF 一些隐藏的 bug；否则就使用 AOF 重写。但是一般情况下建议不要单独使用某一种持久化机制，而是应该两种一起用，在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。Redis后期官方可能都有将两种持久化方式整合为一种持久化模型。</p>\n\n        <h2 id=\"RDB-AOF混合持久化\"   >\n          <a href=\"#RDB-AOF混合持久化\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>RDB-AOF混合持久化</h2>\n      <p>在redis4.0之后，支持RDB-AOF混合持久化方式，这种方式结合了RDB和AOF的优点，既能快速加载又能避免丢失过多的数据。</p>\n<p>配置：aof-use-rdb-preamble设置为yes表示开启，设置为no表示禁用。</p>\n<p>当开启混合持久化时，主进程先fork出子进程将现有内存副本全量以RDB方式写入aof文件中，然后将缓冲区中的增量命令以AOF方式写入aof文件中，写入完成后通知主进程更新相关信息，并将新的含有 RDB和AOF两种格式的aof文件替换旧的aof文件。　　</p>\n<p>简单来说：混合持久化方式产生的文件一部分是RDB格式，一部分是AOF格式。</p>\n<p>缺点就是不能兼容Redis4.0之前版本的备份文件了。</p>\n","categories":["Redis"],"tags":["Redis"]},{"title":"Redis的消息订阅、pipeline、事务、modules、布隆过滤器、缓存LRU","url":"/2020/09/23/Redis%E7%9A%84%E6%B6%88%E6%81%AF%E8%AE%A2%E9%98%85%E3%80%81pipeline%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81modules%E3%80%81%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E3%80%81%E7%BC%93%E5%AD%98LRU/","content":"\n        <h1 id=\"redis的消息订阅、pipeline、事务、modules、布隆过滤器、缓存LRU\"   >\n          <a href=\"#redis的消息订阅、pipeline、事务、modules、布隆过滤器、缓存LRU\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>redis的消息订阅、pipeline、事务、modules、布隆过滤器、缓存LRU</h1>\n      \n        <h2 id=\"消息订阅\"   >\n          <a href=\"#消息订阅\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>消息订阅</h2>\n      <p>Publish 命令用于将信息发送到指定的频道</p>\n<p>Subscribe 命令用于订阅给定的一个或多个频道的信息</p>\n<ul>\n<li>只有订阅后才能收到Publish的消息，之前的消息收不到<br>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a8f82160a154a678e6ebf.png\"  alt=\"8b236951b1b7cf3d33f4b64843ed8e5d.png\">\n      <br>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a8f82160a154a678e6eb2.png\"  alt=\"accd13013b4e1c3a748af1b1054d196e.png\">\n      </li>\n</ul>\n<a id=\"more\"></a>\n\n\n        <h3 id=\"应用场景\"   >\n          <a href=\"#应用场景\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>应用场景</h3>\n      <p>在线聊天、消息推送…<br>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a8f82160a154a678e6eb4.png\"  alt=\"a1c5023f01ff7089c33cbffeb951e4a1.png\">\n      <br>实时消息可以使用发布订阅，短期历史消息可以使用zset（有序集合）<br>也可以再使用一个redis，订阅到发布的消息后做zset<br>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a8f82160a154a678e6eb8.png\"  alt=\"66b9bbbcd1530bd75b88332bb82eda14.png\">\n      </p>\n\n        <h2 id=\"pipeline-管道\"   >\n          <a href=\"#pipeline-管道\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>pipeline 管道</h2>\n      <p>简单来说就是<strong>把一组命令打包，然后一次发送过去</strong></p>\n<p>pipeline省略由于单线程导致的命令排队时间，一次命令的消耗时间=一次网络时间 + 命令执行时间<br>比起命令执行时间，网络时间很可能成为系统的瓶颈<br>pipeline的作用是将一批命令进行打包，然后发送给服务器，服务器执行完按顺序打包返回。<br>通过pipeline，一次pipeline（n条命令）=一次网络时间 + n次命令时间</p>\n<p>注意事项：</p>\n<ol>\n<li>每次pipeline携带数量不推荐过大，否则会影响网络性能</li>\n<li>pipeline每次只能作用在一个Redis节点上</li>\n</ol>\n\n        <h2 id=\"事务\"   >\n          <a href=\"#事务\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>事务</h2>\n      <p>Redis 事务的本质是一组命令的集合。redis事务就是<strong>一次性、顺序性、排他性</strong>的执行一个队列中的一系列命令。Redis事务没有隔离级别的概念，因为在发送EXEC命令前被放入队列缓存，并不会被实际执行</p>\n<p>Redis中，<strong>单条命令是原子性</strong>执行的，但事务<strong>不保证原子性</strong>，且<strong>没有回滚</strong>。事务中任意命令执行失败，其余的命令仍会被执行。</p>\n\n        <h3 id=\"命令\"   >\n          <a href=\"#命令\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>命令</h3>\n      <p>watch 命令用于监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断<br>multi : 标记一个事务块的开始<br>exec : 执行所有事务块的命令 （ 一旦执行exec后，之前加的监控锁都会被取消掉 ）　　　discard : 取消事务，放弃事务块中的所有命令<br>unwatch : 取消watch对所有key的监控</p>\n\n        <h3 id=\"案例\"   >\n          <a href=\"#案例\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>案例</h3>\n      <ol>\n<li>正常<br> \n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a8fac160a154a678e7c53.png\"  alt=\"65849938dd3f52894217db463dbac09d.png\">\n      </li>\n<li>放弃事务<br> \n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a8fab160a154a678e7c3a.png\"  alt=\"f28077314a3cacb8c1c76e498efbed96.png\">\n      </li>\n<li>若在事务队列中存在<strong>命令性错误</strong>（类似于java编译性错误），则执行EXEC命令时，所有命令都不会执行<br> \n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a8fab160a154a678e7c3c.png\"  alt=\"4ff07222beecab343cdbb00c2cd3bc41.png\">\n      </li>\n<li>若在事务队列中存在<strong>语法性错误</strong>（类似于java的运行时异常），则执行EXEC命令时，其他正确命令会被执行，错误命令抛出异常。<br> \n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a8fab160a154a678e7c40.png\"  alt=\"1ff66a6f00f4db9b8eb223277339cea8.png\">\n      </li>\n<li>使用watch<br> \n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a8fab160a154a678e7c49.png\"  alt=\"6be096c42a852bf9331352584ed60b86.png\">\n      </li>\n</ol>\n\n        <h2 id=\"modules\"   >\n          <a href=\"#modules\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>modules</h2>\n      <p>redis可以添加其他的模块</p>\n\n        <h2 id=\"布隆过滤器（RedisBloom）\"   >\n          <a href=\"#布隆过滤器（RedisBloom）\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>布隆过滤器（RedisBloom）</h2>\n      \n        <h3 id=\"缓存穿透\"   >\n          <a href=\"#缓存穿透\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>缓存穿透</h3>\n      <p>一般情况下，先查询缓存是否有该条数据，缓存中没有时，再查询数据库。当数据库也不存在该条数据时，每次查询都要访问数据库，这就是<strong>缓存穿透</strong>。<br>缓存穿透带来的问题是，当有大量请求查询数据库不存在的数据时，就会给数据库带来压力，甚至会拖垮数据库。<br>可以使用布隆过滤器解决缓存穿透的问题，把已存在数据的key存在布隆过滤器中。当有新的请求时，先到布隆过滤器中查询是否存在，如果不存在该条数据直接返回；如果存在该条数据再查询缓存查询数据库。</p>\n\n        <h3 id=\"原理简介\"   >\n          <a href=\"#原理简介\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>原理简介</h3>\n      <p>布隆过滤器是一个BIT数组。<br>向布隆过滤器中添加元素时，会使用多个无偏哈希函数对元素进行哈希，算出一个整数索引值，然后对位数组长度进行取模运算得到一个位置，每个无偏哈希函数都会得到一个不同的位置。再把位数组的这几个位置都设置为1，这就完成了bf.add命令的操作。<br>判断是否存在时，和添加元素一样，也会把哈希的几个位置算出来，然后看看位数组中对应的几个位置是否都为1，只要有一个位为0，就说明不存在。如果这几个位置都为1，并不能完全说明这个元素就一定存在，有可能这些位置为1是因为其他元素的存在，这就是布隆过滤器会出现误判的原因。<br>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a9002160a154a678eb149.png\"  alt=\"5d1b22a5588931cefae31c2773a90356.png\">\n      <br>元素1、2是已有的，分别计算单有可能会hash碰撞<br>元素3展示误判情况，虽然都是1，但有可能不是同一商品造成的1<br>如果出现了3的情况，可以增加redis中的key，value标记他在数据库中不存在，下次再遇到就会直接get到key是不存在的</p>\n<p>当数据库中增加是，bloom过滤器中也要增加</p>\n\n        <h3 id=\"布隆过滤器不支持删除\"   >\n          <a href=\"#布隆过滤器不支持删除\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>布隆过滤器不支持删除</h3>\n      \n        <h3 id=\"基本使用\"   >\n          <a href=\"#基本使用\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>基本使用</h3>\n      <ol>\n<li>bf.add 添加元素到布隆过滤器</li>\n<li>bf.exists 判断元素是否在布隆过滤器</li>\n<li>bf.madd 添加多个元素到布隆过滤器，bf.add只能添加一个</li>\n<li>bf.mexists 判断多个元素是否在布隆过滤器</li>\n<li>bf.reserve命令创建一个自定义的布隆过滤器，有3个参数<ol>\n<li>key：键</li>\n<li>error_rate：期望错误率，期望错误率越低，需要的空间就越大</li>\n<li>capacity：初始容量，当实际元素的数量超过这个初始化容量时，误判率上升<br>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a9002160a154a678eb147.png\"  alt=\"c40d339c61e52660e033e90ade9ebb8c.png\">\n      </li>\n<li>如果对应的key已经存在时，在执行bf.reserve命令就会报错。如果不使用bf.reserve命令创建，而是使用Redis自动创建的布隆过滤器，<strong>默认的error_rate是 0.01，capacity是 100</strong>。</li>\n</ol>\n</li>\n</ol>\n\n        <h3 id=\"优化升级\"   >\n          <a href=\"#优化升级\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>优化升级</h3>\n      \n        <h4 id=\"Counting-Bloom\"   >\n          <a href=\"#Counting-Bloom\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Counting Bloom</h4>\n      <p>升级版的布隆过滤器: Counting Bloom Filter</p>\n<ul>\n<li>原理是把位图的位 升级为计数器，实现了删除功能\n        <h4 id=\"布谷鸟过滤器\"   >\n          <a href=\"#布谷鸟过滤器\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>布谷鸟过滤器</h4>\n      布谷鸟过滤器(Cuckoo filter)</li>\n<li>一维数组实现的</li>\n<li>使用两个 hash 算法将新来的元素映射到数组的两个位置。如果两个位置中有一个位置位空, 那么就可以将元素直接放进去。但是如果这两个位置都满了, 它就会随机踢走一个, 然后自己霸占了这个位置，并会为这个被踢走的数据, 找一个新家</li>\n<li>假如数组太过拥挤, 踢了几十次仍然没有找到空缺的位置, 那就需要为数组扩容了</li>\n<li>改良方案：<ol>\n<li>增加 hash 函数, 让每个元素不止有两个巢</li>\n<li>每个位置上挂多个巢（链表）</li>\n<li>以上两种结合</li>\n</ol>\n</li>\n<li>缺点：无法对同一个数据连续插入，如果连续插入同一个数据, 马上会触发扩容（同一个数据怎么计算结果都一样）</li>\n</ul>\n\n        <h2 id=\"redis作为缓存\"   >\n          <a href=\"#redis作为缓存\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>redis作为缓存</h2>\n      <p>redis作为数据库/缓存的区别：</p>\n<ol>\n<li>缓存数据相对不重要</li>\n<li>缓存不是全量数据</li>\n<li>缓存应该随着访问变化，以热数据为主</li>\n</ol>\n<ul>\n<li>缓存减少后端压力，速度快</li>\n</ul>\n<ol>\n<li><p>内存是有限，随着访问的变化，应该淘汰掉冷数据<br> 内存大小可以通过maxmemory <bytes>配置，单位是byte<br> maxmemory-policy配置回收策略</p>\n<ul>\n<li><p>noeviction 不删除键，返回错误信息(redis默认选项)</p>\n</li>\n<li><p>volatile-lru 使用LRU算法删除一个键(只针对设置了过期时间的key　　</p>\n</li>\n<li><p>allkeys-lru 使用LRU算法删除一个键</p>\n</li>\n<li><p>volatile-lfu 使用LFU算法删除一个键(只针对设置了过期时间的键)　　</p>\n</li>\n<li><p>allkeys-lfu 使用LFU算法删除一个键</p>\n</li>\n<li><p>volatile-random 随机删除一个键(只针对设置了过期时间的键)　　</p>\n</li>\n<li><p>allkeys-random 随机删除一个键　　</p>\n</li>\n<li><p>volatile-ttl 删除最早过期的一个键</p>\n<p>一般作为缓存使用allkeys-lru和volatile-lru    </p>\n</li>\n<li><p>LFU   用了多少次；   LRU  多久没用的</p>\n</li>\n</ul>\n</li>\n<li><p>key的有效期</p>\n<ol>\n<li>有效期可以set时设置，也可以使用EXPIRE设置</li>\n<li>对已经有过期时间的key执行EXPIRE操作，将会更新它的过期时间</li>\n<li>访问（get）不会重置、刷新过期时间</li>\n<li>set会移除过期时间</li>\n<li>EXPIREAT key “timestamp”设置一个key在”timestamp”(时间戳(秒))之后过期</li>\n<li>ttl获取过期时间</li>\n<li>PERSIST移除过期时间</li>\n</ol>\n</li>\n<li><p>redis清除过期时间</p>\n<ol>\n<li>被动清除<br> 主动访问一个过期的key时，redis会将其直接从内存中删除。但是如果一个过期key永远不访问就会一直占用空间</li>\n<li>主动清除<br> redis在周期性执行的函数中会主动清理，redis采用了一个随机算法：<br> 随机的抽取N(默认100)个被设置了过期时间的key，检查这其中已经过期的key，将其清除。如果清除比例超过了25%（默认），则会再进行一次主动清理，直到过期key在25%以下</li>\n<li>内存不足时触发主动清理</li>\n</ol>\n</li>\n</ol>\n","categories":["Redis"],"tags":["Redis"]},{"title":"Redis的类型及常用命令","url":"/2020/09/23/Redis%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","content":"\n        <h1 id=\"Redis的类型\"   >\n          <a href=\"#Redis的类型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Redis的类型</h1>\n      \n        <h2 id=\"string\"   >\n          <a href=\"#string\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>string</h2>\n      <ul>\n<li><strong>string&amp;数值&amp;bitmap</strong></li>\n</ul>\n<a id=\"more\"></a>\n\n<ol>\n<li><p>set key value  例：set k1 hello<br> \n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a8e15160a154a678de6db.png\"  alt=\"b5b5655ea23d232e9fe869828165f34d.png\">\n      <br> nx：不存在的时候才能设置（新增）<br> xx：存在的时候才能设置（修改）<br> \n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a8e15160a154a678de6c5.png\"  alt=\"6ae93516478f2dd52454deebeca93817.png\">\n      <br> mset 设置多个值 例：mset k3 a k4 b</p>\n</li>\n<li><p>get key 例：get k1<br> mget 获取多个值<br> \n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a8e15160a154a678de6c7.png\"  alt=\"7153ffbe5406c28b077f93e1d4a85492.png\">\n      </p>\n</li>\n<li><p>append key 追加<br> \n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a8e15160a154a678de6cb.png\"  alt=\"d56a1e44049762236816ea5ef10c7f95.png\">\n      </p>\n</li>\n<li><p>getrange key 取某一段字符串<br> \n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a8e15160a154a678de6d1.png\"  alt=\"9c76036a96ab51f0bb46f23bb413bfd9.png\">\n      <br> 6和10代表取第六位到第十位，从0开始。-1代表反向索引，从后往前数-1是最后一位-2是倒数第二位</p>\n</li>\n<li><p>setrange key<br> \n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a8e51160a154a678df937.png\"  alt=\"2aac44f3a577a4bb03f9cad9080809f4.png\">\n      <br> 代表从第六位开始将字符串替换</p>\n</li>\n<li><p>strlen key 查询字符串长度</p>\n</li>\n<li><p>type k1 获取k1的类型<br>  如果set k1 99，也是string类型的</p>\n</li>\n<li><p>object encoding k1<br> 此时显示k1的编码类型，是int</p>\n</li>\n<li><p>incr key 对key +1<br> increby key 10 对key加10，写多少加多少<br> increbyfloat key 0.5 对key加一个浮点数0.5<br>10 decr key 对key -1<br> 同上</p>\n</li>\n<li><p>getset name new_cxx 设置值，返回旧值</p>\n</li>\n<li><p>setbit 对位进行set<br>setbit k1 1 1 代表将set一个key是k1的，第一位是1的数（0100 0000）。长度为1，如果setbit k1 9 1，长度就是2，k1就是0100 0000,0100 0000</p>\n</li>\n<li><p>bitcount key 查询二进制的1出现了几次<br>bitcount k1 0 1 从第0个到第一个<strong>字节</strong>中查询<strong>二进制1</strong>出现了几次</p>\n</li>\n<li><p>bitop 按位操作<br>bitop and andkey k1 k2 将k1 k2做and操作(按位与)并将结果赋值给andkey<br>bitop or orkey k1 k2 将k1 k2做and操作(按位或)并将结果赋值给orkey</p>\n\n        <h3 id=\"数值型有什么用-举例\"   >\n          <a href=\"#数值型有什么用-举例\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>数值型有什么用 举例</h3>\n      <p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a8e78160a154a678e0746.png\"  alt=\"4e14c4326ae611be0afcfa7fea71b8ac.png\">\n      </p>\n</li>\n</ol>\n\n        <h3 id=\"位运算有什么用-举例\"   >\n          <a href=\"#位运算有什么用-举例\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>位运算有什么用 举例</h3>\n      <p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a8e78160a154a678e073e.png\"  alt=\"5acfbf691ed97de816c3282010db1163.png\">\n      <br>比mysql快，占用空间还小</p>\n\n        <h2 id=\"List\"   >\n          <a href=\"#List\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>List</h2>\n      <p><strong>可重复出现并有序（插入有序，不是去做排序）</strong></p>\n<ol>\n<li><p>lpush mylist a b c  左插入，结果是c,b,a</p>\n</li>\n<li><p>rpush mylist x y z  右插入，结果是x,y,z</p>\n</li>\n<li><p>lpop mylist  从左边弹出元素，就是获取list[0]，但是弹出就没了</p>\n</li>\n<li><p>rpop mylist  从右边弹出元素，就是list[-1]，但是弹出就没了</p>\n</li>\n<li><p>lrange mylist 0 -1  获取数据集合，从第0个到第-1个，-1是逆向索引，就是最后一个，倒着数</p>\n</li>\n<li><p>lindex mylist 2  获取指定索引的值，-1取最后一个</p>\n</li>\n<li><p>lset mylist 2 n 根据索引设值，将所因为2的值设置为n</p>\n</li>\n<li><p>lrem mylist count value  删除值<br> 例：lrem list1 2 a 删除名为list1的list中的2个值为a的元素</p>\n<pre><code> count &gt; 0 : 从表头开始向表尾搜索，移除与 VALUE 相等的元素，数量为COUNT\n count &lt; 0 : 从表尾开始向表头搜索，移除与 VALUE 相等的元素，数量为COUNT的绝对值。\n count = 0 : 移除表中所有与 VALUE 相等的值。</code></pre>\n</li>\n<li><p>linsert mylist before/after a  插入<br> 例：linsert list1 before a 1 在list1中的值为a的元素前插入一个1</p>\n<pre><code> after表示在a之后插入\n **如果有相同元素则在第一个元素前后插入**</code></pre>\n</li>\n<li><p>llen mylist  统计有多少元素，获取长度</p>\n</li>\n<li><p>ltrim mylist 2 4 删除两端的元素，即删除[0-2)以及(4-最后]的元素，只保留中间的</p>\n</li>\n<li><p>blpop 移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止<br>例：BLPOP list1 100 操作会被阻塞，如果list1存在数据则会返回元素所属的key和第一个元素，否则在等待100秒后会返回 nil，如果时间设置0则会一直阻塞</p>\n</li>\n<li><p>rpoplpush list list2     转移列表的数据</p>\n</li>\n</ol>\n<p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a8e9c160a154a678e14a1.png\"  alt=\"e1389ce108466f6e5acaec9f6507fff5.png\">\n      </p>\n\n        <h2 id=\"hash\"   >\n          <a href=\"#hash\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>hash</h2>\n      <ol>\n<li><p>hset myhash name xx 向名为myhash的hash结构中存一对键值对<br> hmset myhash age 25 address beijing向已有的myhash中再存入键值对</p>\n</li>\n<li><p>hget myhash name 从myhash中取键值对，取key为name的，结果是xx<br> hmget myhash name age address 从myhash中取多对键值对</p>\n</li>\n<li><p>hkeys myhash 取出所有key</p>\n</li>\n<li><p>hvals myhash 取出所有value</p>\n</li>\n<li><p>hgetall myhash 取所有的键值对，有key也有value</p>\n</li>\n<li><p>hincrby myhash age 1 递增<br> hincrbyfloat myhash age 0.5 加浮点数0.5<br> 没有减法，需要减就加负数</p>\n</li>\n<li><p>hexists myhash name 查看哈希表的指定字段是否存在，如果有，返回1。没有或key不存在，返回0 </p>\n</li>\n<li><p>hsetnx myhash score 100 为哈希表中不存在的的字段赋值。如果哈希表不存在，一个新的哈希表被创建并进行HSET 操作。如果字段已经存在于哈希表中，操作无效。如果key不存在，一个新哈希表被创建并执行 HSETNX 命令。成功返回1。如果给定字段已经存在且没有操作被执行，返回0</p>\n</li>\n<li><p>hdel myhash name 删除哈希表key中的一个或多个指定字段</p>\n</li>\n<li><p>hlen myhash 获取哈希表中字段的数量</p>\n</li>\n<li><p>HSETNX myhash field1 a 为哈希表中不存在的的字段赋值，如果哈希表不存在，创建并赋值，已存在则不做任何操作</p>\n</li>\n</ol>\n<p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a8e9c160a154a678e14a3.png\"  alt=\"5971146e5c4afe110fd5587a8497b251.png\">\n      </p>\n\n        <h2 id=\"set\"   >\n          <a href=\"#set\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>set</h2>\n      <p><strong>无序，去重</strong></p>\n<ol>\n<li><p>sadd myset a b c a d 添加元素，结果是四个，a去重后只有一个</p>\n</li>\n<li><p>srem myset a c 删除元素，结果是剩b，d</p>\n</li>\n<li><p>smembers myset 获取所有数据</p>\n</li>\n<li><p>sdiff | sinter | sunion 集合间运算：差集 | 交集 | 并集<br> 例：sinter k1 k2 对k1 k2做交集运算，返回素有交集元素，k1是1,2.k2是2,3则返回2<br> sinterstore k3 k1 k2 对k1 k2做交集运算并将结果写到k3中<br> 其余的加store也是一样，注意差集的顺序</p>\n</li>\n<li><p>srandmember key  count 随机获取集合中的元素</p>\n<ol>\n<li>正数：取出一个去重的结果集（不能超过已有集，超过则返回整个已有集）</li>\n<li>负数：取出一个带重复的结果集</li>\n<li>0，不返回</li>\n</ol>\n</li>\n<li><p>spop  从集合中弹出一个元素，弹出就没有了</p>\n</li>\n<li><p>sismember myset set1 判断元素是否在集合中，是返回 1，否则返回0</p>\n</li>\n<li><p>scard key_name 返回集合中元素的数量</p>\n</li>\n</ol>\n<p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a8e9c160a154a678e14a8.png\"  alt=\"0dd8820c313b7e2dcf21d968902c2a98.png\">\n      </p>\n\n        <h2 id=\"zset（sorted-set）\"   >\n          <a href=\"#zset（sorted-set）\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>zset（sorted_set）</h2>\n      <p><strong>有序，底层实现的数据结构是skip list（跳跃表）</strong></p>\n<p><strong>z后加rev为反向</strong></p>\n<ol>\n<li>zadd zset 8 apple 2 banana 3 orange 将一个或多个元素及其分数值加入到有序集当中<ol>\n<li>如果某个成员已经是有序集的成员，那么更新这个成员的分数值，并通过重新插入这个成员元素，来保证该成员在正确的位置上。</li>\n<li>分数值可以是整数值或双精度浮点数。</li>\n<li>如果有序集合 key 不存在，则创建一个空的有序集并执行 ZADD 操作。</li>\n<li>当 key 存在但不是有序集类型时，返回一个错误。</li>\n</ol>\n</li>\n<li>zrange zset 0 -1 withscores 返回有序集中，指定区间内的成员，并按分数值递增(从小到大)来排序，相同分数值按字典序排列<ul>\n<li>反向排序用zrevrange</li>\n<li>加withscores显示分值，不加不显示</li>\n</ul>\n</li>\n<li>zrangebyscore zset 1 5 withscores 取指定分数区间的成员列表。其他跟zrange一样</li>\n<li>zscore zset apple 通过元素获取分数</li>\n<li>zrank zset apple  返回有序集中指定成员的排名</li>\n<li>zincrby zset 2 apple 增长分数，将apple的分数增加2，同时排序会根据新的分数排<br> 场景：排行榜</li>\n<li>zunionstore/zdiffstore/zinterstore 并集/差集/交集 以并集为例<br> zunionstore unkey 2 k1 k2 将k1 k2取并集将结果放到unkey中，默认结果集中某个成员的分数值是所有给定集下该成员分数值之和<br> \n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a8ec8160a154a678e254a.png\"  alt=\"45df43a8e9581b26e83b2b3a9d2efeeb.png\">\n      <br> zunionstore unkey1 2 k1 k2 weights 1 0.5 在上面的基础上，增加权重，k1的分数乘1，k2的分数乘0.5然后相加<br> \n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a8ec8160a154a678e2541.png\"  alt=\"d2e666e3662df8252d6f29af246e7a78.png\">\n      <br> zunionstore unkey1 2 k1 k2 aggregate max 取最大值，不取和了，min取最小值<br> \n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a8ec8160a154a678e2543.png\"  alt=\"8382d57b3c49afb9a66076362f11f760.png\">\n      </li>\n<li>zcard zset  计算集合中元素的数量</li>\n<li>zcount zset 计算有序集合中指定分数区间的成员数量<br> \n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a8f06160a154a678e3b9f.png\"  alt=\"1837c424fa5bc49eb06256f44e738fd2.png\">\n      </li>\n<li>zrem zset one two 移除有序集中的一个或多个成员</li>\n<li>zremrangebyrank zset 0 1  移除有序集中，指定排名(rank)区间内的所有成员<br>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a8f06160a154a678e3ba2.png\"  alt=\"af472ad835dbf0146354f1a239bb1422.png\">\n      </li>\n<li>zremrangebyscore zset 0 1 移除有序集中，指定分数（score）区间内的所有成员。<br>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a8f06160a154a678e3baa.png\"  alt=\"82825c6d37a40ed1cca5042827224126.png\">\n      </li>\n</ol>\n<p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a8f06160a154a678e3b9d.png\"  alt=\"7ffb9f63d7d0629d62b9a794c4ae674d.png\">\n      </p>\n","categories":["Redis"],"tags":["Redis"]},{"title":"redis介绍及NIO原理介绍","url":"/2020/09/23/redis-%E4%BB%8B%E7%BB%8D%E5%8F%8ANIO%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/","content":"\n        <h1 id=\"redis-介绍及NIO原理介绍\"   >\n          <a href=\"#redis-介绍及NIO原理介绍\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>redis 介绍及NIO原理介绍</h1>\n      \n        <h2 id=\"为什么要有Redis\"   >\n          <a href=\"#为什么要有Redis\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>为什么要有Redis</h2>\n      <p>数据都放在磁盘文件里，随着文件变大，读取、查询速度都变慢，硬盘i/o成为瓶颈。数据库读取数据变慢，不能满足需求。有一个SAP公司的HANA内存级别的关系型数据库（2T），但是成本太高，于是出现了缓存。</p>\n<ul>\n<li>memcached</li>\n<li>redis</li>\n</ul>\n<a id=\"more\"></a>\n\n\n\n        <h3 id=\"数据库表很大，性能下降？\"   >\n          <a href=\"#数据库表很大，性能下降？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>数据库表很大，性能下降？</h3>\n      <p>如果表有索引<br>增删改变慢<br>查询速度呢？</p>\n<ol>\n<li>1个或少量查询依然很快</li>\n<li>并发大的时候会受硬盘带宽影响速度</li>\n</ol>\n\n        <h3 id=\"小常识\"   >\n          <a href=\"#小常识\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>小常识</h3>\n      <p>磁盘：<br>1，寻址：ms<br>2，带宽：G/M</p>\n<p>内存：<br>1，寻址：ns<br>2，带宽：很大<br>秒&gt;毫秒&gt;微秒&gt;纳秒  磁盘比内存在寻址上慢了10W倍</p>\n<p>I/O buffer：成本问题<br>磁盘与磁道，扇区，一扇区 512Byte带来一个成本变大：索引<br>4K  操作系统，无论你读多少，都是最少4k从磁盘拿</p>\n<p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a8d05160a154a678d92b9.png\"  alt=\"6e7dd4cc0baff9333d5415cf3ad422c6.png\">\n      </p>\n\n        <h2 id=\"Redis\"   >\n          <a href=\"#Redis\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Redis</h2>\n      <p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。<br>Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。</p>\n<p>memcached也是key-value，但是value没有类型的概念<br>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a8d05160a154a678d92b2.png\"  alt=\"d61130221aea5980aba51b1fdde52bd5.png\">\n      </p>\n<p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a8d05160a154a678d92b5.png\"  alt=\"c0fabe0ec3ce6b6baedf9c6bc772dfb4.png\">\n      <br>当我看到memcached的value没有类型概念的时候，第一时间想到了json，json可以表示很复杂的数据结构，但是当取复杂数据结构中的一个值时，需要把整个结果集解析</p>\n<p>一个linux中，可以有多个redis实例，每个redis有16个库（配置文件能改），一个库下存的都是键值对。key其实是个对象，除了它的名字之外还有type、encoding等，可以规避一些异常，比如做计算是不需要再去判断能不能计算。</p>\n\n        <h3 id=\"安装\"   >\n          <a href=\"#安装\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>安装</h3>\n      <ol>\n<li>yum install wget</li>\n<li>cd ~</li>\n<li>mkdir soft</li>\n<li>cd soft</li>\n<li>wget    <span class=\"exturl\"><a class=\"exturl__link\"   href=\"http://download.redis.io/releases/redis-5.0.5.tar.gz\" >http://download.redis.io/releases/redis-5.0.5.tar.gz</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li>tar xf    redis…tar.gz</li>\n<li>cd redis-src</li>\n<li>看README.md</li>\n<li>make<br> …yum install  gcc<br> …make distclean 报错后需要先执行这个清除之前的</li>\n<li>make</li>\n<li>cd src   ….生成了可执行程序，然后把它变成服务化</li>\n<li>cd ..</li>\n<li>make install PREFIX=/opt/mashibing/redis5</li>\n<li>vi /etc/profile 配置环境变量<br>…   export  REDIS_HOME=/opt/mashibing/redis5<br>…   export PATH=$PATH:$REDIS_HOME/bin</li>\n</ol>\n<p>..source /etc/profile<br>15. cd utils<br>16. ./install_server.sh  （可以执行一次或多次）<br>    a)  一个物理机中可以有多个redis实例（进程），通过port区分<br>    b)  可执行程序就一份在目录，但是内存中未来的多个实例需要各自的配置文件，持久化目录等资源<br>    c)  service   redis_6379  start/stop/stauts     &gt;   linux   /etc/init.d/****<br>    d)脚本还会帮你启动！<br>17. ps -fe |  grep redis  可以看到进程</p>\n<ul>\n<li>最新版的redis6.0.8需要gcc到5.4以上，默认安装的gcc是4.4.7版本</li>\n</ul>\n\n        <h2 id=\"IO模型\"   >\n          <a href=\"#IO模型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>IO模型</h2>\n      <p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a8d53160a154a678dab9e.png\"  alt=\"6780bc95f27ba3181792aa587f56cf7a.png\">\n      <br>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a8d53160a154a678daba2.png\"  alt=\"717006acba076bd50bea1860df91442b.png\">\n      <br>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a8d53160a154a678daba6.png\"  alt=\"e89dbd4e65d1caff857b9fd78c4d4ee0.png\">\n      <br>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a8d53160a154a678dabab.png\"  alt=\"4b1d37c51f03f1f0af9d4b974f9ec5ed.png\">\n      </p>\n\n        <h2 id=\"零拷贝\"   >\n          <a href=\"#零拷贝\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>零拷贝</h2>\n      <p>通过sendfile实现<br>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a8d8e160a154a678dbe23.png\"  alt=\"533a231728f92247d5115a8d40727a04.png\">\n      </p>\n\n        <h2 id=\"一些知识\"   >\n          <a href=\"#一些知识\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>一些知识</h2>\n      <ol>\n<li>redis-cli默认连接6739<ol>\n<li>edis-cli -h 连接哪个主机</li>\n<li>edis-cli -p 连接哪个端口<br>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a8d8e160a154a678dbe21.png\"  alt=\"822a351d224cae0dd05f153871176ee9.png\">\n      </li>\n</ol>\n</li>\n<li>默认16个库 ，0号库、1号库…  相互独立，数据不互通</li>\n</ol>\n\n        <h3 id=\"二进制安全\"   >\n          <a href=\"#二进制安全\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>二进制安全</h3>\n      <p>二进制安全功能（binary- safe function）是指在一个二进制文件上所执行的不更改文件内容的功能或者操作。这能够保证文件不会因为某些操作而遭到损坏。二进制数据是按照一串0和 1的形式编码的。而绝大多数的程序会给某些特殊的比特串赋予不同的格式代码，所以当用户使用一个程序读取一个二进制文件时，该文件会被按照这个程序的规则 进行解释。如果这个程序所使用的格式编码和文件被写入的格式编码一致，那么这个文件可以被正常读取，否则该文件的格式代码之中会被附加一些无意义的符号， 也可能会导致文件损坏。如果最严重的情况发生，这样的操作会因为损坏导致你的数据永久丢失。所以你应该将重要的文件保存在只读性的存储介质上，例如光盘。</p>\n","categories":["Redis"],"tags":["Redis"]},{"title":"MySQL服务器参数设置","url":"/2020/09/23/MySQL%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/","content":"\n        <h1 id=\"服务器参数设置\"   >\n          <a href=\"#服务器参数设置\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>服务器参数设置</h1>\n      \n        <h2 id=\"general-通用\"   >\n          <a href=\"#general-通用\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>general 通用</h2>\n      <ol>\n<li><p>datadir=/var/lib/mysql<br>数据文件存放的目录</p>\n<a id=\"more\"></a>\n</li>\n<li><p>socket=/var/lib/mysql/mysql.sock<br>mysql.socket表示server和client在同一台服务器，并且使用localhost进行连接，就会使用socket进行连接，一般不用动</p>\n</li>\n<li><p>pid_file=/var/lib/mysql/mysql.pid<br>存储mysql的pid</p>\n</li>\n<li><p>port=3306<br>mysql服务的端口号</p>\n</li>\n<li><p>default_storage_engine=InnoDB<br>mysql存储引擎，一般不改，如果需要其他存储引擎，在建表的时候加上engine=…即可</p>\n</li>\n<li><p><strong>skip-grant-tables</strong><br>当忘记mysql的用户名密码的时候，可以在mysql配置文件中配置该参数，跳过权限表验证，不需要密码即可登录mysql</p>\n</li>\n</ol>\n\n        <h2 id=\"character-字符\"   >\n          <a href=\"#character-字符\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>character 字符</h2>\n      <p><strong>不同的字符集占用的空间不同，合理设置</strong></p>\n<ol>\n<li>character_set_client<br> 客户端数据的字符集</li>\n<li>character_set_connection<br> mysql处理客户端发来的信息时，会把这些数据转换成连接的字符集格式</li>\n<li>character_set_results<br> mysql发送给客户端的结果集所用的字符集</li>\n<li>character_set_database<br> 数据库默认的字符集</li>\n<li>character_set_server<br> mysql server的默认字符集</li>\n</ol>\n\n        <h2 id=\"connection-连接\"   >\n          <a href=\"#connection-连接\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>connection 连接</h2>\n      <ol>\n<li>max_connections<br> mysql的最大连接数，如果数据库的并发连接请求比较大，应该调高该值。默认值取决于硬件配置</li>\n<li>max_user_connections<br> 限制每个用户的连接个数，0代表不限制</li>\n<li>back_log<br> mysql能够暂存的连接数量，当mysql的线程在一个很短时间内得到非常多的连接请求时，就会起作用，如果mysql的连接数量达到max_connections时，新的请求会被存储在堆栈中，以等待某一个连接释放资源，如果等待连接的数量超过back_log,则不再接受连接资源</li>\n<li>wait_timeout<br> mysql在关闭一个非交互的连接之前需要等待的时长</li>\n<li>interactive_timeout<br> 关闭一个交互连接之前需要等待的秒数</li>\n</ol>\n\n        <h2 id=\"log-日志\"   >\n          <a href=\"#log-日志\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>log 日志</h2>\n      <ol>\n<li>log_error<br> 指定错误日志文件名称，用于记录当mysqld启动和停止时，以及服务器在运行中发生任何严重错误时的相关信息</li>\n<li>log_bin<br> 指定二进制日志文件名称，用于记录对数据造成更改的所有查询语句。默认不开启</li>\n<li>binlog_do_db<br> 指定将更新记录到二进制日志的数据库，其他所有没有显式指定的数据库更新将忽略，不记录在日志中</li>\n<li>binlog_ignore_db<br> 指定不将更新记录到二进制日志的数据库</li>\n<li>sync_binlog<br> 指定多少次写日志后同步磁盘</li>\n<li>general_log<br> 是否开启查询日志记录 默认关闭</li>\n<li>general_log_file<br> 指定查询日志文件名，用于记录所有的查询语句</li>\n<li>slow_query_log<br> 是否开启慢查询日志记录 默认关闭</li>\n<li>slow_query_log_file<br> 指定慢查询日志文件名称，用于记录耗时比较长的查询语句</li>\n<li>long_query_time<br> 设置慢查询的时间，超过这个时间的查询语句才会记录日志</li>\n<li>log_slow_admin_statements<br> 是否将管理语句写入慢查询日志</li>\n</ol>\n\n        <h2 id=\"cache-缓存\"   >\n          <a href=\"#cache-缓存\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>cache 缓存</h2>\n      <ol>\n<li><p>key_buffer_size<br> 索引缓存区的大小（只对myisam表起作用）</p>\n</li>\n<li><p>query cache 查询缓存相关，8以后已经没了</p>\n<ol>\n<li>query_cache_size：查询缓存的大小，未来版本被删除<ol>\n<li>show status like ‘%Qcache%’;查看缓存的相关属性</li>\n<li>Qcache_free_blocks：缓存中相邻内存块的个数，如果值比较大，那么查询缓存中碎片比较多</li>\n<li>Qcache_free_memory：查询缓存中剩余的内存大小</li>\n<li>Qcache_hits：表示有多少此命中缓存</li>\n<li>Qcache_inserts：表示多少次未命中而插入</li>\n<li>Qcache_lowmen_prunes：多少条query因为内存不足而被移除cache</li>\n<li>Qcache_queries_in_cache：当前cache中缓存的query数量</li>\n<li>Qcache_total_blocks：当前cache中block的数量</li>\n</ol>\n</li>\n<li>query_cache_limit：超出此大小的查询将不被缓存</li>\n<li>query_cache_min_res_unit：缓存块最小大小</li>\n<li>query_cache_type：缓存类型，决定缓存什么样的查询<ol>\n<li>0表示禁用</li>\n<li>1表示将缓存所有结果，除非sql语句中使用sql_no_cache禁用查询缓存</li>\n<li>2表示只缓存select语句中通过sql_cache指定需要缓存的查询</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>sort_buffer_size<br> 每个需要排序的线程分派该大小的缓冲区</p>\n</li>\n<li><p>max_allowed_packet=32M<br> 限制server接受的数据包大小</p>\n</li>\n<li><p>join_buffer_size=2M<br> 表示关联缓存的大小</p>\n</li>\n<li><p>thread_cache_size 线程缓存大小<br> 服务器线程缓存，这个值表示可以重新利用保存再缓存中的线程数量，当断开连接时，那么客户端的线程将被放到缓存中以响应下一个客户而不是销毁，如果线程重新被请求，那么请求将从缓存中读取，如果缓存中是空的或者是新的请求，这个线程将被重新请求，那么这个线程将被重新创建，如果有很多新的线程，增加这个值即可</p>\n<ol>\n<li>Threads_cached：代表当前此时此刻线程缓存中有多少空闲线程</li>\n<li>Threads_connected：代表当前已建立连接的数量</li>\n<li>Threads_created：代表最近一次服务启动，已创建现成的数量，如果该值比较大，那么服务器会一直再创建线程</li>\n<li>Threads_running：代表当前激活的线程数</li>\n</ol>\n</li>\n</ol>\n\n        <h2 id=\"INNODB\"   >\n          <a href=\"#INNODB\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>INNODB</h2>\n      <ol>\n<li>innodb_buffer_pool_size=<br> 该参数指定大小的内存来缓冲数据和索引，最大可以设置为物理内存的80%</li>\n<li>innodb_flush_log_at_trx_commit<br> 主要控制innodb将log buffer中的数据写入日志文件并flush磁盘的时间点，值分别为0，1，2</li>\n<li>innodb_thread_concurrency<br> 设置innodb线程的并发数，默认为0表示不受限制，如果要设置建议跟服务器的cpu核心数一致或者是cpu核心数的两倍</li>\n<li>innodb_log_buffer_size<br> 此参数确定日志文件所用的内存大小，以M为单位</li>\n<li>innodb_log_file_size<br> 此参数确定数据日志文件的大小，以M为单位</li>\n<li>innodb_log_files_in_group<br> 以循环方式将日志文件写到多个文件中，默认两个</li>\n<li>read_buffer_size<br> mysql读入缓冲区大小，对表进行顺序扫描的请求将分配到一个读入缓冲区</li>\n<li>read_rnd_buffer_size<br> mysql随机读的缓冲区大小</li>\n<li>innodb_file_per_table<br> 此参数确定为每张表分配一个新的文件</li>\n</ol>\n","categories":["MySQL"],"tags":["MySQL","MySQL调优"]},{"title":"分区表","url":"/2020/09/23/%E5%88%86%E5%8C%BA%E8%A1%A8/","content":"\n        <h1 id=\"分区表\"   >\n          <a href=\"#分区表\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>分区表</h1>\n      \n        <h2 id=\"分区表的应用场景\"   >\n          <a href=\"#分区表的应用场景\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>分区表的应用场景</h2>\n      <ol>\n<li>表非常大以至于无法全部都放在内存中，或者只在表的最后部分有热点数据，其他均是历史数据</li>\n<li>分区表的数据更容易维护<ol>\n<li>批量删除大量数据可以使用清除整个分区的方式</li>\n<li>对一个独立分区进行优化、检查、修复等操作</li>\n</ol>\n</li>\n<li>分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备</li>\n<li>可以使用分区表来避免某些特殊的瓶颈<ol>\n<li>innodb的单个索引的互斥访问</li>\n<li>ext3文件系统的inode锁竞争</li>\n</ol>\n</li>\n<li>可以备份和恢复独立的分区</li>\n</ol>\n<a id=\"more\"></a>\n\n<ul>\n<li>目的：减少IO量</li>\n</ul>\n\n        <h2 id=\"分区表的限制\"   >\n          <a href=\"#分区表的限制\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>分区表的限制</h2>\n      <ol>\n<li>一个表最多只能有1024个分区，在5.7版本的时候可以支持8196个分区</li>\n<li>在早期的mysql中，分区表达式必须是整数或者是返回整数的表达式，在mysql5.5中，某些场景可以直接使用列来进行分区</li>\n<li>如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来</li>\n<li>分区表无法使用外键约束 </li>\n</ol>\n\n        <h2 id=\"分区表的原理\"   >\n          <a href=\"#分区表的原理\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>分区表的原理</h2>\n      <p>分区表由多个相关的底层表实现，这个底层表也是由句柄对象标识，我们可以直接访问各个分区。存储引擎管理分区的各个底层表和管理普通表一样（所有的底层表都必须使用相同的存储引擎），分区表的索引知识在各个底层表上各自加上一个完全相同的索引。从存储引擎的角度来看，底层表和普通表没有任何不同，存储引擎也无须知道这是一个普通表还是一个分区表的一部分。</p>\n<p>分区表的操作按照以下的操作逻辑进行：</p>\n<p><strong>select查询</strong></p>\n<p>当查询一个分区表的时候，分区层先打开并锁住所有的底层表，优化器先判断是否可以过滤部分分区，然后再调用对应的存储引擎接口访问各个分区的数据</p>\n<p><strong>insert操作</strong></p>\n<p>当写入一条记录的时候，分区层先打开并锁住所有的底层表，然后确定哪个分区接受这条记录，再将记录写入对应底层表</p>\n<p><strong>delete操作</strong></p>\n<p>当删除一条记录时，分区层先打开并锁住所有的底层表，然后确定数据对应的分区，最后对相应底层表进行删除操作</p>\n<p><strong>update操作</strong></p>\n<p>当更新一条记录时，分区层先打开并锁住所有的底层表，mysql先确定需要更新的记录再哪个分区，然后取出数据并更新，再判断更新后的数据应该再哪个分区，最后对底层表进行写入操作，并对源数据所在的底层表进行删除操作</p>\n<p>有些操作时支持过滤的，例如，当删除一条记录时，MySQL需要先找到这条记录，如果where条件恰好和分区表达式匹配，就可以将所有不包含这条记录的分区都过滤掉，这对update同样有效。如果是insert操作，则本身就是只命中一个分区，其他分区都会被过滤掉。mysql先确定这条记录属于哪个分区，再将记录写入对应得曾分区表，无须对任何其他分区进行操作</p>\n<p>虽然每个操作都会“先打开并锁住所有的底层表”，但这并不是说分区表在处理过程中是锁住全表的，如果存储引擎能够自己实现行级锁，例如innodb，则会在分区层释放对应表锁。</p>\n\n        <h2 id=\"分区表的类型\"   >\n          <a href=\"#分区表的类型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>分区表的类型</h2>\n      <ol>\n<li>范围分区<br> 根据列值在给定范围内将行分配给分区。每个分区都包含行数据且分区的表达式在给定的范围内，分区的范围应该是连续的且不能重叠，可以使用values less than运算符来定义。<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> employees (</span><br><span class=\"line\">    <span class=\"keyword\">id</span> <span class=\"built_in\">INT</span> <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">    fname <span class=\"built_in\">VARCHAR</span>(<span class=\"number\">30</span>),</span><br><span class=\"line\">    lname <span class=\"built_in\">VARCHAR</span>(<span class=\"number\">30</span>),</span><br><span class=\"line\">    hired <span class=\"built_in\">DATE</span> <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;1970-01-01&#x27;</span>,</span><br><span class=\"line\">    separated <span class=\"built_in\">DATE</span> <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;9999-12-31&#x27;</span>,</span><br><span class=\"line\">    job_code <span class=\"built_in\">INT</span> <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">    store_id <span class=\"built_in\">INT</span> <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">PARTITION</span> <span class=\"keyword\">BY</span> <span class=\"keyword\">RANGE</span> (store_id) (</span><br><span class=\"line\">    <span class=\"keyword\">PARTITION</span> p0 <span class=\"keyword\">VALUES</span> <span class=\"keyword\">LESS</span> <span class=\"keyword\">THAN</span> (<span class=\"number\">6</span>),</span><br><span class=\"line\">    <span class=\"keyword\">PARTITION</span> p1 <span class=\"keyword\">VALUES</span> <span class=\"keyword\">LESS</span> <span class=\"keyword\">THAN</span> (<span class=\"number\">11</span>),</span><br><span class=\"line\">    <span class=\"keyword\">PARTITION</span> p2 <span class=\"keyword\">VALUES</span> <span class=\"keyword\">LESS</span> <span class=\"keyword\">THAN</span> (<span class=\"number\">16</span>),</span><br><span class=\"line\">    <span class=\"keyword\">PARTITION</span> p3 <span class=\"keyword\">VALUES</span> <span class=\"keyword\">LESS</span> <span class=\"keyword\">THAN</span> MAXVALUE</span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"comment\">------------</span></span><br><span class=\"line\">PARTITION BY RANGE ( YEAR(separated) ) ( </span><br><span class=\"line\">PARTITION p0 <span class=\"keyword\">VALUES</span> <span class=\"keyword\">LESS</span> <span class=\"keyword\">THAN</span> (<span class=\"number\">2001</span>)</span><br><span class=\"line\">);</span><br><span class=\"line\">PARTITION p1 <span class=\"keyword\">VALUES</span> <span class=\"keyword\">LESS</span> <span class=\"keyword\">THAN</span> MAXVALUE );</span><br><span class=\"line\"><span class=\"comment\">------------</span></span><br><span class=\"line\">PARTITION BY RANGE COLUMNS(joined) ( </span><br><span class=\"line\">PARTITION p0 <span class=\"keyword\">VALUES</span> <span class=\"keyword\">LESS</span> <span class=\"keyword\">THAN</span> (<span class=\"string\">&#x27;1960-01-01&#x27;</span>), </span><br><span class=\"line\"><span class=\"keyword\">PARTITION</span> p1 <span class=\"keyword\">VALUES</span> <span class=\"keyword\">LESS</span> <span class=\"keyword\">THAN</span> MAXVALUE</span><br><span class=\"line\">);</span><br></pre></td></tr></table></div></figure></li>\n<li>列表分区<br> 类似于按range分区，区别在于list分区是基于列值匹配一个离散值集合中的某个值来进行选择<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">PARTITION BY LIST(store_id) ( </span><br><span class=\"line\">PARTITION pNorth <span class=\"keyword\">VALUES</span> <span class=\"keyword\">IN</span> (<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">9</span>,<span class=\"number\">17</span>), </span><br><span class=\"line\"><span class=\"keyword\">PARTITION</span> pEast <span class=\"keyword\">VALUES</span> <span class=\"keyword\">IN</span> (<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">10</span>,<span class=\"number\">11</span>,<span class=\"number\">19</span>,<span class=\"number\">20</span>),</span><br><span class=\"line\"><span class=\"keyword\">PARTITION</span> pWest <span class=\"keyword\">VALUES</span> <span class=\"keyword\">IN</span> (<span class=\"number\">4</span>,<span class=\"number\">12</span>,<span class=\"number\">13</span>,<span class=\"number\">14</span>,<span class=\"number\">18</span>), </span><br><span class=\"line\"><span class=\"keyword\">PARTITION</span> pCentral <span class=\"keyword\">VALUES</span> <span class=\"keyword\">IN</span> (<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">15</span>,<span class=\"number\">16</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></div></figure></li>\n<li>列分区<br> mysql从5.5开始支持column分区，可以认为i是range和list的升级版，在5.5之后，可以使用column分区替代range和list，但是column分区只接受普通列不接受表达式</li>\n<li>hash分区<br> 基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含myql中有效的、产生非负整数值的任何表达式<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> employees (</span><br><span class=\"line\"><span class=\"keyword\">id</span> <span class=\"built_in\">INT</span> <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>, </span><br><span class=\"line\">fname <span class=\"built_in\">VARCHAR</span>(<span class=\"number\">30</span>), </span><br><span class=\"line\">lname <span class=\"built_in\">VARCHAR</span>(<span class=\"number\">30</span>),</span><br><span class=\"line\">hired <span class=\"built_in\">DATE</span> <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;1970-01-01&#x27;</span>, </span><br><span class=\"line\">separated <span class=\"built_in\">DATE</span> <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;9999-12-31&#x27;</span>,</span><br><span class=\"line\">job_code <span class=\"built_in\">INT</span>, store_id <span class=\"built_in\">INT</span></span><br><span class=\"line\">) </span><br><span class=\"line\"><span class=\"keyword\">PARTITION</span> <span class=\"keyword\">BY</span> <span class=\"keyword\">HASH</span>(store_id) </span><br><span class=\"line\"><span class=\"keyword\">PARTITIONS</span> <span class=\"number\">4</span>;</span><br><span class=\"line\">分四个区，把每个store_id都%4后分区</span><br></pre></td></tr></table></div></figure></li>\n<li>key分区<br> 类似于hash分区，区别在于key分区只支持一列或多列，且mysql服务器提供其自身的哈希函数，必须有一列或多列包含整数值<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> k1 ( </span><br><span class=\"line\"><span class=\"keyword\">id</span> <span class=\"built_in\">INT</span> <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>, </span><br><span class=\"line\"><span class=\"keyword\">name</span> <span class=\"built_in\">VARCHAR</span>(<span class=\"number\">20</span>), </span><br><span class=\"line\"><span class=\"keyword\">UNIQUE</span> <span class=\"keyword\">KEY</span> (<span class=\"keyword\">id</span>)</span><br><span class=\"line\">) </span><br><span class=\"line\"><span class=\"keyword\">PARTITION</span> <span class=\"keyword\">BY</span> <span class=\"keyword\">KEY</span>() </span><br><span class=\"line\"><span class=\"keyword\">PARTITIONS</span> <span class=\"number\">2</span>;</span><br></pre></td></tr></table></div></figure></li>\n<li>子分区<br> 在分区的基础之上，再进行分区后存储<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> ts (<span class=\"keyword\">id</span> <span class=\"built_in\">INT</span>, purchased <span class=\"built_in\">DATE</span>) </span><br><span class=\"line\">    <span class=\"keyword\">PARTITION</span> <span class=\"keyword\">BY</span> <span class=\"keyword\">RANGE</span>( <span class=\"keyword\">YEAR</span>(purchased) ) </span><br><span class=\"line\">    <span class=\"keyword\">SUBPARTITION</span> <span class=\"keyword\">BY</span> <span class=\"keyword\">HASH</span>( <span class=\"keyword\">TO_DAYS</span>(purchased) ) </span><br><span class=\"line\">    <span class=\"keyword\">SUBPARTITIONS</span> <span class=\"number\">2</span> ( </span><br><span class=\"line\">        <span class=\"keyword\">PARTITION</span> p0 <span class=\"keyword\">VALUES</span> <span class=\"keyword\">LESS</span> <span class=\"keyword\">THAN</span> (<span class=\"number\">1990</span>), </span><br><span class=\"line\">        <span class=\"keyword\">PARTITION</span> p1 <span class=\"keyword\">VALUES</span> <span class=\"keyword\">LESS</span> <span class=\"keyword\">THAN</span> (<span class=\"number\">2000</span>), </span><br><span class=\"line\">        <span class=\"keyword\">PARTITION</span> p2 <span class=\"keyword\">VALUES</span> <span class=\"keyword\">LESS</span> <span class=\"keyword\">THAN</span> MAXVALUE</span><br><span class=\"line\">);</span><br></pre></td></tr></table></div></figure>\n\n</li>\n</ol>\n\n        <h2 id=\"如何使用分区表\"   >\n          <a href=\"#如何使用分区表\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>如何使用分区表</h2>\n      <p>如果需要从非常大的表中查询出某一段时间的记录，而这张表中包含很多年的历史数据，数据是按照时间排序的，此时应该如何查询数据呢？<br>因为数据量巨大，肯定不能在每次查询的时候都扫描全表。考虑到索引在空间和维护上的消耗，也不希望使用索引，即使使用索引，会发现会产生大量的碎片，还会产生大量的随机IO，但是当数据量超大的时候，索引也就无法起作用了，此时可以考虑使用分区来进行解决</p>\n<ol>\n<li>全量扫描数据，不要任何索引<ul>\n<li>使用简单的分区方式存放表，不要任何索引，根据分区规则大致定位需要的数据为止，通过使用where条件将需要的数据限制在少数分区中，这种策略适用于以正常的方式访问大量数据</li>\n</ul>\n</li>\n<li>索引数据，并分离热点<ul>\n<li>如果数据有明显的热点，而且除了这部分数据，其他数据很少被访问到，那么可以将这部分热点数据单独放在一个分区中，让这个分区的数据能够有机会都缓存在内存中，这样查询就可以只访问一个很小的分区表，能够使用索引，也能够有效的使用缓存</li>\n</ul>\n</li>\n</ol>\n\n        <h2 id=\"在使用分区表的时候需要注意的问题\"   >\n          <a href=\"#在使用分区表的时候需要注意的问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>在使用分区表的时候需要注意的问题</h2>\n      <ol>\n<li>null值会使分区过滤无效</li>\n<li>分区列和索引列不匹配，会导致查询无法进行分区过滤</li>\n<li>选择分区的成本可能很高</li>\n<li>打开并锁住所有底层表的成本可能很高</li>\n<li>维护分区的成本可能很高</li>\n</ol>\n","categories":["MySQL"],"tags":["MySQL","MySQL调优"]},{"title":"MySQL查询优化","url":"/2020/09/23/MySQL%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/","content":"\n        <h1 id=\"查询优化\"   >\n          <a href=\"#查询优化\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>查询优化</h1>\n      <p>在编写快速的查询之前，需要清楚一点，真正重要的是响应时间，而且要知道在整个SQL语句的执行过程中每个步骤都花费了多长时间，要知道哪些步骤是拖垮执行效率的关键步骤，想要做到这点，必须要知道查询的生命周期，然后进行优化，不同的应用场景有不同的优化方式，不要一概而论，具体情况具体分析。</p>\n<a id=\"more\"></a>\n\n\n        <h2 id=\"查询慢的原因\"   >\n          <a href=\"#查询慢的原因\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>查询慢的原因</h2>\n      <ol>\n<li>网络</li>\n<li>CPU</li>\n<li>IO</li>\n<li>上下文切换</li>\n<li>系统调用</li>\n<li>生成统计信息</li>\n<li>锁等待时间</li>\n</ol>\n\n        <h2 id=\"优化数据访问\"   >\n          <a href=\"#优化数据访问\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>优化数据访问</h2>\n      <p>查询性能低下的原因是</p>\n<ol>\n<li>访问的数据太多，某些查询不可避免的需要筛选大量的数据，我们可以通过减少访问数据量的方式进行优化<ol>\n<li>确认应用程序是否在检索大量超过需要的数据</li>\n<li>确认mysql服务器层是否在分析大量超过需要的数据行</li>\n</ol>\n</li>\n<li>是否向数据库请求了不需要的数据<ol>\n<li>查询不需要的记录优，化方式是在查询后面添加limit</li>\n<li>多表关联时返回全部列</li>\n<li>总是取出全部列，禁用select *</li>\n<li>重复查询相同的数据，如果需要不断的重复执行相同的查询，且每次返回完全相同的数据，我们可以将这部分数据缓存起来</li>\n</ol>\n</li>\n</ol>\n\n        <h2 id=\"执行过程的优化\"   >\n          <a href=\"#执行过程的优化\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>执行过程的优化</h2>\n      \n        <h3 id=\"查询缓存\"   >\n          <a href=\"#查询缓存\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>查询缓存</h3>\n      <p>在解析一个查询语句之前，如果查询缓存是打开的，那么mysql会优先检查这个查询是否命中查询缓存中的数据，如果查询恰好命中了查询缓存，那么会在返回结果之前会检查用户权限，如果权限没有问题，那么mysql会跳过所有的阶段，就直接从缓存中拿到结果并返回给客户端。</p>\n<ul>\n<li>在8版本之后已经淘汰了。维护成本高，命中率低</li>\n</ul>\n\n        <h3 id=\"查询优化处理\"   >\n          <a href=\"#查询优化处理\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>查询优化处理</h3>\n      <p>mysql查询完缓存之后会经过以下几个步骤：解析SQL、预处理、优化SQL执行计划，这几个步骤出现任何的错误，都可能会终止查询</p>\n\n        <h4 id=\"语法解析器和预处理\"   >\n          <a href=\"#语法解析器和预处理\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>语法解析器和预处理</h4>\n      <p>mysql通过关键字将SQL语句进行解析，并生成一颗解析树，mysql解析器将使用mysql语法规则验证和解析查询，例如验证使用了错误的关键字或者顺序是否正确等等，预处理器会进一步检查解析树是否合法，例如表名和列名是否存在，是否有歧义，还会验证权限等等。</p>\n<p>简单来说就是，解析sql语句，检查语法是否有问题，表列是否存在，验证权限等</p>\n\n        <h4 id=\"查询优化器\"   >\n          <a href=\"#查询优化器\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>查询优化器</h4>\n      <p>当语法树没有问题之后，相应的要由优化器将其转成执行计划，一条查询语句可以使用非常多的执行方式，最后都可以得到对应的结果，但是不同的执行方式带来的效率是不同的，优化器的最主要目的就是要选择最有效的执行计划（CBO：基于成本优化；RBO：基于规则优化）<br>mysql使用的是<strong>基于成本的优化器</strong>，在优化的时候会尝试预测一个查询使用某种查询计划时候的成本，并选择其中成本最小的一个</p>\n<ul>\n<li><p>在很多情况下mysql会选择错误的执行计划，原因如下：</p>\n<ol>\n<li>统计信息不准确</li>\n<li>执行计划的成本估算不等同于实际执行的成本，</li>\n<li>mysql的最优可能跟你想的不一样，mysql的优化是基于成本模型的优化，可能不是最快的优化</li>\n<li>mysql不考虑其他并发执行的查询</li>\n<li>mysql不会考虑不受其控制的操作成本（执行存储过程或者用户自定义函数的成本）</li>\n</ol>\n</li>\n<li><p>优化器的优化策略</p>\n<ol>\n<li>静态优化，直接对解析树进行分析，并完成优化</li>\n<li>动态优化，与查询的上下文有关，也可能跟取值、索引对应的行数有关</li>\n<li>mysql对查询的静态优化只需要一次，但对动态优化在每次执行时都需要重新评估</li>\n</ol>\n</li>\n<li><p>优化器的优化类型</p>\n<ol>\n<li>重新定义关联表的顺序，数据表的关联并不总是按照在查询中指定的顺序进行，决定关联顺序时优化器很重要的功能</li>\n<li>将外连接转化成内连接，内连接的效率要高于外连接（内连接的数据量少）</li>\n<li>使用等价变换规则，mysql可以使用一些等价变化来简化并规划表达式</li>\n<li>优化count(),min(),max()；索引和列是否可以为空通常可以帮助mysql优化这类表达式：例如，要找到某一列的最小值，只需要查询索引的最左端的记录即可，不需要全文扫描比较</li>\n<li>预估并转化为常数表达式，当mysql检测到一个表达式可以转化为常数的时候，就会一直把该表达式作为常数进行处理</li>\n<li>索引覆盖扫描，当索引中的列包含所有查询中需要使用的列的时候，可以使用覆盖索引</li>\n<li>子查询优化，mysql在某些情况下可以将子查询转换一种效率更高的形式，从而减少多个查询多次对数据进行访问，例如将经常查询的数据放入到缓存中</li>\n<li>等值传播，如果两个列的值通过等式关联，那么mysql能够把其中一个列的where条件传递到另一个上</li>\n</ol>\n</li>\n<li><p>关联查询<br>  mysql的关联查询很重要，但其实关联查询执行的策略比较简单：mysql对任何关联都执行<strong>嵌套循环关联操作</strong>，即mysql先在一张表中循环取出单条数据，然后再嵌套到下一个表中寻找匹配的行，依次下去，直到找到所有表中匹配的行为止。然后根据各个表匹配的行，返回查询中需要的各个列。mysql会尝试在最后一个关联表中找到所有匹配的行，如果最后一个关联表无法找到更多的行之后，mysql返回到上一层次关联表，看是否能够找到更多的匹配记录，以此类推迭代执行。整体的思路如此，但是要注意实际的执行过程中有多个变种形式</p>\n<ul>\n<li>join的实现方式有三种<ol>\n<li>Simple Nested-Loop Join</li>\n<li>Index Nested-Loop Join</li>\n<li>Block Nested-Loop Join</li>\n</ol>\n</li>\n<li>straight_join关键字可以固定join的表按sql的顺序来</li>\n</ul>\n</li>\n<li><p>排序优化<br>  无论如何排序都是一个成本很高的操作，所以从性能的角度出发，应该尽可能避免排序或者尽可能避免对大量数据进行排序。推荐使用利用索引进行排序，但是当不能使用索引的时候，mysql就需要自己进行排序，如果数据量小则再内存中进行，如果数据量大就需要使用磁盘，mysql中称之为filesort。如果需要排序的数据量小于排序缓冲区(show variables like ‘%sort_buffer_size%’;),mysql使用内存进行快速排序操作，如果内存不够排序，那么mysql就会先将树分块，对每个独立的块使用快速排序进行排序，并将各个块的排序结果存放再磁盘上，然后将各个排好序的块进行合并，最后返回排序结果</p>\n<ul>\n<li><p>排序的算法</p>\n<ol>\n<li>两次传输排序<br> 第一次数据读取是将需要排序的字段读取出来，然后进行排序，第二次是将排好序的结果按照需要去读取数据行。这种方式效率比较低，原因是第二次读取数据的时候因为已经排好序，需要去读取所有记录而此时更多的是随机IO，读取数据成本会比较高两次传输的优势，在排序的时候存储尽可能少的数据，让排序缓冲区可以尽可能多的容纳行数来进行排序操作</li>\n<li>单次传输排序<br>  先读取查询所需要的所有列，然后再根据给定列进行排序，最后直接返回排序结果，此方式只需要一次顺序IO读取所有的数据，而无须任何的随机IO，问题在于查询的列特别多的时候，会占用大量的存储空间，无法存储大量的数据</li>\n</ol>\n<ul>\n<li>当需要排序的列的总大小超过max_length_for_sort_data定义的字节，mysql会选择双次排序，反之使用单次排序，当然，用户可以设置此参数的值来选择排序的方式</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"优化特定类型的查询\"   >\n          <a href=\"#优化特定类型的查询\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>优化特定类型的查询</h2>\n      <ol>\n<li><p>优化count()查询</p>\n<ol>\n<li>count(1)、count( * )效率一样</li>\n<li>总有人认为myisam的count函数比较快，这是有前提条件的，只有没有任何where条件的count( * )才是比较快的</li>\n<li>使用近似值，在某些应用场景中，不需要完全精确的值，可以参考使用近似值来代替，比如可以使用explain来获取近似的值</li>\n<li>更复杂的优化，一般情况下，count()需要扫描大量的行才能获取精确的数据，其实很难优化，在实际操作的时候可以考虑<strong>使用索引覆盖扫描，或者增加汇总表，或者增加外部缓存系统</strong>。</li>\n</ol>\n</li>\n<li><p>优化关联查询</p>\n<ol>\n<li>确保on或者using子句中的列上有索引，在创建索引的时候就要考虑到关联的顺序</li>\n<li>确保任何的group by和order by中的表达式只涉及到一个表中的列，这样mysql才有可能使用索引来优化这个过程</li>\n</ol>\n</li>\n<li><p>优化子查询，合理选择关联查询和子查询；原因：临时表，子查询产生的临时表放子查询的结果，关联查询产生的临时表放的是结果，根据数据量合理选择</p>\n</li>\n<li><p>优化limit分页</p>\n<ul>\n<li>在很多应用场景中我们需要将数据进行分页，一般会使用limit加上偏移量的方法实现，同时加上合适的order by 的子句，如果这种方式有索引的帮助，效率通常不错，否则的化需要进行大量的文件排序操作，还有一种情况，当偏移量非常大的时候，前面的大部分数据都会被抛弃，这样的代价太高。要优化这种查询的话，要么是在页面中限制分页的数量，要么优化大偏移量的性能。优化此类查询的最简单的办法就是<strong>尽可能地使用覆盖索引，而不是查询所有的列</strong></li>\n</ul>\n</li>\n<li><p>优化union查询</p>\n<ul>\n<li>mysql总是通过创建并填充临时表的方式来执行union查询，因此很多优化策略在union查询中都没法很好的使用。经常需要手工的将where、limit、order by等子句下推到各个子查询中，以便优化器可以充分利用这些条件进行优化。</li>\n<li>除非确实需要服务器消除重复的行，否则一定要使用union all，因此没有all关键字，mysql会在查询的时候给临时表加上distinct的关键字，这个操作的代价很高</li>\n</ul>\n</li>\n<li><p>推荐使用用户自定义变量</p>\n<ul>\n<li>用户自定义变量是一个容易被遗忘的mysql特性，但是如果能够用好，在某些场景下可以写出非常高效的查询语句，在查询中混合使用过程化和关系话逻辑的时候，自定义变量会非常有用。用户自定义变量是一个用来存储内容的临时容器，在连接mysql的整个过程中都存在。****</li>\n</ul>\n<ol>\n<li>自定义变量的使用<ol>\n<li>set @one :=1</li>\n<li>set @min_actor :=(select min(actor_id) from actor)</li>\n<li>set @last_week :=current_date-interval 1 week;</li>\n</ol>\n</li>\n<li>自定义变量的限制<ol>\n<li>无法使用查询缓存</li>\n<li>不能在使用常量或者标识符的地方使用自定义变量，例如表名、列名或者limit子句</li>\n<li>用户自定义变量的生命周期是在一个连接中有效，所以不能用它们来做连接间的通信</li>\n<li>不能显式地声明自定义变量地类型</li>\n<li>mysql优化器在某些场景下可能会将这些变量优化掉，这可能导致代码不按预想地方式运行</li>\n<li>赋值符号：=的优先级非常低，所以在使用赋值表达式的时候应该明确的使用括号</li>\n<li>使用未定义变量不会产生任何语法错误</li>\n</ol>\n</li>\n<li>自定义变量的使用案例<ol>\n<li>优化排名语句<ul>\n<li>select actor_id,@rownum:=@rownum+1 as rownum from actor limit 10;</li>\n</ul>\n</li>\n<li>避免重新查询刚刚更新的数据<ol>\n<li>update t1 set  lastUpdated=now() where id =1;<br> select lastUpdated from t1 where id =1;</li>\n<li>update t1 set lastupdated = now() where id = 1 and @now:=now();<br> select @now;</li>\n</ol>\n</li>\n<li>确定取值的顺序<br> 在赋值和读取变量的时候可能是在查询的不同阶段<br> \n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a8be2160a154a678d3a50.png\"  alt=\"4d2a5d8b3885fad482008d2cf836a9c0.png\">\n      <br> 三种用法，第一种返回两条数据，因为是先判断@rownum&lt;=1再加一<br> 第三种是先加一，在判断<br> 第二种有order by的时候慎用，因为使用自定义变量order by会先执行</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n","categories":["MySQL"],"tags":["MySQL","MySQL调优"]},{"title":"MySQL索引及通过索引进行优化","url":"/2020/09/23/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E9%80%9A%E8%BF%87%E7%B4%A2%E5%BC%95%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96/","content":"\n        <h1 id=\"MySQL索引及通过索引进行优化\"   >\n          <a href=\"#MySQL索引及通过索引进行优化\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>MySQL索引及通过索引进行优化</h1>\n      <ul>\n<li>本文前部分内容与  文章：MySQL索引  一样，后面添加了一些补充</li>\n</ul>\n<blockquote>\n<p>磁盘预读（预读的长度一般为页（page）的整数倍，页大小通常为4k）：<br><br>&emsp;页是存储器的逻辑块，操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页,主存和磁盘以页为单位交换数据。</p>\n</blockquote>\n<a id=\"more\"></a>\n\n\n        <h2 id=\"MySQL整体结构简图\"   >\n          <a href=\"#MySQL整体结构简图\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>MySQL整体结构简图</h2>\n      <p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a865d160a154a678b7ed1.png\"  alt=\"0052f2fa8f97c4e94334b422f8d6990e.png\">\n      </p>\n<p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a865d160a154a678b7eca.png\"  alt=\"3d704f5810f1e7af0969454754849e43.png\">\n      </p>\n<ul>\n<li>聚簇索引：数据和文件放在一起：innodb<ul>\n<li>.frm文件：存放表结构</li>\n<li>.ibd文件：存放数据文件和索引文件</li>\n</ul>\n</li>\n</ul>\n<p>注意：MySQL的innodb存储引擎在默认情况下会把所有的数据文件放到表空间中，不会为每一个单独的表存一分数据文件。</p>\n<ul>\n<li>费聚簇索引：数据、索引单独一个文件：MyISAM<ul>\n<li>.frm文件：存放表结构</li>\n<li>.MYI文件：存放索引数据</li>\n<li>.MYD文件：存放实际数据</li>\n</ul>\n</li>\n</ul>\n<p>具体查看<span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://app.yinxiang.com/shard/s22/nl/23898398/583df461-257e-4486-98a7-35ec3811bb5e\" >mysql架构</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n\n        <h2 id=\"索引是什么\"   >\n          <a href=\"#索引是什么\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>索引是什么</h2>\n      <ol>\n<li>索引是帮助 MySQL 高效获取数据的数据结构</li>\n<li>索引存储在文件系统中</li>\n<li>索引的文件存储形式与存储引擎有关</li>\n<li>索引文件的结构<ol>\n<li>hash</li>\n<li>二叉树</li>\n<li>B树</li>\n<li>B+树（mysql用B+树）</li>\n</ol>\n</li>\n</ol>\n\n        <h2 id=\"各种数据结构情况\"   >\n          <a href=\"#各种数据结构情况\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>各种数据结构情况</h2>\n      \n        <h3 id=\"hash表\"   >\n          <a href=\"#hash表\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>hash表</h3>\n      <p>哈希表可以完成索引的存储，每次在添加索引的时候需要计算指定列的hash值，取模运算后计算出下标，将元素插入下标位置即可<br>适合场景:</p>\n<ol>\n<li>等值查询</li>\n<li>表中的数据是无序数据(范围查找的时候比较浪费时间,需要个进行遍历操作</li>\n</ol>\n<p>在企业中多数的查询时范围查询，所以此时hash表不是特别合适<br>hash表在使用的时候,需要将全部的数据加载到内存,比较耗费内存的空间也不是很合适</p>\n<p>缺点：</p>\n<ol>\n<li>利用hash存储的话需要将所有的数据文件添加到内存，比较耗费内存空间</li>\n<li>如果所有的查询都是等值查询，那么hash确实很快，但是在企业或者实际工作环境中范围查找的数据更多，而不是等值查询，因此hash就不太适合了</li>\n</ol>\n\n        <h3 id=\"树\"   >\n          <a href=\"#树\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>树</h3>\n      <p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a865d160a154a678b7ecd.png\"  alt=\"9875b71260c51c13b9f32004748e9ff4.png\">\n      </p>\n<p>在树的结构中，左子树必须小于根节点，右子树必须大于根节点，如果是多叉树的话，从左到右是有序</p>\n<ol>\n<li>AVL平衡树<br>AVL树是一颗严格意义上的平衡树，最高子树跟最低子树高度之差不能超过1因此在进行元素插入的时候，会进行1到N次的旋转，严重影响插入的性能</li>\n<li>红黑树<br>红黑树是基于AVL树的一个升级，损失了部分查的性能，来提升插入的性能，在红黑树中最低子树跟最高子树<br>之差小于2倍即可，在插入的时候，不需要进行N多次的旋转操作，而且还加入了变色的特性，来满足插入和查间性能的平衡</li>\n<li>总结<br>二又树及其N多的变种都不能支撑素引，原因是<br> <strong>1. 树的深度无法控制而造成io次数变多，影响数据读取的效率</strong><br> <strong>2. 插入数据的性能比较低</strong></li>\n</ol>\n\n        <h3 id=\"B树\"   >\n          <a href=\"#B树\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>B树</h3>\n      <p>B树特点：</p>\n<ol>\n<li>所有键值分布在整颗树中</li>\n<li>搜索有可能在非叶子结点结束，在关键字全集内做一次查找,性能逼近二分查找</li>\n<li>每个节点最多拥有m个子树</li>\n<li>根节点至少有2个子树</li>\n<li>分支节点至少拥有m/2颗子树（除根节点和叶子节点外都是分支节点）</li>\n<li>所有叶子节点都在同一层、每个节点最多可以有m-1个key，并且以升序排列</li>\n</ol>\n<p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a86c1160a154a678b9d96.png\"  alt=\"b76a5637732e2c68a28dfa43ab974e38.png\">\n      </p>\n<p>实例图说明：<br>每个节点占用一个磁盘块，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为 16 和 34，P1 指针指向的子树的数据范围为小于 16，P2 指针指向的子树的数据范围为 16~34，P3 指针指向的子树的数据范围为大于 34。 </p>\n<p>查找关键字过程：</p>\n<ol>\n<li>根据根节点找到磁盘块 1，读入内存。【磁盘 I/O 操作第 1 次】</li>\n<li>比较关键字 28 在区间（16,34），找到磁盘块 1 的指针 P2。</li>\n<li>根据 P2 指针找到磁盘块 3，读入内存。【磁盘 I/O 操作第 2 次】</li>\n<li>比较关键字 28 在区间（25,31），找到磁盘块 3 的指针 P2。</li>\n<li>根据 P2 指针找到磁盘块 8，读入内存。【磁盘 I/O 操作第 3 次】</li>\n<li>在磁盘块 8 中的关键字列表中找到关键字 28。 </li>\n</ol>\n<p>缺点：<br>1、每个节点都有key，同时也包含data，而每个页存储空间是有限的，如果data比较大的话会导致每个节点存储的key数量变小<br>2、当存储的数据量很大的时候会导致深度较大，增大查询时磁盘io次数，进而影响查询性能</p>\n\n        <h3 id=\"B-树\"   >\n          <a href=\"#B-树\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>B+树</h3>\n      <p>B+Tree是在BTree的基础之上做的一种优化，变化如下：</p>\n<ol>\n<li>B+Tree每个节点可以包含更多的节点，这个做的原因有两个，第一个原因是为了降低树的高度，第二个原因是将数据范围变为多个区间，区间越多，数据检索越快</li>\n<li>非叶子节点存储key，叶子节点存储key和数据</li>\n<li>叶子节点两两指针相互连接（符合磁盘的预读特性），顺序查询性能更高</li>\n</ol>\n<p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a86c1160a154a678b9d85.png\"  alt=\"056b526af9bb4b8829afd9651256d980.png\">\n      </p>\n<p>注意：在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对 B+Tree 进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找（查单个和查范围都可以）。</p>\n\n        <h4 id=\"InnoDB–B-Tree（叶子节点直接放置数据）\"   >\n          <a href=\"#InnoDB–B-Tree（叶子节点直接放置数据）\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>InnoDB–B+Tree（叶子节点直接放置数据）</h4>\n      <p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a86c1160a154a678b9d8c.png\"  alt=\"d83dc7c66c85f62bea3c11b5feaf772b.png\">\n      </p>\n<p>注意：</p>\n<ol>\n<li>InnoDB是通过B+Tree结构对主键创建索引，然后叶子节点中存储记录，如果没有主键，那么会选择唯一键，如果没有唯一键，那么会生成一个6位的row_id来作为主键</li>\n<li>如果创建索引的键是其他字段，那么在叶子节点中存储的是该记录的主键，然后再通过主键索引找到对应的记录,叫做<strong>回表</strong></li>\n</ol>\n\n        <h5 id=\"回表\"   >\n          <a href=\"#回表\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>回表</h5>\n      <p>回表：如果创建索引的键不是主键、唯一键，那么在叶子节点中存储的是该记录的主键，然后再通过主键索引找到对应的记录。<strong>查找了两颗B+树</strong></p>\n<p>例如下图，要根据name=’gang’查找，先从第一棵树种找到gang对应的主键是4，在拿4到下一颗树种查找4对应的信息。<br>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a86c1160a154a678b9d8f.png\"  alt=\"f12b0114d7e8ea20cf02bad1aa43a578.png\">\n      </p>\n\n        <h4 id=\"mysql-MyISAM–B-Tree\"   >\n          <a href=\"#mysql-MyISAM–B-Tree\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>mysql MyISAM–B+Tree</h4>\n      <p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a86c1160a154a678b9d93.png\"  alt=\"455277281b6a9864f276d342fe218cdd.png\">\n      </p>\n<p>MyISAM的数据、索引单独存放，叶子结点存放的不是数据，而是数据的地址值</p>\n\n        <h4 id=\"B-树添加与删除\"   >\n          <a href=\"#B-树添加与删除\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>B+树添加与删除</h4>\n      <p><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://app.yinxiang.com/shard/s22/nl/23898398/6770a0a8-33af-42e6-a8e6-c7c744471a8a\" >B+树添加和删除数据图解</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n\n        <h2 id=\"索引的优点\"   >\n          <a href=\"#索引的优点\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>索引的优点</h2>\n      <ol>\n<li>大大减少了服务器需要扫描的数据量</li>\n<li>帮助服务器避免排序和临时表</li>\n<li>将随机io变成顺序io\n        <h2 id=\"索引的用处\"   >\n          <a href=\"#索引的用处\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>索引的用处</h2>\n      </li>\n<li>快速查找匹配WHERE子句的行</li>\n<li>从consideration中消除行,如果可以在多个索引之间进行选择，mysql通常会使用找到最少行的索引</li>\n<li>如果表具有多列索引，则优化器可以使用索引的任何最左前缀来查找行</li>\n<li>当有表连接的时候，从其他表检索行数据</li>\n<li>查找特定索引列的min或max值</li>\n<li>如果排序或分组时在可用索引的最左前缀上完成的，则对表进行排序和分组</li>\n<li>在某些情况下，可以优化查询以检索值而无需查询数据行\n        <h2 id=\"索引的类型\"   >\n          <a href=\"#索引的类型\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>索引的类型</h2>\n      </li>\n</ol>\n<p>mysql索引的五种类型：主键索引、唯一索引、普通索引和全文索引、组合索引。通过给字段添加索引可以提高数据的读取速度，提高项目的并发能力和抗压能力。</p>\n<ol>\n<li>主键索引<br> 主键是一种唯一性索引，但它必须指定为PRIMARY KEY，每个表只能有一个主键。如果无特殊需求，考虑把主键设置自增，可以减少页分裂和页合并操作，减少IO提高效率</li>\n<li>唯一索引<br> 索引列的所有值都只能出现一次，即必须唯一，值可以为空。</li>\n<li>普通索引<br> 基本的索引类型，值可以为空，没有唯一性的限制。（覆盖索引）</li>\n<li>全文索引（MyISAM支持，Innodb在5.6之后支持）<br> 全文索引的索引类型为FULLTEXT。全文索引可以在varchar、char、text类型的列上创建<br> 项目中基本不用mysql做这个，一般用ES</li>\n<li>组合索引<br> 多列值组成一个索引，专门用于组合搜索（最左匹配原则）。<br> 当包含多个列作为索引，需要注意的是正确的顺序依赖于该索引的查询，同时需要考虑如何更好的满足排序和分组的需要</li>\n</ol>\n\n        <h3 id=\"组合索引案例\"   >\n          <a href=\"#组合索引案例\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>组合索引案例</h3>\n      <ul>\n<li><strong>当使用组合索引的时候，要尽可能的再wehere子句中添加组合索引中包含的列</strong><br>建立组合索引a,b,c<br>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a8b67160a154a678d1183.png\"  alt=\"d35abdff971462ac4e3d53b77d63dd4f.png\">\n      </li>\n<li>上图中倒数第二条：因为b是范围查找，所以后面c不会再使用索引</li>\n<li>上图最后一条结论错误，应该是只是用了a，b因为前面也有%，所以不会使用索引</li>\n</ul>\n\n        <h3 id=\"覆盖索引\"   >\n          <a href=\"#覆盖索引\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>覆盖索引</h3>\n      <p>覆盖索引：<br>简单来说就是 <strong>索引包含了（或覆盖了）满足查询语句中字段与条件的数据</strong><br>解释：一张表有id、name两个字段，建立了id、name两个索引，如果要select * from tab where name=’’，需要在name索引中找到对应的id，再拿id去查询（回表，两次查询）。<br>    此时如果将sql改写为select id from tab where name=’’，这样在name索引中就可以找到结果（没有回表，一次查询）。<br>优点：减少io，提升效率<br>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a873f160a154a678bc326.png\"  alt=\"0c8be303325bf5ea34767e8e135e9aad.png\">\n      </p>\n\n        <h3 id=\"最左前缀匹配原则\"   >\n          <a href=\"#最左前缀匹配原则\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>最左前缀匹配原则</h3>\n      <p>在MySQL建立联合索引时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配</p>\n\n        <h3 id=\"索引下推\"   >\n          <a href=\"#索引下推\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>索引下推</h3>\n      <p>简单来说就是 在回表之前先做筛选，可以使回表查询的全行数据比较少，这就是mysql的索引下推。</p>\n<p>例如：<br>对于user_table表，我们现在有（username,age）联合索引。<br>现在有一个需求，查出名称中以“张”开头且年龄小于等于10的用户信息，语句如下：<br>“select * from user_table where username like ‘张%’ and age &gt; 10”.<br>此时，根据（username,age）联合索引查询所有满足名称以“张”开头的索引，<strong>然后直接再筛选出年龄小于等于10的索引，之后再回表查询全行数据</strong>，这种方式需要回表查询的全行数据比较少，就是mysql的索引下推</p>\n\n        <h2 id=\"索引匹配方式\"   >\n          <a href=\"#索引匹配方式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>索引匹配方式</h2>\n      <figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> staffs(    </span><br><span class=\"line\">    <span class=\"keyword\">id</span> <span class=\"built_in\">int</span> primary <span class=\"keyword\">key</span> auto_increment,    </span><br><span class=\"line\">    <span class=\"keyword\">name</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">24</span>) <span class=\"keyword\">not</span> <span class=\"literal\">null</span> <span class=\"keyword\">default</span> <span class=\"string\">&#x27;&#x27;</span> <span class=\"keyword\">comment</span> <span class=\"string\">&#x27;姓名&#x27;</span>,    </span><br><span class=\"line\">    age <span class=\"built_in\">int</span> <span class=\"keyword\">not</span> <span class=\"literal\">null</span> <span class=\"keyword\">default</span> <span class=\"number\">0</span> <span class=\"keyword\">comment</span> <span class=\"string\">&#x27;年龄&#x27;</span>,    </span><br><span class=\"line\">    pos <span class=\"built_in\">varchar</span>(<span class=\"number\">20</span>) <span class=\"keyword\">not</span> <span class=\"literal\">null</span> <span class=\"keyword\">default</span> <span class=\"string\">&#x27;&#x27;</span> <span class=\"keyword\">comment</span> <span class=\"string\">&#x27;职位&#x27;</span>,    </span><br><span class=\"line\">    add_time <span class=\"built_in\">timestamp</span> <span class=\"keyword\">not</span> <span class=\"literal\">null</span> <span class=\"keyword\">default</span> <span class=\"keyword\">current_timestamp</span> <span class=\"keyword\">comment</span> <span class=\"string\">&#x27;入职时间&#x27;</span> </span><br><span class=\"line\">) <span class=\"keyword\">charset</span> utf8 <span class=\"keyword\">comment</span> <span class=\"string\">&#x27;员工记录表&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">-----------</span></span><br><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> staffs <span class=\"keyword\">add</span> <span class=\"keyword\">index</span> idx_nap(<span class=\"keyword\">name</span>, age, pos);</span><br></pre></td></tr></table></div></figure>\n<ul>\n<li>创建组合索引idx_nap(name, age, pos);</li>\n</ul>\n<ol>\n<li>全值匹配。全值匹配指的是和索引中的所有列进行匹配<br> explain select * from staffs where name = ‘July’ and age = ‘23’ and pos = ‘dev’;</li>\n<li>匹配最左前缀。只匹配前面的几列<br> explain select * from staffs where name = ‘July’ and age = ‘23’;</li>\n<li>匹配列前缀。可以匹配某一列的值的开头部分<br>  explain select * from staffs where name like ‘J%’;</li>\n<li>匹配范围值。可以查找某一个范围的数据<br> explain select * from staffs where name &gt; ‘Mary’;</li>\n<li>精确匹配某一列并范围匹配另外一列。可以查询第一列的全部和第二列的部分<br> explain select * from staffs where name = ‘July’ and age &gt; 25;</li>\n<li>只访问索引的查询。查询的时候只需要访问索引，不需要访问数据行，本质上就是覆盖索引<br> explain select name,age,pos from staffs where name = ‘July’ and age = 25 and pos = ‘dev’;</li>\n</ol>\n\n        <h2 id=\"hash索引（不太重要）\"   >\n          <a href=\"#hash索引（不太重要）\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>hash索引（不太重要）</h2>\n      <p>基于哈希表的实现，只有精确匹配索引所有列的查询才有效。在mysql中，只有<strong>memory</strong>的存储引擎显式支持哈希索引，哈希索引自身只需存储对应的hash值，所以索引的结构十分紧凑，这让哈希索引<strong>查找的速度非常快</strong></p>\n\n        <h3 id=\"hash索引限制\"   >\n          <a href=\"#hash索引限制\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>hash索引限制</h3>\n      <ol>\n<li>哈希索引只包含哈希值和行指针，而不存储字段值，索引不能使用索引中的值来避免读取行</li>\n<li>哈希索引数据并不是按照索引值顺序存储的，所以无法进行排序</li>\n<li>哈希索引不支持部分列匹配查找，哈希索引是使用索引列的全部内容来计算哈希值</li>\n<li>哈希索引支持等值比较查询，也不支持任何范围查询</li>\n<li>访问哈希索引的数据非常快，除非有很多哈希冲突，当出现哈希冲突的时候，存储引擎必须遍历链表中的所有行指针，逐行进行比较，直到找到所有符合条件的行</li>\n<li>哈希冲突比较多的话，维护的代价也会很高</li>\n</ol>\n<ul>\n<li><strong>如果有一张基本不修改数据量非常大（百万条）的常量表，可以使用memory存储引擎</strong></li>\n</ul>\n\n        <h2 id=\"Mysql存储引擎区别\"   >\n          <a href=\"#Mysql存储引擎区别\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Mysql存储引擎区别</h2>\n      <div class=\"table-container\"><table>\n<thead>\n<tr>\n<th></th>\n<th>MyISAM</th>\n<th>InnoDB</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>索引类型</td>\n<td>非聚簇索引</td>\n<td>聚簇索引</td>\n</tr>\n<tr>\n<td>支持事务</td>\n<td>否</td>\n<td>是</td>\n</tr>\n<tr>\n<td>支持表锁</td>\n<td>是</td>\n<td>是</td>\n</tr>\n<tr>\n<td>支持行锁</td>\n<td>否</td>\n<td>是</td>\n</tr>\n<tr>\n<td>支持外键</td>\n<td>否</td>\n<td>是</td>\n</tr>\n<tr>\n<td>支持全文索引</td>\n<td>是</td>\n<td>是（5.6后支持）</td>\n</tr>\n<tr>\n<td>适合操作类型</td>\n<td>大量select</td>\n<td>大量insert、delete、update</td>\n</tr>\n</tbody></table></div>\n<ul>\n<li>memory存储引擎，数据在内存，不能持久化，使用hash索引，速度快</li>\n<li>非聚簇索引：数据文件跟索引文件分开存放</li>\n<li>聚簇索引：不是单独的索引类型，而是一种数据存储方式，指的是数据行跟相邻的键值紧凑的存储在一起</li>\n</ul>\n\n        <h2 id=\"索引维护\"   >\n          <a href=\"#索引维护\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>索引维护</h2>\n      <p>索引在插入新的值的时候，为了维护索引的有序性，必须要维护，在维护索引的时候需要需要分以下集中情况：</p>\n<ol>\n<li>如果插入一个比较大的值，直接插入即可，几乎没有成本</li>\n<li>如果插入的是中间的某一个值，需要逻辑上移动后续的元素，空出位置</li>\n<li>如果需要插入的数据页满了，就需要单独申请一个新的数据页，然后移动部分数据过去，叫做<strong>页分裂</strong>，此时性能会受影响同时空间的使用率也会降低，除了页分裂之外还包含<strong>页合并</strong></li>\n</ol>\n\n        <h2 id=\"前缀索引\"   >\n          <a href=\"#前缀索引\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>前缀索引</h2>\n      <p>有时候需要索引很长的字符串，这会让索引变的大且慢，通常情况下可以使用某个列开始的部分字符串，这样大大的节约索引空间，从而提高索引效率，但这会降低索引的选择性，索引的选择性是指不重复的索引值和数据表记录总数的比值，范围从1/#T到1之间。索引的选择性越高则查询效率越高，因为选择性更高的索引可以让mysql在查找的时候过滤掉更多的行。<br>    一般情况下某个列前缀的选择性也是足够高的，足以满足查询的性能，但是对应BLOB,TEXT,VARCHAR类型的列，必须要使用前缀索引，因为mysql不允许索引这些列的完整长度，使用该方法的诀窍在于要选择足够长的前缀以保证较高的选择性，通过又不能太长。</p>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--创建数据表</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> citydemo(city <span class=\"built_in\">varchar</span>(<span class=\"number\">50</span>) <span class=\"keyword\">not</span> <span class=\"literal\">null</span>);</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> citydemo(city) <span class=\"keyword\">select</span> city <span class=\"keyword\">from</span> city;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--重复执行5次下面的sql语句</span></span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> citydemo(city) <span class=\"keyword\">select</span> city <span class=\"keyword\">from</span> citydemo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--更新城市表的名称</span></span><br><span class=\"line\"><span class=\"keyword\">update</span> citydemo <span class=\"keyword\">set</span> city=(<span class=\"keyword\">select</span> city <span class=\"keyword\">from</span> city <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> <span class=\"keyword\">rand</span>() <span class=\"keyword\">limit</span> <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--查找最常见的城市列表，发现每个值都出现45-65次，</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">count</span>(*) <span class=\"keyword\">as</span> cnt,city <span class=\"keyword\">from</span> citydemo <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> city <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> cnt <span class=\"keyword\">desc</span> <span class=\"keyword\">limit</span> <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--查找最频繁出现的城市前缀，先从3个前缀字母开始，发现比原来出现的次数更多，可以分别截取多个字符查看城市出现的次数</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">count</span>(*) <span class=\"keyword\">as</span> cnt,<span class=\"keyword\">left</span>(city,<span class=\"number\">3</span>) <span class=\"keyword\">as</span> pref <span class=\"keyword\">from</span> citydemo <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> pref <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> cnt <span class=\"keyword\">desc</span> <span class=\"keyword\">limit</span> <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">count</span>(*) <span class=\"keyword\">as</span> cnt,<span class=\"keyword\">left</span>(city,<span class=\"number\">7</span>) <span class=\"keyword\">as</span> pref <span class=\"keyword\">from</span> citydemo <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> pref <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> cnt <span class=\"keyword\">desc</span> <span class=\"keyword\">limit</span> <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"comment\">--此时前缀的选择性接近于完整列的选择性</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--还可以通过另外一种方式来计算完整列的选择性，可以看到当前缀长度到达7之后，再增加前缀长度，选择性提升的幅度已经很小了</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">count</span>(<span class=\"keyword\">distinct</span> <span class=\"keyword\">left</span>(city,<span class=\"number\">3</span>))/<span class=\"keyword\">count</span>(*) <span class=\"keyword\">as</span> sel3,</span><br><span class=\"line\"><span class=\"keyword\">count</span>(<span class=\"keyword\">distinct</span> <span class=\"keyword\">left</span>(city,<span class=\"number\">4</span>))/<span class=\"keyword\">count</span>(*) <span class=\"keyword\">as</span> sel4,</span><br><span class=\"line\"><span class=\"keyword\">count</span>(<span class=\"keyword\">distinct</span> <span class=\"keyword\">left</span>(city,<span class=\"number\">5</span>))/<span class=\"keyword\">count</span>(*) <span class=\"keyword\">as</span> sel5,</span><br><span class=\"line\"><span class=\"keyword\">count</span>(<span class=\"keyword\">distinct</span> <span class=\"keyword\">left</span>(city,<span class=\"number\">6</span>))/<span class=\"keyword\">count</span>(*) <span class=\"keyword\">as</span> sel6,</span><br><span class=\"line\"><span class=\"keyword\">count</span>(<span class=\"keyword\">distinct</span> <span class=\"keyword\">left</span>(city,<span class=\"number\">7</span>))/<span class=\"keyword\">count</span>(*) <span class=\"keyword\">as</span> sel7,</span><br><span class=\"line\"><span class=\"keyword\">count</span>(<span class=\"keyword\">distinct</span> <span class=\"keyword\">left</span>(city,<span class=\"number\">8</span>))/<span class=\"keyword\">count</span>(*) <span class=\"keyword\">as</span> sel8 </span><br><span class=\"line\"><span class=\"keyword\">from</span> citydemo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--计算完成之后可以创建前缀索引</span></span><br><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> citydemo <span class=\"keyword\">add</span> <span class=\"keyword\">key</span>(city(<span class=\"number\">7</span>));</span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n<ul>\n<li>前缀索引是一种能使索引更小更快的有效方法，但是也包含缺点：mysql无法使用前缀索引做order by 和 group by。</li>\n</ul>\n\n        <h2 id=\"优化小细节\"   >\n          <a href=\"#优化小细节\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>优化小细节</h2>\n      <ol>\n<li><p>当使用索引列进行查询的时候尽量不要使用表达式，把计算放到业务层而不是数据库层</p>\n</li>\n<li><p>尽量使用主键查询，而不是其他索引，因此主键查询不会触发回表查询</p>\n</li>\n<li><p>使用前缀索引</p>\n</li>\n<li><p>使用索引扫描来排序。</p>\n<ul>\n<li>在排序的时候，如果where列和order by能组成最左前缀，那么就是使用索引扫描来排序，但是不能使用范围查找，排序不能一个asc 一个desc</li>\n</ul>\n</li>\n<li><p>union all,in,or都能够使用索引，但是推荐使用in</p>\n</li>\n<li><p>范围列可以用到索引</p>\n<ol>\n<li>范围条件是：&lt;、&lt;=、&gt;、&gt;=、between</li>\n<li>范围列可以用到索引，但是范围列后面的列无法用到索引，索引最多用于一个范围列</li>\n</ol>\n</li>\n<li><p>强制类型转换会全表扫描</p>\n</li>\n<li><p>更新十分频繁，数据区分度不高的字段上不宜建立索引</p>\n<ol>\n<li>更新会变更B+树，更新频繁的字段建议索引会大大降低数据库性能</li>\n<li>类似于性别这类区分不大的属性，建立索引是没有意义的，不能有效的过滤数据</li>\n<li>一般区分度在80%以上的时候就可以建立索引，区分度可以使用 count(distinct(列名))/count( * ) 来计算</li>\n</ol>\n<ul>\n<li>一句话概括：维护成本高，区分不大索引没有意义</li>\n</ul>\n</li>\n<li><p>创建索引的列，不允许为null，可能会得到不符合预期的结果</p>\n</li>\n<li><p>当需要进行表连接的时候，最好不要超过三张表，因为需要join的字段，数据类型必须一致</p>\n</li>\n<li><p>能使用limit的时候尽量使用limit，limit作用是<strong>限制输出</strong></p>\n</li>\n<li><p>单表索引建议控制在5个以内</p>\n</li>\n<li><p>单索引字段数不允许超过5个（组合索引，组合索引的列不能超过5个）</p>\n</li>\n<li><p>创建索引的时候应该避免以下错误概念</p>\n<ol>\n<li>索引越多越好</li>\n<li>过早优化，在不了解系统的情况下进行优化</li>\n</ol>\n</li>\n</ol>\n\n        <h2 id=\"索引监控\"   >\n          <a href=\"#索引监控\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>索引监控</h2>\n      <ul>\n<li>show status like ‘Handler_read%’;</li>\n</ul>\n<div class=\"table-container\"><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Handler_read_first</td>\n<td>读取索引第一个条目的次数</td>\n</tr>\n<tr>\n<td><strong>Handler_read_key</strong></td>\n<td>通过index获取数据的次数</td>\n</tr>\n<tr>\n<td>Handler_read_last</td>\n<td>读取索引最后一个条目的次数</td>\n</tr>\n<tr>\n<td>Handler_read_next</td>\n<td>通过索引读取下一条数据的次数</td>\n</tr>\n<tr>\n<td>Handler_read_prev</td>\n<td>通过索引读取上一条数据的次数</td>\n</tr>\n<tr>\n<td>Handler_read_rnd</td>\n<td>从固定位置读取数据的次数</td>\n</tr>\n<tr>\n<td><strong>Handler_read_rnd_next</strong></td>\n<td>从数据节点读取下一条数据的次数</td>\n</tr>\n</tbody></table></div>\n<p>加粗的两个值越大越好，越小说明索引没怎么用</p>\n\n        <h2 id=\"优化案例\"   >\n          <a href=\"#优化案例\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>优化案例</h2>\n      \n        <h1 id=\"索引优化分析案例\"   >\n          <a href=\"#索引优化分析案例\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>索引优化分析案例</h1>\n      <p>预先准备好数据</p>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SET</span> FOREIGN_KEY_CHECKS=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">IF</span> <span class=\"keyword\">EXISTS</span> <span class=\"string\">`itdragon_order_list`</span>;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`itdragon_order_list`</span> (</span><br><span class=\"line\">  <span class=\"string\">`id`</span> <span class=\"built_in\">bigint</span>(<span class=\"number\">11</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> AUTO_INCREMENT <span class=\"keyword\">COMMENT</span> <span class=\"string\">&#x27;主键id，默认自增长&#x27;</span>,</span><br><span class=\"line\">  <span class=\"string\">`transaction_id`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">150</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"literal\">NULL</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">&#x27;交易号&#x27;</span>,</span><br><span class=\"line\">  <span class=\"string\">`gross`</span> <span class=\"keyword\">double</span> <span class=\"keyword\">DEFAULT</span> <span class=\"literal\">NULL</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">&#x27;毛收入(RMB)&#x27;</span>,</span><br><span class=\"line\">  <span class=\"string\">`net`</span> <span class=\"keyword\">double</span> <span class=\"keyword\">DEFAULT</span> <span class=\"literal\">NULL</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">&#x27;净收入(RMB)&#x27;</span>,</span><br><span class=\"line\">  <span class=\"string\">`stock_id`</span> <span class=\"built_in\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"literal\">NULL</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">&#x27;发货仓库&#x27;</span>,</span><br><span class=\"line\">  <span class=\"string\">`order_status`</span> <span class=\"built_in\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"literal\">NULL</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">&#x27;订单状态&#x27;</span>,</span><br><span class=\"line\">  <span class=\"string\">`descript`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"literal\">NULL</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">&#x27;客服备注&#x27;</span>,</span><br><span class=\"line\">  <span class=\"string\">`finance_descript`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"literal\">NULL</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">&#x27;财务备注&#x27;</span>,</span><br><span class=\"line\">  <span class=\"string\">`create_type`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">100</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"literal\">NULL</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">&#x27;创建类型&#x27;</span>,</span><br><span class=\"line\">  <span class=\"string\">`order_level`</span> <span class=\"built_in\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"literal\">NULL</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">&#x27;订单级别&#x27;</span>,</span><br><span class=\"line\">  <span class=\"string\">`input_user`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">20</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"literal\">NULL</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">&#x27;录入人&#x27;</span>,</span><br><span class=\"line\">  <span class=\"string\">`input_date`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">20</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"literal\">NULL</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">&#x27;录入时间&#x27;</span>,</span><br><span class=\"line\">  PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"string\">`id`</span>)</span><br><span class=\"line\">) <span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> AUTO_INCREMENT=<span class=\"number\">10003</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> itdragon_order_list <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;10000&#x27;</span>, <span class=\"string\">&#x27;81X97310V32236260E&#x27;</span>, <span class=\"string\">&#x27;6.6&#x27;</span>, <span class=\"string\">&#x27;6.13&#x27;</span>, <span class=\"string\">&#x27;1&#x27;</span>, <span class=\"string\">&#x27;10&#x27;</span>, <span class=\"string\">&#x27;ok&#x27;</span>, <span class=\"string\">&#x27;ok&#x27;</span>, <span class=\"string\">&#x27;auto&#x27;</span>, <span class=\"string\">&#x27;1&#x27;</span>, <span class=\"string\">&#x27;itdragon&#x27;</span>, <span class=\"string\">&#x27;2017-08-28 17:01:49&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> itdragon_order_list <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;10001&#x27;</span>, <span class=\"string\">&#x27;61525478BB371361Q&#x27;</span>, <span class=\"string\">&#x27;18.88&#x27;</span>, <span class=\"string\">&#x27;18.79&#x27;</span>, <span class=\"string\">&#x27;1&#x27;</span>, <span class=\"string\">&#x27;10&#x27;</span>, <span class=\"string\">&#x27;ok&#x27;</span>, <span class=\"string\">&#x27;ok&#x27;</span>, <span class=\"string\">&#x27;auto&#x27;</span>, <span class=\"string\">&#x27;1&#x27;</span>, <span class=\"string\">&#x27;itdragon&#x27;</span>, <span class=\"string\">&#x27;2017-08-18 17:01:50&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> itdragon_order_list <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;10002&#x27;</span>, <span class=\"string\">&#x27;5RT64180WE555861V&#x27;</span>, <span class=\"string\">&#x27;20.18&#x27;</span>, <span class=\"string\">&#x27;20.17&#x27;</span>, <span class=\"string\">&#x27;1&#x27;</span>, <span class=\"string\">&#x27;10&#x27;</span>, <span class=\"string\">&#x27;ok&#x27;</span>, <span class=\"string\">&#x27;ok&#x27;</span>, <span class=\"string\">&#x27;auto&#x27;</span>, <span class=\"string\">&#x27;1&#x27;</span>, <span class=\"string\">&#x27;itdragon&#x27;</span>, <span class=\"string\">&#x27;2017-09-08 17:01:49&#x27;</span>);</span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n\n<p>逐步开始进行优化：</p>\n<p>第一个案例：</p>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> itdragon_order_list <span class=\"keyword\">where</span> transaction_id = <span class=\"string\">&quot;81X97310V32236260E&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">--通过查看执行计划发现type=all,需要进行全表扫描</span></span><br><span class=\"line\"><span class=\"keyword\">explain</span> <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> itdragon_order_list <span class=\"keyword\">where</span> transaction_id = <span class=\"string\">&quot;81X97310V32236260E&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--优化一、为transaction_id创建唯一索引</span></span><br><span class=\"line\"> <span class=\"keyword\">create</span> <span class=\"keyword\">unique</span> <span class=\"keyword\">index</span> idx_order_transaID <span class=\"keyword\">on</span> itdragon_order_list (transaction_id);</span><br><span class=\"line\"><span class=\"comment\">--当创建索引之后，唯一索引对应的type是const，通过索引一次就可以找到结果，普通索引对应的type是ref，表示非唯一性索引赛秒，找到值还要进行扫描，直到将索引文件扫描完为止，显而易见，const的性能要高于ref</span></span><br><span class=\"line\"> <span class=\"keyword\">explain</span> <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> itdragon_order_list <span class=\"keyword\">where</span> transaction_id = <span class=\"string\">&quot;81X97310V32236260E&quot;</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">--优化二、使用覆盖索引，查询的结果变成 transaction_id,当extra出现using index,表示使用了覆盖索引</span></span><br><span class=\"line\"> <span class=\"keyword\">explain</span> <span class=\"keyword\">select</span> transaction_id <span class=\"keyword\">from</span> itdragon_order_list <span class=\"keyword\">where</span> transaction_id = <span class=\"string\">&quot;81X97310V32236260E&quot;</span>;</span><br></pre></td></tr></table></div></figure>\n\n<p>第二个案例</p>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--创建复合索引</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">index</span> idx_order_levelDate <span class=\"keyword\">on</span> itdragon_order_list (order_level,input_date);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--创建索引之后发现跟没有创建索引一样，都是全表扫描，都是文件排序</span></span><br><span class=\"line\"><span class=\"keyword\">explain</span> <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> itdragon_order_list <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> order_level,input_date;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--可以使用force index强制指定索引</span></span><br><span class=\"line\"><span class=\"keyword\">explain</span> <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> itdragon_order_list <span class=\"keyword\">force</span> <span class=\"keyword\">index</span>(idx_order_levelDate) <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> order_level,input_date;</span><br><span class=\"line\"><span class=\"comment\">--其实给订单排序意义不大，给订单级别添加索引意义也不大，因此可以先确定order_level的值，然后再给input_date排序</span></span><br><span class=\"line\"><span class=\"keyword\">explain</span> <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> itdragon_order_list <span class=\"keyword\">where</span> order_level=<span class=\"number\">3</span> <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> input_date;</span><br></pre></td></tr></table></div></figure>","categories":["MySQL"],"tags":["MySQL","MySQL调优"]},{"title":"MySQL结构与数据类型优化","url":"/2020/09/23/MySQL%E7%BB%93%E6%9E%84%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BC%98%E5%8C%96/","content":"\n        <h1 id=\"MySQL结构与数据类型优化\"   >\n          <a href=\"#MySQL结构与数据类型优化\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>MySQL结构与数据类型优化</h1>\n      \n        <h2 id=\"数据类型的优化\"   >\n          <a href=\"#数据类型的优化\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>数据类型的优化</h2>\n      \n        <h3 id=\"更小的通常更好\"   >\n          <a href=\"#更小的通常更好\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>更小的通常更好</h3>\n      <p>应该尽量使用可以正确存储数据的最小数据类型，更小的数据类型通常更快，因为它们占用更少的磁盘、内存和CPU缓存，并且处理时需要的CPU周期更少，但是要确保没有低估需要存储的值的范围，如果无法确认哪个数据类型，就选择你认为不会超过范围的最小类型</p>\n<a id=\"more\"></a>\n\n\n        <h3 id=\"简单就好\"   >\n          <a href=\"#简单就好\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>简单就好</h3>\n      <p>简单数据类型的操作通常需要更少的CPU周期，例如：</p>\n<ol>\n<li>整型比字符操作代价更低，因为字符集和校对规则是字符比较比整型比较更复杂</li>\n<li>使用mysql自建类型而不是字符串来存储日期和时间</li>\n<li>用整型存储IP地址</li>\n</ol>\n\n        <h3 id=\"尽量避免null\"   >\n          <a href=\"#尽量避免null\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>尽量避免null</h3>\n      <p>如果查询中包含可为NULL的列，对mysql来说很难优化，因为可为null的列使得索引、索引统计和值比较都更加复杂，坦白来说，通常情况下null的列改为not null带来的性能提升比较小，所有没有必要将所有的表的结构进行修改，尽量避免设计成可为null的列</p>\n\n        <h3 id=\"实际细则\"   >\n          <a href=\"#实际细则\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>实际细则</h3>\n      <ol>\n<li><p>整数类型<br> 可以使用的几种整数类型：<br> TINYINT，SMALLINT，MEDIUMINT，INT，BIGINT分别使用8，16，24，32，64位存储空间。<br> 尽量使用满足需求的最小数据类型</p>\n</li>\n<li><p>字符和字符串类型</p>\n<ol>\n<li>char长度固定，即每条数据占用等长字节空间；最大长度是255个字符，适合用在身份证号、手机号等定长字符串</li>\n<li>varchar可变程度，可以设置最大长度；最大空间是65535个字节，适合用在长度可变的属性</li>\n<li>text不设置长度，当不知道属性的最大长度时，适合用text按照查询速度：char&gt;varchar&gt;text</li>\n</ol>\n<ul>\n<li>varchar根据实际内容长度保存数据<ol>\n<li>使用最小的符合需求的长度</li>\n<li>varchar(n) n小于等于255使用额外一个字节保存长度，n&gt;255使用额外两个字节保存长度</li>\n<li>varchar(5)与varchar(255)保存同样的内容，硬盘存储空间相同，但内存空间占用不同，是指定的大小</li>\n<li>varchar在mysql5.6之前变更长度，或者从255一下变更到255以上时时，都会导致锁表</li>\n<li>应用场景<ol>\n<li>存储长度波动较大的数据，如：文章，有的会很短有的会很长</li>\n<li>字符串很少更新的场景，每次更新后都会重算并使用额外存储空间保存长度</li>\n<li>适合保存多字节字符，如：汉字，特殊字符等</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>char固定长度的字符串<ol>\n<li>最大长度：255</li>\n<li>会自动删除末尾的空格</li>\n<li>检索效率、写效率 会比varchar高，以空间换时间</li>\n<li>应用场景<ol>\n<li>存储长度波动不大的数据，如：md5摘要</li>\n<li>存储短字符串、经常更新的字符串</li>\n</ol>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>BLOB和TEXT类型<br> MySQL 把每个 BLOB 和 TEXT 值当作一个独立的对象处理。两者都是为了存储很大数据而设计的字符串类型，分别采用二进制和字符方式存储。</p>\n</li>\n<li><p>datetime和timestamp、date</p>\n<ol>\n<li>不要使用字符串类型来存储日期时间数据</li>\n<li>日期时间类型通常比字符串占用的存储空间小</li>\n<li>日期时间类型在进行查找过滤时可以利用日期来进行比对</li>\n<li>日期时间类型还有着丰富的处理函数，可以方便的对时间类型进行日期计算</li>\n<li>使用int存储日期时间不如使用timestamp类型</li>\n</ol>\n<ul>\n<li>datetime占用8个字节，与时区无关，数据库底层时区配置，对datetime无效，可保存到毫秒，可保存时间范围大，不要使用字符串存储日期类型，占用空间大，损失日期类型函数的便捷性</li>\n<li>timestamp占用4个字节，时间范围：1970-01-01到2038-01-19，精确到秒，采用整形存储，依赖数据库设置的时区，自动更新timestamp列的值</li>\n<li>date占用的字节数比使用字符串、datetime、int存储要少，使用date类型只需要3个字节，可以利用日期时间函数进行日期之间的计算，可用于保存1000-01-01到9999-12-31之间的日期</li>\n</ul>\n</li>\n<li><p>使用枚举代替字符串类型<br> 有时可以使用枚举类代替常用的字符串类型，mysql存储枚举类型会非常紧凑，会根据列表值的数据压缩到一个或两个字节中，mysql在内部会将每个值在列表中的位置保存为整数，并且在表的.frm文件中保存“数字-字符串”映射关系的查找表<br> create table enum_test(e enum(‘fish’,’apple’,’dog’) not null);<br> insert into enum_test(e) values(‘fish’),(‘dog’),(‘apple’);<br> select e+0 from enum_test;</p>\n</li>\n<li><p>特殊类型数据<br> 人们经常使用varchar(15)来存储ip地址，然而，它的本质是32位无符号整数不是字符串，可以使用INET_ATON()和INET_NTOA函数在这两种表示方法之间转换<br> select inet_aton(‘1.1.1.1’)<br> select inet_ntoa(16843009)</p>\n</li>\n</ol>\n\n        <h2 id=\"合理使用范式和反范式\"   >\n          <a href=\"#合理使用范式和反范式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>合理使用范式和反范式</h2>\n      \n        <h3 id=\"什么是三范式\"   >\n          <a href=\"#什么是三范式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>什么是三范式</h3>\n      <p>设计关系型数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。</p>\n<ol>\n<li>第一范式：保证每列的原子性</li>\n<li>第二范式：保证一张表只描述一件事情</li>\n<li>第三范式：保证每列都和主键直接相关</li>\n</ol>\n\n        <h3 id=\"范式优缺点\"   >\n          <a href=\"#范式优缺点\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>范式优缺点</h3>\n      <p>优点：</p>\n<ol>\n<li>范式化的更新通常比反范式要快</li>\n<li>当数据较好的范式化后，很少或者没有重复的数据</li>\n<li>范式化的数据比较小，可以放在内存中，操作比较快<br>缺点：<br>通常需要进行关联</li>\n</ol>\n\n        <h3 id=\"反范式反范式\"   >\n          <a href=\"#反范式反范式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>反范式反范式</h3>\n      <p>优点：</p>\n<ol>\n<li>所有的数据都在同一张表中，可以避免关联</li>\n<li>可以设计有效的索引<br>缺点：<br>表格内的冗余较多，删除数据时候会造成表有些有用的信息丢失</li>\n</ol>\n\n        <h3 id=\"注意\"   >\n          <a href=\"#注意\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>注意</h3>\n      <p>在企业中很好能做到严格意义上的范式或者反范式，一般需要<strong>混合使用</strong><br>例如：<br>在一个网站实例中，这个网站，允许用户发送消息，并且一些用户是付费用户。现在想查看付费用户最近的10条信息。  在user表和message表中都存储用户类型(account_type)而不用完全的反范式化。这避免了完全反范式化的插入和删除问题，因为即使没有消息的时候也绝不会丢失用户的信息。这样也不会把user_message表搞得太大，有利于高效地获取数据。<br>（空间换时间）</p>\n\n        <h2 id=\"主键的选择\"   >\n          <a href=\"#主键的选择\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>主键的选择</h2>\n      <ol>\n<li>代理主键：与业务无关的，无意义的数字序列</li>\n<li>自然主键：事物属性中的自然唯一标识\n        <h3 id=\"推荐使用代理主键\"   >\n          <a href=\"#推荐使用代理主键\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>推荐使用代理主键</h3>\n      原因：</li>\n<li>它们不与业务耦合，因此更容易维护</li>\n<li>一个大多数表，最好是全部表，通用的键策略能够减少需要编写的源码数量，减少系统的总体拥有成本</li>\n</ol>\n\n        <h2 id=\"字符集的选择\"   >\n          <a href=\"#字符集的选择\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>字符集的选择</h2>\n      <ol>\n<li>纯拉丁字符能表示的内容，没必要选择 latin1 之外的其他字符编码，因为这会节省大量的存储空间</li>\n<li>如果我们可以确定不需要存放多种语言，就没必要非得使用UTF8或者其他UNICODE字符类型，这回造成大量的存储空间浪费</li>\n<li>MySQL的数据类型可以精确到字段，所以当我们需要大型数据库中存放多字节数据的时候，可以通过对不同表不同字段使用不同的数据类型来较大程度减小数据存储量，进而降低 IO 操作次数并提高缓存命中率</li>\n</ol>\n\n        <h2 id=\"存储引擎的选择\"   >\n          <a href=\"#存储引擎的选择\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>存储引擎的选择</h2>\n      <p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a8a10160a154a678c99d3.png\"  alt=\"279454170895f4284f38ccb1a7d047d4.png\">\n      </p>\n\n        <h2 id=\"适当的数据冗余\"   >\n          <a href=\"#适当的数据冗余\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>适当的数据冗余</h2>\n      <ol>\n<li>被频繁引用且只能通过 Join 2张(或者更多)大表的方式才能得到的独立小字段。</li>\n<li>这样的场景由于每次Join仅仅只是为了取得某个小字段的值，Join到的记录又大，会造成大量不必要的 IO，完全可以通过空间换取时间的方式来优化。不过，冗余的同时需要确保数据的一致性不会遭到破坏，确保更新的同时冗余字段也被更新\n        <h2 id=\"适当拆分\"   >\n          <a href=\"#适当拆分\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>适当拆分</h2>\n      当我们的表中存在类似于 TEXT 或者是很大的 VARCHAR类型的大字段的时候，如果我们大部分访问这张表的时候都不需要这个字段，我们就该义无反顾的将其拆分到另外的独立表中，以减少常用数据所占用的存储空间。这样做的一个明显好处就是每个数据块中可以存储的数据条数可以大大增加，既减少物理 IO 次数，也能大大提高内存中的缓存命中率。</li>\n</ol>\n","categories":["MySQL"],"tags":["MySQL","MySQL调优"]},{"title":"MySQL性能监控","url":"/2020/09/23/MySQL%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/","content":"\n        <h1 id=\"性能监控\"   >\n          <a href=\"#性能监控\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>性能监控</h1>\n      \n        <h2 id=\"使用show-profile查询剖析工具，可以指定具体的type\"   >\n          <a href=\"#使用show-profile查询剖析工具，可以指定具体的type\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>使用show profile查询剖析工具，可以指定具体的type</h2>\n      <p>此工具默认是禁用的，可以通过服务器变量在绘画级别动态的修改<br>set profiling=1;<br>当设置完成之后，在服务器上执行的所有语句，都会测量其耗费的时间和其他一些查询执行状态变更相关的数据。<br>select * from emp;</p>\n<a id=\"more\"></a>\n\n<p>在mysql的命令行模式下只能显示两位小数的时间，可以使用如下命令查看具体的执行时间<br>show profiles;<br>执行如下命令可以查看详细的每个步骤的时间：show profile for query 1;</p>\n\n        <h3 id=\"type\"   >\n          <a href=\"#type\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>type</h3>\n      <div class=\"table-container\"><table>\n<thead>\n<tr>\n<th>type</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>all：显示所有性能信息</td>\n<td>show profile all for query n</td>\n</tr>\n<tr>\n<td>block io：显示块io操作的次数</td>\n<td>show  profile block io for query n</td>\n</tr>\n<tr>\n<td>context switches：显示上下文切换次数，被动和主动</td>\n<td>show profile context switches for query n</td>\n</tr>\n<tr>\n<td>cpu：显示用户cpu时间、系统cpu时间</td>\n<td>show profile cpu for query n</td>\n</tr>\n<tr>\n<td>IPC：显示发送和接受的消息数量</td>\n<td>show profile ipc for query n</td>\n</tr>\n<tr>\n<td>Memory：暂未实现</td>\n<td></td>\n</tr>\n<tr>\n<td>page faults：显示页错误数量</td>\n<td>show profile page faults for query n</td>\n</tr>\n<tr>\n<td>source：显示源码中的函数名称与位置</td>\n<td>show profile source for query n</td>\n</tr>\n<tr>\n<td>swaps：显示swap的次数</td>\n<td>show profile swaps for query n</td>\n</tr>\n</tbody></table></div>\n\n        <h2 id=\"使用performance-schema来更加容易的监控mysql\"   >\n          <a href=\"#使用performance-schema来更加容易的监控mysql\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>使用performance schema来更加容易的监控mysql</h2>\n      <p>具体请查看文章：MYSQL performance schema详解</p>\n\n        <h2 id=\"使用show-processlist查看连接的线程个数\"   >\n          <a href=\"#使用show-processlist查看连接的线程个数\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>使用show processlist查看连接的线程个数</h2>\n      <p>来观察是否有大量线程处于不正常的状态或者其他不正常的特征。通常使用数据连接池来实控制连接，这个了解即可。</p>\n","categories":["MySQL"],"tags":["MySQL","MySQL调优"]},{"title":"MySQL主从复制","url":"/2020/09/23/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/","content":"\n        <h1 id=\"mysql主从复制原理\"   >\n          <a href=\"#mysql主从复制原理\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>mysql主从复制原理</h1>\n      \n        <h2 id=\"为什么需要主从复制？\"   >\n          <a href=\"#为什么需要主从复制？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>为什么需要主从复制？</h2>\n      <p>1、在业务复杂的系统中，有这么一个情景，有一句sql语句需要锁表，导致暂时不能使用读的服务，那么就很影响运行中的业务，使用主从复制，让主库负责写，从库负责读，这样，即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作。</p>\n<a id=\"more\"></a>\n\n<p>2、做数据的热备</p>\n<p>3、架构的扩展。业务量越来越大，I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的频率，提高单个机器的I/O性能。</p>\n\n        <h2 id=\"1、什么是mysql的主从复制？\"   >\n          <a href=\"#1、什么是mysql的主从复制？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>1、什么是mysql的主从复制？</h2>\n      <p>MySQL 主从复制是指数据可以从一个MySQL数据库服务器主节点复制到一个或多个从节点。MySQL 默认采用异步复制方式，这样从节点不用一直访问主服务器来更新自己的数据，数据的更新可以在远程连接上进行，从节点可以复制主数据库中的所有数据库或者特定的数据库，或者特定的表。</p>\n\n        <h2 id=\"2、mysql复制原理\"   >\n          <a href=\"#2、mysql复制原理\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>2、mysql复制原理</h2>\n      \n        <h3 id=\"原理\"   >\n          <a href=\"#原理\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>原理</h3>\n      <ol>\n<li><p>master服务器将数据的改变记录二进制binlog日志，当master上的数据发生改变时，则将其改变写入二进制日志中；        </p>\n</li>\n<li><p>slave服务器会在一定时间间隔内对master二进制日志进行探测其是否发生改变，如果发生改变，则开始一个I/OThread请求master二进制事件</p>\n</li>\n<li><p>同时主节点为每个I/O线程启动一个dump线程，用于向其发送二进制事件，并保存至从节点本地的中继日志中，从节点将启动SQL线程从中继日志中读取二进制日志，在本地重放，使得其数据和主节点的保持一致，最后I/OThread和SQLThread将进入睡眠状态，等待下一次被唤醒。</p>\n</li>\n</ol>\n\n        <h4 id=\"也就是说\"   >\n          <a href=\"#也就是说\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>也就是说</h4>\n      <ul>\n<li>从库会生成两个线程,一个I/O线程,一个SQL线程;</li>\n<li>I/O线程会去请求主库的binlog,并将得到的binlog写到本地的relay-log(中继日志)文件中;</li>\n<li>主库会生成一个log dump线程,用来给从库I/O线程传binlog;</li>\n<li>SQL线程,会读取relay log文件中的日志,并解析成sql语句逐一执行;</li>\n</ul>\n\n        <h5 id=\"注意\"   >\n          <a href=\"#注意\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>注意</h5>\n      <ol>\n<li>master将操作语句记录到binlog日志中，然后授予slave远程连接的权限（master一定要开启binlog二进制日志功能；通常为了数据安全考虑，slave也开启binlog功能）。</li>\n<li>slave开启两个线程：IO线程和SQL线程。其中：IO线程负责读取master的binlog内容到中继日志relay log里；SQL线程负责从relay log日志里读出binlog内容，并更新到slave的数据库里，这样就能保证slave数据和master数据保持一致了。</li>\n<li>Mysql复制至少需要两个Mysql的服务，当然Mysql服务可以分布在不同的服务器上，也可以在一台服务器上启动多个服务。</li>\n<li>Mysql复制最好确保master和slave服务器上的Mysql版本相同（如果不能满足版本一致，那么要保证master主节点的版本低于slave从节点的版本）</li>\n<li>master和slave两节点间时间需同步</li>\n</ol>\n<p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a8841160a154a678c0fb8.png\"  alt=\"b83fdc37945b65db8b643af641407873.png\">\n      </p>\n\n        <h5 id=\"具体步骤\"   >\n          <a href=\"#具体步骤\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>具体步骤</h5>\n      <p>1、从库通过手工执行change  master to 语句连接主库，提供了连接的用户一切条件（user 、password、port、ip），并且让从库知道，二进制日志的起点位置（file名 position 号）；    start  slave</p>\n<p>2、从库的IO线程和主库的dump线程建立连接。</p>\n<p>3、从库根据change  master  to 语句提供的file名和position号，IO线程向主库发起binlog的请求。</p>\n<p>4、主库dump线程根据从库的请求，将本地binlog以events的方式发给从库IO线程。</p>\n<p>5、从库IO线程接收binlog  events，并存放到本地relay-log中，传送过来的信息，会记录到master.info中</p>\n<p>6、从库SQL线程应用relay-log，并且把应用过的记录到relay-log.info中，默认情况下，已经应用过的relay 会自动被清理purge</p>\n\n        <h2 id=\"3、mysql主从形式\"   >\n          <a href=\"#3、mysql主从形式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>3、mysql主从形式</h2>\n      \n        <h3 id=\"1-一主一从\"   >\n          <a href=\"#1-一主一从\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>1.一主一从</h3>\n      <p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a884e160a154a678c1440.png\"  alt=\"18b866682900dcc3a0d90e23caf28bdb.png\">\n      </p>\n\n        <h3 id=\"2-主主复制\"   >\n          <a href=\"#2-主主复制\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>2.主主复制</h3>\n      <p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a884e160a154a678c1444.png\"  alt=\"449577a99094e7c153a7a98ca0f239bf.png\">\n      </p>\n\n        <h3 id=\"3-一主多从\"   >\n          <a href=\"#3-一主多从\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>3.一主多从</h3>\n      <p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a884e160a154a678c1448.png\"  alt=\"a2d2fa77228e8554c5f684a10f7e9c0b.png\">\n      </p>\n\n        <h3 id=\"4-多主一从\"   >\n          <a href=\"#4-多主一从\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>4.多主一从</h3>\n      <p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a884e160a154a678c144f.png\"  alt=\"4e905b670b6db4c9d09cb0d3007ccda1.png\">\n      </p>\n\n        <h3 id=\"5-联级复制\"   >\n          <a href=\"#5-联级复制\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>5.联级复制</h3>\n      <p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a884e160a154a678c1455.png\"  alt=\"7e90978f03350b203c7a70e11952893f.png\">\n      </p>\n\n        <h2 id=\"4、mysql主从同步延时分析\"   >\n          <a href=\"#4、mysql主从同步延时分析\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>4、mysql主从同步延时分析</h2>\n      <p>mysql的主从复制都是单线程的操作，主库对所有DDL和DML产生的日志写进binlog，由于binlog是<strong>顺序写</strong>，所以效率很高，slave的sql thread线程将主库的DDL和DML操作事件在slave中重放。DML和DDL的IO操作是随机的，不是顺序，所以成本要高很多，另一方面，由于sql thread也是单线程的，当主库的并发较高时，产生的DML数量超过slave的SQL thread所能处理的速度，或者当slave中有大型query语句产生了锁等待，那么延时就产生了。</p>\n\n        <h3 id=\"解决方案\"   >\n          <a href=\"#解决方案\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>解决方案</h3>\n      <ol>\n<li><p>业务的持久化层的实现采用分库架构，mysql服务可平行扩展，分散压力。</p>\n</li>\n<li><p>单个库读写分离，一主多从，主写从读，分散压力。这样从库压力比主库高，保护主库。</p>\n</li>\n<li><p>服务的基础架构在业务和mysql之间加入memcache或者redis的cache层。降低mysql的读压力。</p>\n</li>\n<li><p>不同业务的mysql物理上放在不同机器，分散压力。</p>\n</li>\n<li><p>使用比主库更好的硬件设备作为slave，mysql压力小，延迟自然会变小。</p>\n</li>\n<li><p>使用更加强劲的硬件设备</p>\n</li>\n</ol>\n<p><strong>mysql5.7之后使用MTS并行复制技术，永久解决复制延时问题</strong></p>\n\n        <h1 id=\"mysql主从复制安装配置\"   >\n          <a href=\"#mysql主从复制安装配置\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>mysql主从复制安装配置</h1>\n      \n        <h2 id=\"1、基础设置准备\"   >\n          <a href=\"#1、基础设置准备\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>1、基础设置准备</h2>\n      <figure class=\"highlight shell\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">操作系统：</span></span><br><span class=\"line\">centos6.5</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">mysql版本：</span></span><br><span class=\"line\">5.7</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">两台虚拟机(看自己的地址)：</span></span><br><span class=\"line\">node1:192.168.136.111（主）</span><br><span class=\"line\">node2:192.168.136.112（从）</span><br></pre></td></tr></table></div></figure>\n\n\n        <h2 id=\"2、安装mysql数据库\"   >\n          <a href=\"#2、安装mysql数据库\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>2、安装mysql数据库</h2>\n      <figure class=\"highlight shell\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">详细安装和卸载的步骤参考对应的文档</span></span><br></pre></td></tr></table></div></figure>\n\n\n        <h2 id=\"3、在两台数据库中分别创建数据库\"   >\n          <a href=\"#3、在两台数据库中分别创建数据库\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>3、在两台数据库中分别创建数据库</h2>\n      <figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--注意两台必须全部执行</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">database</span> msb;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h2 id=\"4、在主（node1）服务器进行如下配置\"   >\n          <a href=\"#4、在主（node1）服务器进行如下配置\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>4、在主（node1）服务器进行如下配置</h2>\n      <figure class=\"highlight shell\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">修改配置文件，执行以下命令打开mysql配置文件</span></span><br><span class=\"line\">vi /etc/my.cnf</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">在mysqld模块中添加如下配置信息</span></span><br><span class=\"line\">log-bin=master-bin #二进制文件名称</span><br><span class=\"line\">binlog-format=ROW  #二进制日志格式，有row、statement、mixed三种格式，row指的是把改变的内容复制过去，而不是把命令在从服务器上执行一遍，statement指的是在主服务器上执行的SQL语句，在从服务器上执行同样的语句。MySQL默认采用基于语句的复制，效率比较高。mixed指的是默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制。</span><br><span class=\"line\">server-id=1\t\t   #要求各个服务器的id必须不一样</span><br><span class=\"line\">binlog-do-db=msb   #同步的数据库名称</span><br></pre></td></tr></table></div></figure>\n\n\n        <h2 id=\"5、配置从服务器登录主服务器的账号授权\"   >\n          <a href=\"#5、配置从服务器登录主服务器的账号授权\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>5、配置从服务器登录主服务器的账号授权</h2>\n      <figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--授权操作</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> validate_password_policy=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> validate_password_length=<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">grant</span> <span class=\"keyword\">replication</span> <span class=\"keyword\">slave</span> <span class=\"keyword\">on</span> *.* <span class=\"keyword\">to</span> <span class=\"string\">&#x27;root&#x27;</span>@<span class=\"string\">&#x27;%&#x27;</span> <span class=\"keyword\">identified</span> <span class=\"keyword\">by</span> <span class=\"string\">&#x27;123456&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">--刷新权限</span></span><br><span class=\"line\"><span class=\"keyword\">flush</span> <span class=\"keyword\">privileges</span>;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h2 id=\"6、从服务器的配置\"   >\n          <a href=\"#6、从服务器的配置\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>6、从服务器的配置</h2>\n      <figure class=\"highlight shell\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">修改配置文件，执行以下命令打开mysql配置文件</span></span><br><span class=\"line\">vi /etc/my.cnf</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">在mysqld模块中添加如下配置信息</span></span><br><span class=\"line\">log-bin=master-bin\t#二进制文件的名称</span><br><span class=\"line\">binlog-format=ROW\t#二进制文件的格式</span><br><span class=\"line\">server-id=2\t\t\t#服务器的id</span><br></pre></td></tr></table></div></figure>\n\n\n        <h2 id=\"7、重启主服务器的mysqld服务\"   >\n          <a href=\"#7、重启主服务器的mysqld服务\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>7、重启主服务器的mysqld服务</h2>\n      <figure class=\"highlight shell\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">重启mysql服务</span></span><br><span class=\"line\">service mysqld restart</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">登录mysql数据库</span></span><br><span class=\"line\">mysql -uroot -p</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">查看master的状态</span></span><br><span class=\"line\">show master status；</span><br></pre></td></tr></table></div></figure>\n\n<p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a8882160a154a678c254a.png\"  alt=\"3f4365dde81aa4f011fd944d43591423.png\">\n      </p>\n\n        <h2 id=\"8、重启从服务器并进行相关配置\"   >\n          <a href=\"#8、重启从服务器并进行相关配置\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>8、重启从服务器并进行相关配置</h2>\n      <figure class=\"highlight shell\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">重启mysql服务</span></span><br><span class=\"line\">service mysqld restart</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">登录mysql</span></span><br><span class=\"line\">mysql -uroot -p</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">连接主服务器</span></span><br><span class=\"line\">change master to master_host=&#x27;192.168.136.111&#x27;,master_user=&#x27;root&#x27;,master_password=&#x27;123456&#x27;,master_port=3306,master_log_file=&#x27;master-bin.000001&#x27;,master_log_pos=1034;</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">启动slave</span></span><br><span class=\"line\">start slave</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">查看slave的状态</span></span><br><span class=\"line\">show slave status\\G(注意没有分号)</span><br></pre></td></tr></table></div></figure>\n<p>master_log_pos要与主一致</p>\n\n        <h2 id=\"9、此时可以在主服务器进行相关的数据添加删除工作，在从服务器看相关的状态\"   >\n          <a href=\"#9、此时可以在主服务器进行相关的数据添加删除工作，在从服务器看相关的状态\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>9、此时可以在主服务器进行相关的数据添加删除工作，在从服务器看相关的状态</h2>\n      ","categories":["MySQL"],"tags":["MySQL"]},{"title":"MySQL的锁机制","url":"/2020/09/23/MySQL%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/","content":"\n        <h1 id=\"MySQL的锁机制\"   >\n          <a href=\"#MySQL的锁机制\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>MySQL的锁机制</h1>\n      \n        <h2 id=\"1、MySQL锁的基本介绍\"   >\n          <a href=\"#1、MySQL锁的基本介绍\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>1、MySQL锁的基本介绍</h2>\n      <p><strong>锁是计算机协调多个进程或线程并发访问某一资源的机制。</strong> 在数据库中，除传统的 计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一 个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p>\n<a id=\"more\"></a>\n\n<p>相对其他数据库而言，MySQL的锁机制比较简单，其最 显著的特点是不同的<strong>存储引擎</strong>支持不同的锁机制。比如，MyISAM和MEMORY存储引擎采用的是表级锁（table-level locking）；InnoDB存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。 </p>\n<p><strong>表级锁：</strong> 开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。<br><strong>行级锁：</strong> 开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。  </p>\n<p>从上述特点可见，很难笼统地说哪种锁更好，只能就具体应用的特点来说哪种锁更合适！仅从锁的角度 来说：表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有 并发查询的应用，如一些在线事务处理（OLTP）系统。 </p>\n\n        <h2 id=\"2、MyISAM表锁\"   >\n          <a href=\"#2、MyISAM表锁\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>2、MyISAM表锁</h2>\n      <p>MySQL的表级锁有两种模式：</p>\n<ol>\n<li><strong>表读共享锁（Table Read Lock）</strong><br> 一个session使用lock table给表加读锁，这个session可以锁定表中的记录，更新和访问其他表都会提示错误，同时，另一个session可以查询表中的记录，但更新就会出现锁等待</li>\n<li><strong>表写独占锁（Table Write Lock）</strong><br> 当一个线程获得对一个表的写锁之后，只有持有锁的线程可以对表进行更新操作。其他线程的读写操作都会等待，直到锁释放为止。</li>\n</ol>\n<p>对MyISAM表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；对 MyISAM表的写操作，则会阻塞其他用户对同一表的读和写操作；MyISAM表的读操作与写操作之间，以及写操作之间是串行的！ </p>\n<p>建表语句：</p>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`mylock`</span> (</span><br><span class=\"line\">  <span class=\"string\">`id`</span> <span class=\"built_in\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> AUTO_INCREMENT,</span><br><span class=\"line\">  <span class=\"string\">`NAME`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">20</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"string\">`id`</span>)</span><br><span class=\"line\">) <span class=\"keyword\">ENGINE</span>=MyISAM <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"string\">`mylock`</span> (<span class=\"string\">`id`</span>, <span class=\"string\">`NAME`</span>) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;1&#x27;</span>, <span class=\"string\">&#x27;a&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"string\">`mylock`</span> (<span class=\"string\">`id`</span>, <span class=\"string\">`NAME`</span>) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;2&#x27;</span>, <span class=\"string\">&#x27;b&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"string\">`mylock`</span> (<span class=\"string\">`id`</span>, <span class=\"string\">`NAME`</span>) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;3&#x27;</span>, <span class=\"string\">&#x27;c&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"string\">`mylock`</span> (<span class=\"string\">`id`</span>, <span class=\"string\">`NAME`</span>) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;4&#x27;</span>, <span class=\"string\">&#x27;d&#x27;</span>);</span><br></pre></td></tr></table></div></figure>\n\n\n\n        <h3 id=\"MyISAM写锁阻塞读案例\"   >\n          <a href=\"#MyISAM写锁阻塞读案例\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>MyISAM写锁阻塞读案例</h3>\n      <p>当一个线程获得对一个表的写锁之后，只有持有锁的线程可以对表进行更新操作。其他线程的读写操作都会等待，直到锁释放为止。</p>\n<div class=\"table-container\"><table>\n<thead>\n<tr>\n<th align=\"center\">session1</th>\n<th align=\"center\">session2</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">获取表的write锁定<br />lock table mylock write;</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">当前session对表的查询，插入，更新操作都可以执行<br />select * from mylock;<br />insert into mylock values(5,’e’);</td>\n<td align=\"center\">当前session对表的查询会被阻塞<br />select * from mylock；</td>\n</tr>\n<tr>\n<td align=\"center\">释放锁：<br />unlock tables；</td>\n<td align=\"center\">当前session能够立刻执行，并返回对应结果</td>\n</tr>\n</tbody></table></div>\n\n        <h3 id=\"MyISAM读锁阻塞写案例\"   >\n          <a href=\"#MyISAM读锁阻塞写案例\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>MyISAM读锁阻塞写案例</h3>\n      <p>一个session使用lock table给表加读锁，这个session可以锁定表中的记录，更新和访问其他表都会提示错误，同时，另一个session可以查询表中的记录，但更新就会出现锁等待。</p>\n<div class=\"table-container\"><table>\n<thead>\n<tr>\n<th align=\"center\">session1</th>\n<th align=\"center\">session2</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">获得表的read锁定<br />lock table mylock read;</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">当前session可以查询该表记录：<br />select * from mylock;</td>\n<td align=\"center\">当前session可以查询该表记录：<br />select * from mylock;</td>\n</tr>\n<tr>\n<td align=\"center\">当前session不能查询没有锁定的表<br />select * from person<br />Table ‘person’ was not locked with LOCK TABLES</td>\n<td align=\"center\">当前session可以查询或者更新未锁定的表<br />select * from mylock<br />insert into person values(1,’zhangsan’);</td>\n</tr>\n<tr>\n<td align=\"center\">当前session插入或者更新表会提示错误<br />insert into mylock values(6,’f’)<br />Table ‘mylock’ was locked with a READ lock and can’t be updated<br />update mylock set name=’aa’ where id = 1;<br />Table ‘mylock’ was locked with a READ lock and can’t be updated</td>\n<td align=\"center\">当前session插入数据会等待获得锁<br />insert into mylock values(6,’f’);</td>\n</tr>\n<tr>\n<td align=\"center\">释放锁<br />unlock tables;</td>\n<td align=\"center\">获得锁，更新成功</td>\n</tr>\n</tbody></table></div>\n\n        <h3 id=\"注意\"   >\n          <a href=\"#注意\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>注意</h3>\n      <p><strong>MyISAM在执行查询语句之前，会自动给涉及的所有表加读锁，在执行更新操作前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此用户一般不需要使用命令来显式加锁，上例中的加锁时为了演示效果。</strong></p>\n\n        <h3 id=\"MyISAM的并发插入问题\"   >\n          <a href=\"#MyISAM的并发插入问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>MyISAM的并发插入问题</h3>\n      <p>MyISAM表的读和写是串行的，这是就总体而言的，在一定条件下，MyISAM也支持查询和插入操作的并发执行</p>\n<div class=\"table-container\"><table>\n<thead>\n<tr>\n<th align=\"center\">session1</th>\n<th align=\"center\">session2</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">获取表的read local锁定<br />lock table mylock read local</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">当前session不能对表进行更新或者插入操作<br />insert into mylock values(6,’f’)<br />Table ‘mylock’ was locked with a READ lock and can’t be updated<br />update mylock set name=’aa’ where id = 1;<br />Table ‘mylock’ was locked with a READ lock and can’t be updated</td>\n<td align=\"center\">其他session可以查询该表的记录<br />select* from mylock</td>\n</tr>\n<tr>\n<td align=\"center\">当前session不能查询没有锁定的表<br />select * from person<br />Table ‘person’ was not locked with LOCK TABLES</td>\n<td align=\"center\">其他session可以进行插入操作，但是更新会阻塞<br />update mylock set name = ‘aa’ where id = 1;</td>\n</tr>\n<tr>\n<td align=\"center\">当前session不能访问其他session插入的记录；</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">释放锁资源：unlock tables</td>\n<td align=\"center\">当前session获取锁，更新操作完成</td>\n</tr>\n<tr>\n<td align=\"center\">当前session可以查看其他session插入的记录</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table></div>\n<p> 可以通过检查table_locks_waited和table_locks_immediate状态变量来分析系统上的表锁定争夺： </p>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; show status like &#x27;table%&#x27;;</span><br><span class=\"line\">+<span class=\"comment\">-----------------------+-------+</span></span><br><span class=\"line\">| Variable_name         | Value |</span><br><span class=\"line\">+<span class=\"comment\">-----------------------+-------+</span></span><br><span class=\"line\">| Table_locks_immediate | 352   |</span><br><span class=\"line\">| Table_locks_waited    | 2     |</span><br><span class=\"line\">+<span class=\"comment\">-----------------------+-------+</span></span><br><span class=\"line\"><span class=\"comment\">--如果Table_locks_waited的值比较高，则说明存在着较严重的表级锁争用情况。</span></span><br></pre></td></tr></table></div></figure>\n\n\n        <h2 id=\"InnoDB锁\"   >\n          <a href=\"#InnoDB锁\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>InnoDB锁</h2>\n      \n        <h3 id=\"1、事务及其ACID属性\"   >\n          <a href=\"#1、事务及其ACID属性\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>1、事务及其ACID属性</h3>\n      <p>事务是由一组SQL语句组成的逻辑处理单元，事务具有4属性，通常称为事务的ACID属性。</p>\n<ol>\n<li>原子性（Actomicity）：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。(UndoLog实现)</li>\n<li>一致性（Consistent）：在事务开始和完成时，数据都必须保持一致状态。（一致性是最重要的，通过其他三个实现）</li>\n<li>隔离性（Isolation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。(锁机制实现)</li>\n<li>持久性（Durable）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。（RedoLog实现）</li>\n</ol>\n\n        <h3 id=\"2、并发事务带来的问题\"   >\n          <a href=\"#2、并发事务带来的问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>2、并发事务带来的问题</h3>\n      <p>相对于串行处理来说，并发事务处理能大大增加数据库资源的利用率，提高数据库系统的事务吞吐量，从而可以支持更多用户的并发操作，但与此同时，会带来一下问题：</p>\n<ol>\n<li><p><strong>脏读</strong>：<br>  一个事务正在对一条记录做修改，在这个事务并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做“脏读” </p>\n</li>\n<li><p><strong>不可重复读</strong>：</p>\n<pre><code> 一个事务在读取某些数据已经发生了改变、或某些记录已经被删除了！这种现象叫做“不可重复读”。 </code></pre>\n</li>\n<li><p><strong>幻读</strong>：<br>  一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读” </p>\n</li>\n</ol>\n<p>上述出现的问题都是数据库读一致性的问题，可以通过事务的隔离机制来进行保证。</p>\n<p>数据库的事务隔离越严格，并发副作用就越小，但付出的代价也就越大，因为事务隔离本质上就是使事务在一定程度上串行化，需要根据具体的业务需求来决定使用哪种隔离级别</p>\n<div class=\"table-container\"><table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">脏读</th>\n<th align=\"center\">不可重复读</th>\n<th align=\"center\">幻读</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">读未提交 read uncommitted</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n</tr>\n<tr>\n<td align=\"center\">读已提交 read committed</td>\n<td align=\"center\"></td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n</tr>\n<tr>\n<td align=\"center\">可重复读 repeatable read</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">√</td>\n</tr>\n<tr>\n<td align=\"center\">序列化 serializable</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table></div>\n<p><strong>MySQL默认的数据库隔离级别是可重复读</strong></p>\n<p> 可以通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况： </p>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; show status like &#x27;innodb_row_lock%&#x27;;</span><br><span class=\"line\">+<span class=\"comment\">-------------------------------+-------+</span></span><br><span class=\"line\">| Variable_name                 | Value |</span><br><span class=\"line\">+<span class=\"comment\">-------------------------------+-------+</span></span><br><span class=\"line\">| Innodb_row_lock_current_waits | 0     |</span><br><span class=\"line\">| Innodb_row_lock_time          | 18702 |</span><br><span class=\"line\">| Innodb_row_lock_time_avg      | 18702 |</span><br><span class=\"line\">| Innodb_row_lock_time_max      | 18702 |</span><br><span class=\"line\">| Innodb_row_lock_waits         | 1     |</span><br><span class=\"line\">+<span class=\"comment\">-------------------------------+-------+</span></span><br><span class=\"line\"><span class=\"comment\">--如果发现锁争用比较严重，如InnoDB_row_lock_waits和InnoDB_row_lock_time_avg的值比较高</span></span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"3、InnoDB的行锁模式及加锁方法\"   >\n          <a href=\"#3、InnoDB的行锁模式及加锁方法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>3、InnoDB的行锁模式及加锁方法</h3>\n      <p><strong>共享锁（s）</strong>：又称读锁。允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。<br><strong>排他锁（x）</strong>：又称写锁。允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。</p>\n<p>mysql InnoDB引擎默认的修改数据语句：<strong>update,delete,insert都会自动给涉及到的数据加上排他锁，select语句默认不会加任何锁类型</strong>，如果加排他锁可以使用select …for update语句，加共享锁可以使用select … lock in share mode语句。<strong>所以加过排他锁的数据行在其他事务种是不能修改数据的，也不能通过for update和lock in share mode锁的方式查询数据，但可以直接通过select …from…查询数据，因为普通查询没有任何锁机制。</strong> </p>\n<p><strong>InnoDB行锁实现方式</strong></p>\n<p>InnoDB行锁是通过给<strong>索引</strong>上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，<strong>否则，InnoDB将使用表锁！</strong>  </p>\n<p>1、在不通过索引条件查询的时候，innodb使用的是表锁而不是行锁</p>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> tab_no_index(<span class=\"keyword\">id</span> <span class=\"built_in\">int</span>,<span class=\"keyword\">name</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">10</span>)) <span class=\"keyword\">engine</span>=<span class=\"keyword\">innodb</span>;</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> tab_no_index <span class=\"keyword\">values</span>(<span class=\"number\">1</span>,<span class=\"string\">&#x27;1&#x27;</span>),(<span class=\"number\">2</span>,<span class=\"string\">&#x27;2&#x27;</span>),(<span class=\"number\">3</span>,<span class=\"string\">&#x27;3&#x27;</span>),(<span class=\"number\">4</span>,<span class=\"string\">&#x27;4&#x27;</span>);</span><br></pre></td></tr></table></div></figure>\n\n<div class=\"table-container\"><table>\n<thead>\n<tr>\n<th align=\"center\">session1</th>\n<th align=\"center\">session2</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">set autocommit=0<br />select * from tab_no_index where id = 1;</td>\n<td align=\"center\">set autocommit=0<br />select * from tab_no_index where id =2</td>\n</tr>\n<tr>\n<td align=\"center\">select * from tab_no_index where id = 1 for update</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\">select * from tab_no_index where id = 2 for update;</td>\n</tr>\n</tbody></table></div>\n<p>session1只给一行加了排他锁，但是session2在请求其他行的排他锁的时候，会出现锁等待。原因是在没有索引的情况下，innodb只能使用表锁。</p>\n<p>2、创建带索引的表进行条件查询，innodb使用的是行锁</p>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> tab_with_index(<span class=\"keyword\">id</span> <span class=\"built_in\">int</span>,<span class=\"keyword\">name</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">10</span>)) <span class=\"keyword\">engine</span>=<span class=\"keyword\">innodb</span>;</span><br><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> tab_with_index <span class=\"keyword\">add</span> <span class=\"keyword\">index</span> <span class=\"keyword\">id</span>(<span class=\"keyword\">id</span>);</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> tab_with_index <span class=\"keyword\">values</span>(<span class=\"number\">1</span>,<span class=\"string\">&#x27;1&#x27;</span>),(<span class=\"number\">2</span>,<span class=\"string\">&#x27;2&#x27;</span>),(<span class=\"number\">3</span>,<span class=\"string\">&#x27;3&#x27;</span>),(<span class=\"number\">4</span>,<span class=\"string\">&#x27;4&#x27;</span>);</span><br></pre></td></tr></table></div></figure>\n\n<div class=\"table-container\"><table>\n<thead>\n<tr>\n<th align=\"center\">session1</th>\n<th align=\"center\">session2</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">set autocommit=0<br />select * from tab_with_indexwhere id = 1;</td>\n<td align=\"center\">set autocommit=0<br />select * from tab_with_indexwhere id =2</td>\n</tr>\n<tr>\n<td align=\"center\">select * from tab_with_indexwhere id = 1 for update</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\">select * from tab_with_indexwhere id = 2 for update;</td>\n</tr>\n</tbody></table></div>\n<p>3、由于mysql的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现冲突的。</p>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> tab_with_index <span class=\"keyword\">drop</span> <span class=\"keyword\">index</span> <span class=\"keyword\">id</span>;</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> tab_with_index  <span class=\"keyword\">values</span>(<span class=\"number\">1</span>,<span class=\"string\">&#x27;4&#x27;</span>);</span><br></pre></td></tr></table></div></figure>\n\n<div class=\"table-container\"><table>\n<thead>\n<tr>\n<th align=\"center\">session1</th>\n<th align=\"center\">session2</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">set autocommit=0</td>\n<td align=\"center\">set autocommit=0</td>\n</tr>\n<tr>\n<td align=\"center\">select * from tab_with_index where id = 1 and name=’1’ for update</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\">select * from tab_with_index where id = 1 and name=’4’ for update<br />虽然session2访问的是和session1不同的记录，但是锁的是具体的表，所以需要等待锁</td>\n</tr>\n</tbody></table></div>\n\n        <h2 id=\"总结\"   >\n          <a href=\"#总结\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>总结</h2>\n      <p><strong>对于MyISAM的表锁：</strong><br>（1）共享读锁（S）之间是兼容的，但共享读锁（S）与排他写锁（X）之间，以及排他写锁（X）之间是互斥的，也就是说读和写是串行的。<br>（2）在一定条件下，MyISAM允许查询和插入并发执行，我们可以利用这一点来解决应用中对同一表查询和插入的锁争用问题。<br>（3）MyISAM默认的锁调度机制是写优先，这并不一定适合所有应用，用户可以通过设置LOW_PRIORITY_UPDATES参数，或在INSERT、UPDATE、DELETE语句中指定LOW_PRIORITY选项来调节读写锁的争用。<br>（4）由于表锁的锁定粒度大，读写之间又是串行的，因此，如果更新操作较多，MyISAM表可能会出现严重的锁等待，可以考虑采用InnoDB表来减少锁冲突。</p>\n<p><strong>对于InnoDB表锁：</strong><br>（1）InnoDB的行锁是基于索引实现的，如果不通过索引访问数据，InnoDB会使用表锁。<br>（2）在不同的隔离级别下，InnoDB的锁机制和一致性读策略不同。</p>\n<p>在了解InnoDB锁特性后，用户可以通过设计和SQL调整等措施减少锁冲突和死锁，包括：</p>\n<ul>\n<li>尽量使用较低的隔离级别； 精心设计索引，并尽量使用索引访问数据，使加锁更精确，从而减少锁冲突的机会；</li>\n<li>选择合理的事务大小，小事务发生锁冲突的几率也更小；</li>\n<li>给记录集显式加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁；</li>\n<li>不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会；</li>\n<li>尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响； 不要申请超过实际需要的锁级别；除非必须，查询时不要显示加锁；</li>\n<li>对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能。</li>\n</ul>\n\n        <h2 id=\"名词解释\"   >\n          <a href=\"#名词解释\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>名词解释</h2>\n      \n        <h3 id=\"意向共享锁-IS锁\"   >\n          <a href=\"#意向共享锁-IS锁\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>意向共享锁 IS锁</h3>\n      <p>表示事物准备给数据行加入共享锁，也就是说一个数据行在加共享锁之前必须先取得意向共享锁</p>\n\n        <h3 id=\"意向排他锁-IX锁\"   >\n          <a href=\"#意向排他锁-IX锁\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>意向排他锁 IX锁</h3>\n      <p>表示事物准备给数据行加入排他锁，也就是说一个数据行在加排他锁之前必须先取得意向排他锁</p>\n<p><strong>意向锁是InnoDB数据操作之前自动加的。不需要用户干预</strong></p>\n\n        <h3 id=\"自增锁\"   >\n          <a href=\"#自增锁\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>自增锁</h3>\n      <p>针对自增列自增长的一个特殊的表级别锁<br>SHOW VARIABLES LIKE ‘innodb_autoinc_lock_mode’;<br>默认值1，代表连续，事物未提交则id永久丢失</p>\n","categories":["MySQL"],"tags":["MySQL"]},{"title":"MySQL执行计划","url":"/2020/09/23/MySQL%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/","content":"\n        <h1 id=\"MySQL执行计划\"   >\n          <a href=\"#MySQL执行计划\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>MySQL执行计划</h1>\n      <p>  在企业的应用场景中，为了知道优化SQL语句的执行，需要查看SQL语句的具体执行过程，以加快SQL语句的执行效率。</p>\n<p>  可以使用explain+SQL语句来模拟优化器执行SQL查询语句，从而知道mysql是如何处理sql语句的。</p>\n<p> 官网地址： <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://dev.mysql.com/doc/refman/5.5/en/explain-output.html\" >https://dev.mysql.com/doc/refman/5.5/en/explain-output.html</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span> </p>\n<a id=\"more\"></a>\n\n\n        <h2 id=\"执行计划中包含的信息\"   >\n          <a href=\"#执行计划中包含的信息\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>执行计划中包含的信息</h2>\n      <div class=\"table-container\"><table>\n<thead>\n<tr>\n<th align=\"center\">Column</th>\n<th align=\"center\">Meaning</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">id</td>\n<td align=\"center\">The <code>SELECT</code> identifier</td>\n</tr>\n<tr>\n<td align=\"center\">select_type</td>\n<td align=\"center\">The <code>SELECT</code> type</td>\n</tr>\n<tr>\n<td align=\"center\">table</td>\n<td align=\"center\">The table for the output row</td>\n</tr>\n<tr>\n<td align=\"center\">partitions</td>\n<td align=\"center\">The matching partitions</td>\n</tr>\n<tr>\n<td align=\"center\">type</td>\n<td align=\"center\">The join type</td>\n</tr>\n<tr>\n<td align=\"center\">possible_keys</td>\n<td align=\"center\">The possible indexes to choose</td>\n</tr>\n<tr>\n<td align=\"center\">key</td>\n<td align=\"center\">The index actually chosen</td>\n</tr>\n<tr>\n<td align=\"center\">key_len</td>\n<td align=\"center\">The length of the chosen key</td>\n</tr>\n<tr>\n<td align=\"center\">ref</td>\n<td align=\"center\">The columns compared to the index</td>\n</tr>\n<tr>\n<td align=\"center\">rows</td>\n<td align=\"center\">Estimate of rows to be examined</td>\n</tr>\n<tr>\n<td align=\"center\">filtered</td>\n<td align=\"center\">Percentage of rows filtered by table condition</td>\n</tr>\n<tr>\n<td align=\"center\">extra</td>\n<td align=\"center\">Additional information</td>\n</tr>\n</tbody></table></div>\n\n        <h3 id=\"id\"   >\n          <a href=\"#id\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>id</h3>\n      <p>select查询的序列号，包含一组数字，表示查询中执行select子句或者操作表的顺序</p>\n<p>id号分为三种情况：</p>\n<p>1、如果id相同，那么执行顺序从上到下</p>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">explain</span> <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> emp e <span class=\"keyword\">join</span> dept d <span class=\"keyword\">on</span> e.deptno = d.deptno <span class=\"keyword\">join</span> salgrade sg <span class=\"keyword\">on</span> e.sal <span class=\"keyword\">between</span> sg.losal <span class=\"keyword\">and</span> sg.hisal;</span><br></pre></td></tr></table></div></figure>\n\n<p>2、如果id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</p>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">explain</span> <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> emp e <span class=\"keyword\">where</span> e.deptno <span class=\"keyword\">in</span> (<span class=\"keyword\">select</span> d.deptno <span class=\"keyword\">from</span> dept d <span class=\"keyword\">where</span> d.dname = <span class=\"string\">&#x27;SALES&#x27;</span>);</span><br></pre></td></tr></table></div></figure>\n\n<p>3、id相同和不同的，同时存在：相同的可以认为是一组，从上往下顺序执行，在所有组中，id值越大，优先级越高，越先执行</p>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">explain</span> <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> emp e <span class=\"keyword\">join</span> dept d <span class=\"keyword\">on</span> e.deptno = d.deptno <span class=\"keyword\">join</span> salgrade sg <span class=\"keyword\">on</span> e.sal <span class=\"keyword\">between</span> sg.losal <span class=\"keyword\">and</span> sg.hisal <span class=\"keyword\">where</span> e.deptno <span class=\"keyword\">in</span> (<span class=\"keyword\">select</span> d.deptno <span class=\"keyword\">from</span> dept d <span class=\"keyword\">where</span> d.dname = <span class=\"string\">&#x27;SALES&#x27;</span>);</span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"select-type\"   >\n          <a href=\"#select-type\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>select_type</h3>\n      <p>主要用来分辨查询的类型，是普通查询还是联合查询还是子查询</p>\n<div class=\"table-container\"><table>\n<thead>\n<tr>\n<th align=\"center\"><code>select_type</code> Value</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>SIMPLE</code></td>\n<td align=\"center\">简单查询，没有使用UNION和子查询</td>\n</tr>\n<tr>\n<td align=\"center\"><code>PRIMARY </code></td>\n<td align=\"center\">查询中若包含任何复杂的子查询，最外层查询则被标记为Primary</td>\n</tr>\n<tr>\n<td align=\"center\"><code>UNION</code></td>\n<td align=\"center\">若第二个select出现在union之后，则被标记为union</td>\n</tr>\n<tr>\n<td align=\"center\"><code>DEPENDENT UNION</code></td>\n<td align=\"center\">跟union类似，此处的depentent表示union或union all联合而成的结果会受外部表影响</td>\n</tr>\n<tr>\n<td align=\"center\">UNION RESULT</td>\n<td align=\"center\">从union表获取结果的select</td>\n</tr>\n<tr>\n<td align=\"center\"><code>SUBQUERY</code></td>\n<td align=\"center\">在select或者where列表中包含子查询</td>\n</tr>\n<tr>\n<td align=\"center\"><code>DEPENDENT SUBQUERY</code></td>\n<td align=\"center\">subquery的子查询要受到外部表查询的影响</td>\n</tr>\n<tr>\n<td align=\"center\"><code>DERIVED</code></td>\n<td align=\"center\">from子句中出现的子查询，也叫做派生类、衍生表、虚拟表</td>\n</tr>\n<tr>\n<td align=\"center\">UNCACHEABLE SUBQUERY</td>\n<td align=\"center\">表示使用子查询的结果不能被缓存</td>\n</tr>\n<tr>\n<td align=\"center\">UNCACHEABLE UNION</td>\n<td align=\"center\">表示union的查询结果不能被缓存：sql语句未验证</td>\n</tr>\n</tbody></table></div>\n\n        <h4 id=\"DEPENDENT-SUBQUERY和-SUBQUERY-的区别\"   >\n          <a href=\"#DEPENDENT-SUBQUERY和-SUBQUERY-的区别\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>DEPENDENT SUBQUERY和 SUBQUERY 的区别</h4>\n      <p>简单来说，SUBQUERY是子查询是等于一个值，DEPENDENT SUBQUERY是多个值（ = 和 in，值和集合的区别）</p>\n\n        <h4 id=\"sql举例\"   >\n          <a href=\"#sql举例\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>sql举例</h4>\n      <figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--sample:简单的查询，不包含子查询和union</span></span><br><span class=\"line\"><span class=\"keyword\">explain</span> <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> emp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--primary:查询中若包含任何复杂的子查询，最外层查询则被标记为Primary</span></span><br><span class=\"line\"><span class=\"keyword\">explain</span> <span class=\"keyword\">select</span> staname,ename supname <span class=\"keyword\">from</span> (<span class=\"keyword\">select</span> ename staname,mgr <span class=\"keyword\">from</span> emp) t <span class=\"keyword\">join</span> emp <span class=\"keyword\">on</span> t.mgr=emp.empno ;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--union:若第二个select出现在union之后，则被标记为union</span></span><br><span class=\"line\"><span class=\"keyword\">explain</span> <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> emp <span class=\"keyword\">where</span> deptno = <span class=\"number\">10</span> <span class=\"keyword\">union</span> <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> emp <span class=\"keyword\">where</span> sal &gt;<span class=\"number\">2000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--dependent union:跟union类似，此处的depentent表示union或union all联合而成的结果会受外部表影响</span></span><br><span class=\"line\"><span class=\"keyword\">explain</span> <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> emp e <span class=\"keyword\">where</span> e.empno  <span class=\"keyword\">in</span> ( <span class=\"keyword\">select</span> empno <span class=\"keyword\">from</span> emp <span class=\"keyword\">where</span> deptno = <span class=\"number\">10</span> <span class=\"keyword\">union</span> <span class=\"keyword\">select</span> empno <span class=\"keyword\">from</span> emp <span class=\"keyword\">where</span> sal &gt;<span class=\"number\">2000</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--union result:从union表获取结果的select</span></span><br><span class=\"line\"><span class=\"keyword\">explain</span> <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> emp <span class=\"keyword\">where</span> deptno = <span class=\"number\">10</span> <span class=\"keyword\">union</span> <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> emp <span class=\"keyword\">where</span> sal &gt;<span class=\"number\">2000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--subquery:在select或者where列表中包含子查询</span></span><br><span class=\"line\"><span class=\"keyword\">explain</span> <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> emp <span class=\"keyword\">where</span> sal &gt; (<span class=\"keyword\">select</span> <span class=\"keyword\">avg</span>(sal) <span class=\"keyword\">from</span> emp) ;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--dependent subquery:subquery的子查询要受到外部表查询的影响</span></span><br><span class=\"line\"><span class=\"keyword\">explain</span> <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> emp e <span class=\"keyword\">where</span> e.deptno <span class=\"keyword\">in</span> (<span class=\"keyword\">select</span> <span class=\"keyword\">distinct</span> deptno <span class=\"keyword\">from</span> dept);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--DERIVED: from子句中出现的子查询，也叫做派生类，</span></span><br><span class=\"line\"><span class=\"keyword\">explain</span> <span class=\"keyword\">select</span> staname,ename supname <span class=\"keyword\">from</span> (<span class=\"keyword\">select</span> ename staname,mgr <span class=\"keyword\">from</span> emp) t <span class=\"keyword\">join</span> emp <span class=\"keyword\">on</span> t.mgr=emp.empno ;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--UNCACHEABLE SUBQUERY：表示使用子查询的结果不能被缓存</span></span><br><span class=\"line\"> <span class=\"keyword\">explain</span> <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> emp <span class=\"keyword\">where</span> empno = (<span class=\"keyword\">select</span> empno <span class=\"keyword\">from</span> emp <span class=\"keyword\">where</span> deptno=@@sort_buffer_size);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">--uncacheable union:表示union的查询结果不能被缓存：sql语句未验证</span></span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"table\"   >\n          <a href=\"#table\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>table</h3>\n      <p>对应行正在访问哪一个表，表名或者别名，可能是临时表或者union合并结果集</p>\n<ol>\n<li>如果是具体的表名，则表明从实际的物理表中获取数据，当然也可以是表的别名</li>\n<li>表名是<derivedN>的形式，表示使用了id为N的查询产生的衍生表</li>\n<li>当有union result的时候，表名是&lt;union n1,n2&gt;等的形式，n1,n2表示参与union的id</li>\n</ol>\n\n        <h3 id=\"type\"   >\n          <a href=\"#type\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>type</h3>\n      <p>type显示的是访问类型，访问类型表示我是以何种方式去访问我们的数据，最容易想的是全表扫描，直接暴力的遍历一张表去寻找需要的数据，效率非常低下，访问的类型有很多，效率从最好到最坏依次是：</p>\n<p>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL </p>\n<p>一般情况下，得保证查询至少达到range级别，最好能达到ref</p>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--all:全表扫描，一般情况下出现这样的sql语句而且数据量比较大的话那么就需要进行优化。</span></span><br><span class=\"line\"><span class=\"keyword\">explain</span> <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> emp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--index：全索引扫描这个比all的效率要好，主要有两种情况，一种是当前的查询时覆盖索引，即我们需要的数据在索引中就可以索取，或者是使用了索引进行排序，这样就避免数据的重排序</span></span><br><span class=\"line\"><span class=\"keyword\">explain</span>  <span class=\"keyword\">select</span> empno <span class=\"keyword\">from</span> emp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--range：表示利用索引查询的时候限制了范围，在指定范围内进行查询，这样避免了index的全索引扫描，适用的操作符： =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, BETWEEN, LIKE, or IN() </span></span><br><span class=\"line\"><span class=\"keyword\">explain</span> <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> emp <span class=\"keyword\">where</span> empno <span class=\"keyword\">between</span> <span class=\"number\">7000</span> <span class=\"keyword\">and</span> <span class=\"number\">7500</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--index_subquery：利用索引来关联子查询，不再扫描全表</span></span><br><span class=\"line\"><span class=\"keyword\">explain</span> <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> emp <span class=\"keyword\">where</span> emp.job <span class=\"keyword\">in</span> (<span class=\"keyword\">select</span> job <span class=\"keyword\">from</span> t_job);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--unique_subquery:该连接类型类似与index_subquery,使用的是唯一索引</span></span><br><span class=\"line\"> <span class=\"keyword\">explain</span> <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> emp e <span class=\"keyword\">where</span> e.deptno <span class=\"keyword\">in</span> (<span class=\"keyword\">select</span> <span class=\"keyword\">distinct</span> deptno <span class=\"keyword\">from</span> dept);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">--index_merge：在查询过程中需要多个索引组合使用，没有模拟出来</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--ref_or_null：对于某个字段即需要关联条件，也需要null值的情况下，查询优化器会选择这种访问方式</span></span><br><span class=\"line\"><span class=\"keyword\">explain</span> <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> emp e <span class=\"keyword\">where</span>  e.mgr <span class=\"keyword\">is</span> <span class=\"literal\">null</span> <span class=\"keyword\">or</span> e.mgr=<span class=\"number\">7369</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--ref：使用了非唯一性索引进行数据的查找</span></span><br><span class=\"line\"> <span class=\"keyword\">create</span> <span class=\"keyword\">index</span> idx_3 <span class=\"keyword\">on</span> emp(deptno);</span><br><span class=\"line\"> <span class=\"keyword\">explain</span> <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> emp e,dept d <span class=\"keyword\">where</span> e.deptno =d.deptno;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--eq_ref ：使用唯一性索引进行数据查找</span></span><br><span class=\"line\"><span class=\"keyword\">explain</span> <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> emp,emp2 <span class=\"keyword\">where</span> emp.empno = emp2.empno;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--const：这个表至多有一个匹配行，</span></span><br><span class=\"line\"><span class=\"keyword\">explain</span> <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> emp <span class=\"keyword\">where</span> empno = <span class=\"number\">7369</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">--system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现</span></span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"possible-keys\"   >\n          <a href=\"#possible-keys\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>possible_keys</h3>\n      <p>显示可能应用在这张表中的索引，一个或多个，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用</p>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">explain</span> <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> emp,dept <span class=\"keyword\">where</span> emp.deptno = dept.deptno <span class=\"keyword\">and</span> emp.deptno = <span class=\"number\">10</span>;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"key\"   >\n          <a href=\"#key\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>key</h3>\n      <p>实际使用的索引，如果为null，则没有使用索引，查询中若使用了覆盖索引，则该索引和查询的select字段重叠。</p>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">explain</span> <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> emp,dept <span class=\"keyword\">where</span> emp.deptno = dept.deptno <span class=\"keyword\">and</span> emp.deptno = <span class=\"number\">10</span>;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"key-len\"   >\n          <a href=\"#key-len\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>key_len</h3>\n      <p>表示索引中使用的字节数，可以通过key_len计算查询中使用的索引长度，在不损失精度的情况下长度越短越好。</p>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">explain</span> <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> emp,dept <span class=\"keyword\">where</span> emp.deptno = dept.deptno <span class=\"keyword\">and</span> emp.deptno = <span class=\"number\">10</span>;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"ref\"   >\n          <a href=\"#ref\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>ref</h3>\n      <p>显示索引的哪一列被使用了，如果可能的话，是一个常数</p>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">explain</span> <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> emp,dept <span class=\"keyword\">where</span> emp.deptno = dept.deptno <span class=\"keyword\">and</span> emp.deptno = <span class=\"number\">10</span>;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"rows\"   >\n          <a href=\"#rows\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>rows</h3>\n      <p>根据表的统计信息及索引使用情况，大致估算出找出所需记录需要读取的行数，此参数很重要，直接反应的sql找了多少数据，在完成目的的情况下越少越好</p>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">explain</span> <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> emp;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h3 id=\"extra\"   >\n          <a href=\"#extra\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>extra</h3>\n      <p>包含额外的信息。</p>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--using filesort:说明mysql无法利用索引进行排序，只能利用排序算法进行排序，会消耗额外的位置</span></span><br><span class=\"line\"><span class=\"keyword\">explain</span> <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> emp <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> sal;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--using temporary:建立临时表来保存中间结果，查询完成之后把临时表删除</span></span><br><span class=\"line\"><span class=\"keyword\">explain</span> <span class=\"keyword\">select</span> ename,<span class=\"keyword\">count</span>(*) <span class=\"keyword\">from</span> emp <span class=\"keyword\">where</span> deptno = <span class=\"number\">10</span> <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> ename;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--using index:这个表示当前的查询时覆盖索引的，直接从索引中读取数据，而不用访问数据表。如果同时出现using where 表名索引被用来执行索引键值的查找，如果没有，表面索引被用来读取数据，而不是真的查找</span></span><br><span class=\"line\"><span class=\"keyword\">explain</span> <span class=\"keyword\">select</span> deptno,<span class=\"keyword\">count</span>(*) <span class=\"keyword\">from</span> emp <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> deptno <span class=\"keyword\">limit</span> <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--using where:使用where进行条件过滤</span></span><br><span class=\"line\"><span class=\"keyword\">explain</span> <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> t_user <span class=\"keyword\">where</span> <span class=\"keyword\">id</span> = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--using join buffer:使用连接缓存，情况没有模拟出来</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--impossible where：where语句的结果总是false</span></span><br><span class=\"line\"><span class=\"keyword\">explain</span> <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> emp <span class=\"keyword\">where</span> empno = <span class=\"number\">7469</span>;</span><br></pre></td></tr></table></div></figure>","categories":["MySQL"],"tags":["MySQL","MySQL调优"]},{"title":"MySQL日志 Redo、Undo、binlog","url":"/2020/09/23/MySQL%E6%97%A5%E5%BF%97-Redo%E3%80%81Undo%E3%80%81binlog/","content":"\n        <h1 id=\"MySQL日志-Redo、Undo、binlog\"   >\n          <a href=\"#MySQL日志-Redo、Undo、binlog\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>MySQL日志 Redo、Undo、binlog</h1>\n      \n        <h2 id=\"Redo日志—innodb存储引擎的日志文件\"   >\n          <a href=\"#Redo日志—innodb存储引擎的日志文件\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Redo日志—innodb存储引擎的日志文件</h2>\n      <ol>\n<li>当发生数据修改的时候，innodb引擎会先将记录写到redo log中，并更新内存，此时更新就算是完成了，同时innodb引擎会在合适的时机将记录操作到磁盘中</li>\n<li>Redolog是固定大小的，是循环写的过程</li>\n<li>有了redolog之后，innodb就可以保证即使数据库发生异常重启，之前的记录也不会丢失，叫做crash-safe</li>\n</ol>\n<p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a8795160a154a678bdc67.png\"  alt=\"b98a63c1e5cce333af3640f329c27a05.png\">\n      </p>\n<a id=\"more\"></a>\n\n\n        <h2 id=\"Undo-log日志\"   >\n          <a href=\"#Undo-log日志\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Undo log日志</h2>\n      <ol>\n<li>Undo Log是为了实现事务的原子性，在MySQL数据库InnoDB存储引擎中，还用Undo Log来实现多版本并发控制(简称：MVCC)</li>\n<li>在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为Undo Log）。然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态</li>\n<li>注意：undo log是逻辑日志，可以理解为：<ol>\n<li>当delete一条记录时，undo log中会记录一条对应的insert记录</li>\n<li>当insert一条记录时，undo log中会记录一条对应的delete记录</li>\n<li>当update一条记录时，它记录一条对应相反的update记录</li>\n</ol>\n</li>\n</ol>\n\n        <h2 id=\"binlog—服务端的日志文件\"   >\n          <a href=\"#binlog—服务端的日志文件\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>binlog—服务端的日志文件</h2>\n      <ul>\n<li><p>Binlog是server层的日志，主要做mysql功能层面的事情</p>\n</li>\n<li><p>Binlog中会记录所有的逻辑，并且采用追加写的方式</p>\n</li>\n<li><p>一般在企业中数据库会有备份系统，可以定期执行备份，备份的<br>周期可以自己设置</p>\n</li>\n</ul>\n\n        <h3 id=\"恢复数据的过程\"   >\n          <a href=\"#恢复数据的过程\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>恢复数据的过程</h3>\n      <ol>\n<li>找到最近一次的全量备份数据</li>\n<li>从备份的时间点开始，将备份的binlog取出来，重放到要恢复的那个时刻</li>\n</ol>\n\n        <h2 id=\"binlog与redo日志的区别\"   >\n          <a href=\"#binlog与redo日志的区别\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>binlog与redo日志的区别</h2>\n      <ol>\n<li>redo是innodb独有的，binlog是所有引擎都可以使用的</li>\n<li>redo是物理日志，记录的是在某个数据页上做了什么修改，binlog是逻辑日志，记录的是这个语句的原始逻辑</li>\n<li>redo是循环写的，空间会用完，binlog是可以追加写的，不会覆盖之前的日志信息</li>\n</ol>\n\n        <h2 id=\"数据更新的流程\"   >\n          <a href=\"#数据更新的流程\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>数据更新的流程</h2>\n      <p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a8795160a154a678bdc64.png\"  alt=\"229797c471c9878b9ca4783785ae5f89.png\">\n      </p>\n<p>执行流程：</p>\n<ol>\n<li>执行器先从引擎中找到数据，如果在内存中直接返回，如果不在内存中，查询后返回</li>\n<li>执行器拿到数据之后会先修改数据，然后调用引擎接口重新写入数据</li>\n<li>引擎将数据更新到内存，同时写数据到redo中，此时处于prepare(准备)阶段，并通知执行器执行完成，随时可以操作</li>\n<li>执行器生成这个操作的binlog</li>\n<li>执行器调用引擎的事务提交接口，引擎把刚刚写完的redo改成commit状态，更新完成</li>\n</ol>\n\n        <h3 id=\"为什么redo要有两个阶段（prepare、commit）\"   >\n          <a href=\"#为什么redo要有两个阶段（prepare、commit）\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>为什么redo要有两个阶段（prepare、commit）</h3>\n      <p>总结来说：<strong>保证数据的一致性</strong></p>\n<ul>\n<li>如果先写redo log后写binlog：<br>假设修改了一行数据将a从0改为1，在redo log写完，binlog还没有写完的时候，MySQL进程异常重启。redo log写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行a的值是1。但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句。因此，之后备份日志的时候，存起来的binlog里面就没有这条语句。如果需要用这个binlog来恢复临时库的话，恢复出来的这一行a的值就是0，数据不能保持一致。</li>\n<li>先写binlog后写redo log：<br>如果在binlog写完之后crash，由于redo log还没写，崩溃恢复以后这个事务无效，所以这一行a的值是0。但是binlog里面已经记录了“把a从0改成1”这个日志。所以，在之后用binlog来恢复的时候这一行a的值就是1，与原库的值不同,数据不能保持一致。</li>\n</ul>\n","categories":["MySQL"],"tags":["MySQL"]},{"title":"MySQL索引","url":"/2020/09/23/MySQL%E7%B4%A2%E5%BC%95/","content":"\n        <h1 id=\"MySQL索引\"   >\n          <a href=\"#MySQL索引\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>MySQL索引</h1>\n      <blockquote>\n<p>磁盘预读（预读的长度一般为页（page）的整数倍，页大小通常为4k）：<br><br>&emsp;页是存储器的逻辑块，操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页,主存和磁盘以页为单位交换数据。</p>\n</blockquote>\n<a id=\"more\"></a>\n\n\n        <h2 id=\"MySQL整体结构简图\"   >\n          <a href=\"#MySQL整体结构简图\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>MySQL整体结构简图</h2>\n      <p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a865d160a154a678b7ed1.png\"  alt=\"0052f2fa8f97c4e94334b422f8d6990e.png\">\n      </p>\n<p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a865d160a154a678b7eca.png\"  alt=\"3d704f5810f1e7af0969454754849e43.png\">\n      </p>\n<ul>\n<li>聚簇索引：数据和文件放在一起：innodb<ul>\n<li>.frm文件：存放表结构</li>\n<li>.ibd文件：存放数据文件和索引文件</li>\n</ul>\n</li>\n</ul>\n<p>注意：MySQL的innodb存储引擎在默认情况下会把所有的数据文件放到表空间中，不会为每一个单独的表存一分数据文件。</p>\n<ul>\n<li>费聚簇索引：数据、索引单独一个文件：MyISAM<ul>\n<li>.frm文件：存放表结构</li>\n<li>.MYI文件：存放索引数据</li>\n<li>.MYD文件：存放实际数据</li>\n</ul>\n</li>\n</ul>\n<p>具体查看<span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://app.yinxiang.com/shard/s22/nl/23898398/583df461-257e-4486-98a7-35ec3811bb5e\" >mysql架构</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n\n        <h2 id=\"索引是什么\"   >\n          <a href=\"#索引是什么\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>索引是什么</h2>\n      <ol>\n<li>索引是帮助 MySQL 高效获取数据的数据结构</li>\n<li>索引存储在文件系统中</li>\n<li>索引的文件存储形式与存储引擎有关</li>\n<li>索引文件的结构<ol>\n<li>hash</li>\n<li>二叉树</li>\n<li>B树</li>\n<li>B+树（mysql用B+树）</li>\n</ol>\n</li>\n</ol>\n\n        <h2 id=\"各种数据结构情况\"   >\n          <a href=\"#各种数据结构情况\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>各种数据结构情况</h2>\n      \n        <h3 id=\"hash表\"   >\n          <a href=\"#hash表\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>hash表</h3>\n      <p>哈希表可以完成索引的存储，每次在添加索引的时候需要计算指定列的hash值，取模运算后计算出下标，将元素插入下标位置即可<br>适合场景:</p>\n<ol>\n<li>等值查询</li>\n<li>表中的数据是无序数据(范围查找的时候比较浪费时间,需要个进行遍历操作</li>\n</ol>\n<p>在企业中多数的查询时范围查询，所以此时hash表不是特别合适<br>hash表在使用的时候,需要将全部的数据加载到内存,比较耗费内存的空间也不是很合适</p>\n<p>缺点：</p>\n<ol>\n<li>利用hash存储的话需要将所有的数据文件添加到内存，比较耗费内存空间</li>\n<li>如果所有的查询都是等值查询，那么hash确实很快，但是在企业或者实际工作环境中范围查找的数据更多，而不是等值查询，因此hash就不太适合了</li>\n</ol>\n\n        <h3 id=\"树\"   >\n          <a href=\"#树\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>树</h3>\n      <p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a865d160a154a678b7ecd.png\"  alt=\"9875b71260c51c13b9f32004748e9ff4.png\">\n      </p>\n<p>在树的结构中，左子树必须小于根节点，右子树必须大于根节点，如果是多叉树的话，从左到右是有序</p>\n<ol>\n<li>AVL平衡树<br>AVL树是一颗严格意义上的平衡树，最高子树跟最低子树高度之差不能超过1因此在进行元素插入的时候，会进行1到N次的旋转，严重影响插入的性能</li>\n<li>红黑树<br>红黑树是基于AVL树的一个升级，损失了部分查的性能，来提升插入的性能，在红黑树中最低子树跟最高子树<br>之差小于2倍即可，在插入的时候，不需要进行N多次的旋转操作，而且还加入了变色的特性，来满足插入和查间性能的平衡</li>\n<li>总结<br>二又树及其N多的变种都不能支撑素引，原因是<br> <strong>1. 树的深度无法控制而造成io次数变多，影响数据读取的效率</strong><br> <strong>2. 插入数据的性能比较低</strong></li>\n</ol>\n\n        <h3 id=\"B树\"   >\n          <a href=\"#B树\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>B树</h3>\n      <p>B树特点：</p>\n<ol>\n<li>所有键值分布在整颗树中</li>\n<li>搜索有可能在非叶子结点结束，在关键字全集内做一次查找,性能逼近二分查找</li>\n<li>每个节点最多拥有m个子树</li>\n<li>根节点至少有2个子树</li>\n<li>分支节点至少拥有m/2颗子树（除根节点和叶子节点外都是分支节点）</li>\n<li>所有叶子节点都在同一层、每个节点最多可以有m-1个key，并且以升序排列</li>\n</ol>\n<p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a86c1160a154a678b9d96.png\"  alt=\"b76a5637732e2c68a28dfa43ab974e38.png\">\n      </p>\n<p>实例图说明：<br>每个节点占用一个磁盘块，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为 16 和 34，P1 指针指向的子树的数据范围为小于 16，P2 指针指向的子树的数据范围为 16~34，P3 指针指向的子树的数据范围为大于 34。 </p>\n<p>查找关键字过程：</p>\n<ol>\n<li>根据根节点找到磁盘块 1，读入内存。【磁盘 I/O 操作第 1 次】</li>\n<li>比较关键字 28 在区间（16,34），找到磁盘块 1 的指针 P2。</li>\n<li>根据 P2 指针找到磁盘块 3，读入内存。【磁盘 I/O 操作第 2 次】</li>\n<li>比较关键字 28 在区间（25,31），找到磁盘块 3 的指针 P2。</li>\n<li>根据 P2 指针找到磁盘块 8，读入内存。【磁盘 I/O 操作第 3 次】</li>\n<li>在磁盘块 8 中的关键字列表中找到关键字 28。 </li>\n</ol>\n<p>缺点：<br>1、每个节点都有key，同时也包含data，而每个页存储空间是有限的，如果data比较大的话会导致每个节点存储的key数量变小<br>2、当存储的数据量很大的时候会导致深度较大，增大查询时磁盘io次数，进而影响查询性能</p>\n\n        <h3 id=\"B-树\"   >\n          <a href=\"#B-树\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>B+树</h3>\n      <p>B+Tree是在BTree的基础之上做的一种优化，变化如下：</p>\n<ol>\n<li>B+Tree每个节点可以包含更多的节点，这个做的原因有两个，第一个原因是为了降低树的高度，第二个原因是将数据范围变为多个区间，区间越多，数据检索越快</li>\n<li>非叶子节点存储key，叶子节点存储key和数据</li>\n<li>叶子节点两两指针相互连接（符合磁盘的预读特性），顺序查询性能更高</li>\n</ol>\n<p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a86c1160a154a678b9d85.png\"  alt=\"056b526af9bb4b8829afd9651256d980.png\">\n      </p>\n<p>注意：在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对 B+Tree 进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找（查单个和查范围都可以）。</p>\n\n        <h4 id=\"InnoDB–B-Tree（叶子节点直接放置数据）\"   >\n          <a href=\"#InnoDB–B-Tree（叶子节点直接放置数据）\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>InnoDB–B+Tree（叶子节点直接放置数据）</h4>\n      <p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a86c1160a154a678b9d8c.png\"  alt=\"d83dc7c66c85f62bea3c11b5feaf772b.png\">\n      </p>\n<p>注意：</p>\n<ol>\n<li>InnoDB是通过B+Tree结构对主键创建索引，然后叶子节点中存储记录，如果没有主键，那么会选择唯一键，如果没有唯一键，那么会生成一个6位的row_id来作为主键</li>\n<li>如果创建索引的键是其他字段，那么在叶子节点中存储的是该记录的主键，然后再通过主键索引找到对应的记录,叫做<strong>回表</strong></li>\n</ol>\n\n        <h5 id=\"回表\"   >\n          <a href=\"#回表\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>回表</h5>\n      <p>回表：如果创建索引的键不是主键、唯一键，那么在叶子节点中存储的是该记录的主键，然后再通过主键索引找到对应的记录。<strong>查找了两颗B+树</strong></p>\n<p>例如下图，要根据name=’gang’查找，先从第一棵树种找到gang对应的主键是4，在拿4到下一颗树种查找4对应的信息。<br>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a86c1160a154a678b9d8f.png\"  alt=\"f12b0114d7e8ea20cf02bad1aa43a578.png\">\n      </p>\n\n        <h4 id=\"mysql-MyISAM–B-Tree\"   >\n          <a href=\"#mysql-MyISAM–B-Tree\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>mysql MyISAM–B+Tree</h4>\n      <p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a86c1160a154a678b9d93.png\"  alt=\"455277281b6a9864f276d342fe218cdd.png\">\n      </p>\n<p>MyISAM的数据、索引单独存放，叶子结点存放的不是数据，而是数据的地址值</p>\n\n        <h4 id=\"B-树添加与删除\"   >\n          <a href=\"#B-树添加与删除\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>B+树添加与删除</h4>\n      <p><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://app.yinxiang.com/shard/s22/nl/23898398/6770a0a8-33af-42e6-a8e6-c7c744471a8a\" >B+树添加和删除数据图解</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n\n        <h2 id=\"索引的分类\"   >\n          <a href=\"#索引的分类\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>索引的分类</h2>\n      <p>mysql索引的五种类型：主键索引、唯一索引、普通索引和全文索引、组合索引。通过给字段添加索引可以提高数据的读取速度，提高项目的并发能力和抗压能力。</p>\n<ol>\n<li>主键索引<br> 主键是一种唯一性索引，但它必须指定为PRIMARY KEY，每个表只能有一个主键。如果无特殊需求，考虑把主键设置自增，可以减少页分裂和页合并操作，减少IO提高效率</li>\n<li>唯一索引<br> 索引列的所有值都只能出现一次，即必须唯一，值可以为空。</li>\n<li>普通索引<br> 基本的索引类型，值可以为空，没有唯一性的限制。（覆盖索引）</li>\n<li>全文索引（MyISAM支持，Innodb在5.6之后支持）<br> 全文索引的索引类型为FULLTEXT。全文索引可以在varchar、char、text类型的列上创建<br> 项目中基本不用mysql做这个，一般用ES</li>\n<li>组合索引<br> 多列值组成一个索引，专门用于组合搜索（最左匹配原则）</li>\n</ol>\n\n        <h3 id=\"覆盖索引\"   >\n          <a href=\"#覆盖索引\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>覆盖索引</h3>\n      <p>覆盖索引：<br>简单来说就是 <strong>索引包含了（或覆盖了）满足查询语句中字段与条件的数据</strong><br>解释：一张表有id、name两个字段，建立了id、name两个索引，如果要select * from tab where name=’’，需要在name索引中找到对应的id，再拿id去查询（回表，两次查询）。<br>    此时如果将sql改写为select id from tab where name=’’，这样在name索引中就可以找到结果（没有回表，一次查询）。</p>\n<p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6a873f160a154a678bc326.png\"  alt=\"0c8be303325bf5ea34767e8e135e9aad.png\">\n      </p>\n\n        <h3 id=\"最左前缀匹配原则\"   >\n          <a href=\"#最左前缀匹配原则\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>最左前缀匹配原则</h3>\n      <p>在MySQL建立联合索引时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配</p>\n\n        <h3 id=\"索引下推\"   >\n          <a href=\"#索引下推\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>索引下推</h3>\n      <p>简单来说就是 在回表之前先做筛选，可以使回表查询的全行数据比较少，这就是mysql的索引下推。</p>\n<p>例如：<br>对于user_table表，我们现在有（username,age）联合索引。<br>现在有一个需求，查出名称中以“张”开头且年龄小于等于10的用户信息，语句如下：<br>“select * from user_table where username like ‘张%’ and age &gt; 10”.<br>此时，根据（username,age）联合索引查询所有满足名称以“张”开头的索引，<strong>然后直接再筛选出年龄小于等于10的索引，之后再回表查询全行数据</strong>，这种方式需要回表查询的全行数据比较少，就是mysql的索引下推</p>\n\n        <h2 id=\"Mysql存储引擎区别\"   >\n          <a href=\"#Mysql存储引擎区别\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Mysql存储引擎区别</h2>\n      <div class=\"table-container\"><table>\n<thead>\n<tr>\n<th></th>\n<th>MyISAM</th>\n<th>InnoDB</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>索引类型</td>\n<td>非聚簇索引</td>\n<td>聚簇索引</td>\n</tr>\n<tr>\n<td>支持事务</td>\n<td>否</td>\n<td>是</td>\n</tr>\n<tr>\n<td>支持表锁</td>\n<td>是</td>\n<td>是</td>\n</tr>\n<tr>\n<td>支持行锁</td>\n<td>否</td>\n<td>是</td>\n</tr>\n<tr>\n<td>支持外键</td>\n<td>否</td>\n<td>是</td>\n</tr>\n<tr>\n<td>支持全文索引</td>\n<td>是</td>\n<td>是（5.6后支持）</td>\n</tr>\n<tr>\n<td>适合操作类型</td>\n<td>大量select</td>\n<td>大量insert、delete、update</td>\n</tr>\n</tbody></table></div>\n\n        <h2 id=\"索引维护\"   >\n          <a href=\"#索引维护\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>索引维护</h2>\n      <p>索引在插入新的值的时候，为了维护索引的有序性，必须要维护，在维护索引的时候需要需要分以下集中情况：</p>\n<ol>\n<li>如果插入一个比较大的值，直接插入即可，几乎没有成本</li>\n<li>如果插入的是中间的某一个值，需要逻辑上移动后续的元素，空出位置</li>\n<li>如果需要插入的数据页满了，就需要单独申请一个新的数据页，然后移动部分数据过去，叫做页分裂，此时性能会受影响同时空间的使用率也会降低，除了页分裂之外还包含页合并</li>\n</ol>\n","categories":["MySQL"],"tags":["MySQL"]},{"title":"GC和GC Tuning","url":"/2020/09/22/GC%E5%92%8CGC-Tuning/","content":"\n        <h1 id=\"GC和GC-Tuning\"   >\n          <a href=\"#GC和GC-Tuning\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>GC和GC Tuning</h1>\n      \n        <h2 id=\"GC的基础知识\"   >\n          <a href=\"#GC的基础知识\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>GC的基础知识</h2>\n      \n        <h3 id=\"1-什么是垃圾\"   >\n          <a href=\"#1-什么是垃圾\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>1.什么是垃圾</h3>\n      <p>没有任何<strong>引用指向</strong>的一个对象或者多个对象（循环引用）</p>\n<a id=\"more\"></a>\n\n\n        <h3 id=\"2-如何定位垃圾\"   >\n          <a href=\"#2-如何定位垃圾\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>2.如何定位垃圾</h3>\n      <ol>\n<li><p>引用计数算法</p>\n<p> 对象有一个引用指向就是1，两个就是2，没有就是0，这时就是垃圾<br> 问题：循环引用无法解决，比如下图是一堆垃圾相互引用，<strong>会导致内存泄漏</strong><br> \n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f698ab9160a154a671f4635.png\"  alt=\"927f4bafb08942bf8727477973d2456b.png\">\n      </p>\n</li>\n<li><p>根可达（根搜索、Root Searching）算法</p>\n<p> 通过根对象能够找到的就不是垃圾，反之就是垃圾</p>\n<p> 根有哪些：</p>\n<ol>\n<li>线程栈变量 <ul>\n<li>一个main方法开始运行，main线程栈中的变量调用了其他方法，main线程栈中的方法访问到的对象是根对象 </li>\n</ul>\n</li>\n<li>静态变量<ul>\n<li>T.class对静态变量初始化能够访问到的对象是根对象 </li>\n</ul>\n</li>\n<li>常量池 <ul>\n<li>如果一个class能够用到其他的class对象叫根对象</li>\n</ul>\n</li>\n<li>JNI指针<ul>\n<li>如果调用了本地方法运用到本地的对象叫根对象</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li><p>根对象：当一个程序启动时就需要用到的对象叫做根对象</p>\n<p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f698ab9160a154a671f462e.png\"  alt=\"efccd4a1d60db196fe6595fcc097d7ee.png\">\n      </p>\n</li>\n</ul>\n</li>\n</ol>\n\n        <h3 id=\"3-常见的垃圾回收算法\"   >\n          <a href=\"#3-常见的垃圾回收算法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>3.常见的垃圾回收算法</h3>\n      <ol>\n<li>标记清除(mark sweep) <ul>\n<li>算法相对简单，存货对象比较多的情况下效率比较高 </li>\n<li>位置不连续，容易产生碎片，需要经过两遍扫描（第一遍标记有用的，第二遍清除无用的）</li>\n</ul>\n</li>\n<li>拷贝算法 (copying)  - 适合Eden区<ul>\n<li>适用于存活对象较少的情况，只扫描一次，效率提高，没有碎片</li>\n<li>比较浪费空间，移动复制对象，需要调整对象引用</li>\n</ul>\n</li>\n<li>标记压缩(mark compact) <ul>\n<li>没有碎片，方便对象分配，不会产生内存减半</li>\n<li>扫描两次，需要移动对象并调整指针，效率偏低</li>\n</ul>\n</li>\n</ol>\n\n        <h3 id=\"4-JVM内存分代模型（用于分代垃圾回收算法）\"   >\n          <a href=\"#4-JVM内存分代模型（用于分代垃圾回收算法）\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>4.JVM内存分代模型（用于分代垃圾回收算法）</h3>\n      <p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f698b5b160a154a671f9efa.png\"  alt=\"c62ce51447e2af5dfb9ca8000ab89e73.png\">\n      <br>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f698b69160a154a671fa803.png\"  alt=\"e35f7af17d149845bbf8a9f21dc2a7f6.png\">\n      </p>\n<ul>\n<li>-Xms -Xmx -Xmn X是分标参数，m是memory，s是最小值，x是最大值，n是new,新生代的大小</li>\n</ul>\n<ol>\n<li><p>部分垃圾回收器使用的模型</p>\n<ul>\n<li>除Epsilon ZGC Shenandoah之外的GC都是使用逻辑分代模型</li>\n<li>G1是逻辑分代，物理不分代</li>\n<li>除此之外不仅逻辑分代，而且物理分代</li>\n</ul>\n</li>\n<li><p>新生代 + 老年代 + 永久代（1.7）Perm Generation/ 元数据区(1.8) Metaspace</p>\n<ol>\n<li>永久代 元数据 - 存放Class信息、代码编译信息等</li>\n<li>永久代必须指定大小限制 ，元数据可以设置，也可以不设置，不设置受限于物理内存</li>\n<li>字符串常量 1.7 - 永久代，1.8 - 堆</li>\n<li>MethodArea是逻辑概念 - 他的实现在1.7叫永久代、1.8叫元数据</li>\n<li>新生代、老年代是堆，永久代 元数据区是堆之外的空间</li>\n</ol>\n</li>\n<li><p>新生代 = Eden + 2个suvivor区 （三个区域比例8:1:1）</p>\n<ol>\n<li>YGC回收之后，大多数的对象会被回收，活着的进入s0</li>\n<li>再次YGC，活着的对象eden + s0 -&gt; s1</li>\n<li>再次YGC，eden + s1 -&gt; s0</li>\n<li>年龄足够 -&gt; 老年代 （可以指定，默认PS 15次，CMS 6次，G1 15次。注意：文件头中存贮次数的地方是4位，最大就是15）</li>\n<li>s区装不下 -&gt; 老年代</li>\n</ol>\n</li>\n<li><p>老年代（老年代：新生代 = 3:1）</p>\n<ol>\n<li>顽固分子</li>\n<li>老年代满了FGC （Full GC）</li>\n</ol>\n</li>\n<li><p>GC 调优(Generation分代模型)</p>\n<ol>\n<li>尽量减少FGC</li>\n<li>MinorGC = YGC</li>\n<li>MajorGC = FGC</li>\n</ol>\n</li>\n<li><p>动态年龄：（不重要）<br>当YGC一次后，Eden和s0中的存活对象进入s1，如果超过s1容量的50%，其中年龄最大的对象会被放入老年代<br>参考：<span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.jianshu.com/p/989d3b06a49d\" >https://www.jianshu.com/p/989d3b06a49d</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n</li>\n<li><p>分配担保：（不重要）<br>YGC期间 survivor区空间不够了 空间担保直接进入老年代<br>参考：<span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://cloud.tencent.com/developer/article/1082730\" >https://cloud.tencent.com/developer/article/1082730</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n</li>\n<li><p>对象分配过程如下图：<br>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f698b74160a154a671fae5c.png\"  alt=\"86795f58498f8eb819d4b430c45742a6.png\">\n      <br>首先在栈上分配，如果能分配就分配到栈上，分配不下就会判断大不大（用一个参数制定），如果特别大，就直接进入old区，否则进去TLAB，到Eden区，进行FGC，如果没被清除还存活进入S1，再FGC还存活进S2，当年龄足够进入old区</p>\n</li>\n</ol>\n\n        <h3 id=\"5-常见的垃圾回收器\"   >\n          <a href=\"#5-常见的垃圾回收器\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>5.常见的垃圾回收器</h3>\n      <p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f698b8b160a154a671fbad9.png\"  alt=\"aff0a0be7e69d5d1f359ff9162fd0300.png\">\n      </p>\n<ul>\n<li>JDK诞生时就是Serial，为了提高效率，诞生了PS，为了配合CMS，诞生了PN。CMS是1.4版本后期引入，CMS是里程碑式的GC，它开启了并发回收的过程，但是CMS毛病较多，因此目前任何一个JDK版本默认是CMS<ul>\n<li>并发垃圾回收是因为无法忍受STW</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>Serial 年轻代 串行回收（满了就在安全点上STW(stop-the-world)然后<strong>单线程</strong>回收，依次循环）</li>\n<li>Parallel Scavenge(PS) 年轻代 并行回收（满了就STW(stop-the-world)然后<strong>多线程</strong>回收，依次循环） java14已弃用</li>\n<li>ParNew 年轻代 对PS做了一些增强，能够配合CMS的并行回收</li>\n<li>SerialOld 老年代的Serial  java14已弃用</li>\n<li>ParallelOld 老年代的PS</li>\n<li>ConcurrentMarkSweep 老年代 并发的， 垃圾回收和应用程序同时运行，降低STW的时间(200ms)<ul>\n<li>CMS问题比较多，所以现在没有一个版本默认是CMS，只能手工指定</li>\n<li>CMS既然是MarkSweep，就一定会有碎片化的问题，碎片到达一定程度，CMS的老年代分配对象分配不下的时候，使用SerialOld 进行老年代回收<br>想象一下：<br>PS + PO -&gt; 加内存 换垃圾回收器 -&gt; PN + CMS + SerialOld（几个小时 - 几天的STW）<br>几十个G的内存，单线程回收 -&gt; G1 + FGC 几十个G -&gt; 上T内存的服务器 ZGC<br>算法：三色标记 + Incremental Update</li>\n</ul>\n</li>\n<li>G1(10ms)<br>算法：三色标记 + SATB</li>\n<li>ZGC (1ms) 能够PK C++<br>算法：ColoredPointers + LoadBarrier（读屏障）</li>\n<li>Shenandoah<br> 算法：ColoredPointers + WriteBarrier（写屏障）</li>\n<li>Eplison</li>\n<li>PS 和 PN区别的延伸阅读：<br>▪<span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://docs.oracle.com/en/java/javase/13/gctuning/ergonomics.html\" >https://docs.oracle.com/en/java/javase/13/gctuning/ergonomics.html#GUID-3D0BB91E-9BFF-4EBB-B523-14493A860E73</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li>垃圾收集器跟内存大小的关系<ol>\n<li>Serial 几十兆</li>\n<li>PS 上百兆 - 几个G</li>\n<li>CMS - 20G</li>\n<li>G1 - 上百G</li>\n<li>ZGC - 4T - 16T（JDK13）</li>\n</ol>\n</li>\n</ol>\n<p><strong>1.8默认的垃圾回收：PS + ParallelOld（PO）</strong></p>\n\n        <h2 id=\"常见垃圾回收器组合参数设定：-1-8\"   >\n          <a href=\"#常见垃圾回收器组合参数设定：-1-8\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>常见垃圾回收器组合参数设定：(1.8)</h2>\n      <ul>\n<li><p>-XX:+UseSerialGC = Serial New (DefNew) + Serial Old</p>\n<ul>\n<li>小型程序。默认情况下不会是这种选项，HotSpot会根据计算及配置和JDK版本自动选择收集器</li>\n</ul>\n</li>\n<li><p>-XX:+UseParNewGC = ParNew + SerialOld</p>\n<ul>\n<li>这个组合已经很少用（在某些版本中已经废弃）</li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://stackoverflow.com/questions/34962257/why-remove-support-for-parnewserialold-anddefnewcms-in-the-future\" >https://stackoverflow.com/questions/34962257/why-remove-support-for-parnewserialold-anddefnewcms-in-the-future</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n</ul>\n</li>\n<li><p>-XX:+UseConc(urrent)MarkSweepGC = ParNew + CMS + Serial Old（括号内的内容在默写版本需要加上）</p>\n</li>\n<li><p>-XX:+UseParallelGC = Parallel Scavenge + Parallel Old (1.8默认) 【PS + SerialOld】</p>\n</li>\n<li><p>-XX:+UseParallelOldGC = Parallel Scavenge + Parallel Old</p>\n</li>\n<li><p>-XX:+UseG1GC = G1</p>\n</li>\n<li><p>Linux中没找到默认GC的查看方法，而windows中会打印UseParallelGC </p>\n<ul>\n<li>java +XX:+PrintCommandLineFlags -version</li>\n<li>通过GC的日志来分辨</li>\n</ul>\n</li>\n<li><p>Linux下1.8版本默认的垃圾回收器到底是什么？</p>\n<ul>\n<li>1.8.0_181 默认（看不出来）Copy MarkCompact</li>\n<li>1.8.0_222 默认 PS + PO</li>\n</ul>\n</li>\n</ul>\n\n        <h2 id=\"JVM调优第一步，了解JVM常用命令行参数\"   >\n          <a href=\"#JVM调优第一步，了解JVM常用命令行参数\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>JVM调优第一步，了解JVM常用命令行参数</h2>\n      <ul>\n<li><p>JVM的命令行参数参考：<span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html\" >https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n</li>\n<li><p>HotSpot参数分类</p>\n<blockquote>\n<p>标准： - 开头，所有的HotSpot都支持<br>非标准：-X 开头，特定版本HotSpot支持特定命令<br>不稳定：-XX 开头，下个版本可能取消</p>\n</blockquote>\n<p>java -version</p>\n<p>java -X</p>\n</li>\n</ul>\n<p>试验用程序：</p>\n<figure class=\"highlight java\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"> <span class=\"keyword\">import</span> java.util.LinkedList;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloGC</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">     System.out.println(<span class=\"string\">&quot;HelloGC!&quot;</span>);</span><br><span class=\"line\">     List list = <span class=\"keyword\">new</span> LinkedList();</span><br><span class=\"line\">     <span class=\"keyword\">for</span>(;;) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">byte</span>[] b = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span>*<span class=\"number\">1024</span>];</span><br><span class=\"line\">       list.add(b);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></div></figure>\n\n<ol>\n<li><p>区分概念：内存泄漏memory leak，内存溢出out of memory</p>\n</li>\n<li><p>java -XX:+PrintCommandLineFlags HelloGC</p>\n<p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f698ba3160a154a671fc860.png\"  alt=\"43b58700144c5f2022a5e21b30703d23.png\">\n      </p>\n</li>\n</ol>\n<pre><code>    * InitialHeapSize 起始堆大小，根据内存算出来\n    * MaxHeapSize 最大堆大小\n    * UseCompressedClassPointers 默认\n    * UseCompressedOops 普通指针压缩</code></pre>\n<ol start=\"3\">\n<li><p>java -Xmn10M -Xms40M -Xmx60M -XX:+PrintCommandLineFlags -XX:+PrintGC  HelloGC<br> PrintGCDetails PrintGCTimeStamps PrintGCCauses</p>\n<ul>\n<li>Xms最小堆大小、Xmx最大堆大小，一般情况下设置成一样的，不要让他产生弹性压缩浪费系统资源</li>\n<li>-XX:+PrintGC 打印GC回收的信息</li>\n<li>PrintGCDetails 打印更详细的GC信息</li>\n<li>PrintGCTimeStamps 打印GC产生是系统的详细时间</li>\n<li>PrintGCCauses 打印GC产生的原因<br>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f698be3160a154a671ff161.png\"  alt=\"0e63ffb24d2f6aa3f2fa6caf06ef784d.png\">\n      </li>\n</ul>\n</li>\n<li><p>java -XX:+UseConcMarkSweepGC -XX:+PrintCommandLineFlags HelloGC</p>\n<ul>\n<li>设置CMS GC，-XX:+PrintGC打印CMS的GC跟上面差不多，会多一些CMS的详细的阶段过程</li>\n</ul>\n</li>\n<li><p>java -XX:+PrintFlagsInitial 默认参数值</p>\n</li>\n<li><p>java -XX:+PrintFlagsFinal 最终参数值</p>\n</li>\n<li><p>java -XX:+PrintFlagsFinal | grep xxx 找到对应的参数</p>\n</li>\n<li><p>java -XX:+PrintFlagsFinal -version |grep GC</p>\n</li>\n</ol>\n\n        <h2 id=\"PS-GC日志详解\"   >\n          <a href=\"#PS-GC日志详解\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>PS GC日志详解</h2>\n      <p>每种垃圾回收器的日志格式是不同的！</p>\n<p>PS日志格式</p>\n<p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f698c07160a154a672007e8.png\"  alt=\"c8ecb28583f3c664174e204aded82a78.png\">\n      </p>\n<p>heap dump部分（内存溢出，会打印堆的信息）：</p>\n<figure class=\"highlight java\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">eden space <span class=\"number\">5632</span>K, <span class=\"number\">94</span>% used [<span class=\"number\">0x00000000ff980000</span>,<span class=\"number\">0x00000000ffeb3e28</span>,<span class=\"number\">0x00000000fff00000</span>)</span><br><span class=\"line\"><span class=\"comment\">//三个地址分别是：内存起始地址、使用空间结束地址、整体空间结束地址</span></span><br><span class=\"line\"><span class=\"comment\">//eden区整体大小5632k，使用了94%，eden区地址是从 第1个地址 开始到 第3个地址 结束，其中从第1个地址到了第2个地址是已经使用的，占94%</span></span><br></pre></td></tr></table></div></figure>\n\n<p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f698c07160a154a672007e2.png\"  alt=\"62119ba3f0733d7ffd4d5b15ef40035b.png\">\n      </p>\n<p>total = eden + 1个survivor</p>\n\n        <h2 id=\"调优\"   >\n          <a href=\"#调优\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>调优</h2>\n      \n        <h3 id=\"调优前的基础概念：\"   >\n          <a href=\"#调优前的基础概念：\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>调优前的基础概念：</h3>\n      <ol>\n<li>吞吐量：用户代码时间 /（用户代码执行时间 + 垃圾回收时间）</li>\n<li>响应时间：STW越短，响应时间越好</li>\n</ol>\n<p>所谓调优，首先确定，追求啥？吞吐量优先，还是响应时间优先？还是在满足一定的响应时间的情况下，要求达到多大的吞吐量…</p>\n<p>问题：</p>\n<p>科学计算，吞吐量。数据挖掘，吞吐量。吞吐量优先的一般：（PS + PO）</p>\n<p>响应时间：网站 GUI API （1.8 G1）</p>\n\n        <h3 id=\"什么是调优？\"   >\n          <a href=\"#什么是调优？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>什么是调优？</h3>\n      <ol>\n<li>根据需求进行JVM规划和预调优</li>\n<li>优化运行JVM运行环境（慢，卡顿）</li>\n<li>解决JVM运行过程中出现的各种问题(OOM)</li>\n</ol>\n\n        <h3 id=\"解决JVM运行中的问题\"   >\n          <a href=\"#解决JVM运行中的问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>解决JVM运行中的问题</h3>\n      \n        <h4 id=\"一个案例理解常用工具\"   >\n          <a href=\"#一个案例理解常用工具\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>一个案例理解常用工具</h4>\n      <ol>\n<li>测试代码：</li>\n</ol>\n<figure class=\"highlight java\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.mashibing.jvm.gc;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">import</span> java.math.BigDecimal;</span><br><span class=\"line\">   <span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\">   <span class=\"keyword\">import</span> java.util.Date;</span><br><span class=\"line\">   <span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\">   <span class=\"keyword\">import</span> java.util.concurrent.ScheduledThreadPoolExecutor;</span><br><span class=\"line\">   <span class=\"keyword\">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class=\"line\">   <span class=\"keyword\">import</span> java.util.concurrent.TimeUnit;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 从数据库中读取信用数据，套用模型，并把结果进行记录和传输</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T15_FullGC_Problem01</span> </span>&#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">       <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CardInfo</span> </span>&#123;</span><br><span class=\"line\">           BigDecimal price = <span class=\"keyword\">new</span> BigDecimal(<span class=\"number\">0.0</span>);</span><br><span class=\"line\">           String name = <span class=\"string\">&quot;张三&quot;</span>;</span><br><span class=\"line\">           <span class=\"keyword\">int</span> age = <span class=\"number\">5</span>;</span><br><span class=\"line\">           Date birthdate = <span class=\"keyword\">new</span> Date();</span><br><span class=\"line\">   </span><br><span class=\"line\">           <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">m</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">       <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ScheduledThreadPoolExecutor executor = <span class=\"keyword\">new</span> ScheduledThreadPoolExecutor(<span class=\"number\">50</span>,</span><br><span class=\"line\">               <span class=\"keyword\">new</span> ThreadPoolExecutor.DiscardOldestPolicy());</span><br><span class=\"line\">   </span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">           executor.setMaximumPoolSize(<span class=\"number\">50</span>);</span><br><span class=\"line\">   </span><br><span class=\"line\">           <span class=\"keyword\">for</span> (;;)&#123;</span><br><span class=\"line\">               modelFit();</span><br><span class=\"line\">               Thread.sleep(<span class=\"number\">100</span>);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">modelFit</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">           List&lt;CardInfo&gt; taskList = getAllCardInfo();</span><br><span class=\"line\">           taskList.forEach(info -&gt; &#123;</span><br><span class=\"line\">               <span class=\"comment\">// do something</span></span><br><span class=\"line\">               executor.scheduleWithFixedDelay(() -&gt; &#123;</span><br><span class=\"line\">                   <span class=\"comment\">//do sth with info</span></span><br><span class=\"line\">                   info.m();</span><br><span class=\"line\">   </span><br><span class=\"line\">               &#125;, <span class=\"number\">2</span>, <span class=\"number\">3</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">           &#125;);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;CardInfo&gt; <span class=\"title\">getAllCardInfo</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">           List&lt;CardInfo&gt; taskList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">   </span><br><span class=\"line\">           <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">               CardInfo ci = <span class=\"keyword\">new</span> CardInfo();</span><br><span class=\"line\">               taskList.add(ci);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">           <span class=\"keyword\">return</span> taskList;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>使用命令运行 java -Xms200M -Xmx200M -XX:+PrintGC com.mashibing.jvm.gc.T15_FullGC_Problem01</p>\n<ul>\n<li>一般是运维团队首先受到报警信息（CPU Memory），如何定位问题</li>\n</ul>\n<ol>\n<li><p>传统命令行，<strong>top</strong>命令观察到问题：内存不断增长 CPU占用率居高不下</p>\n</li>\n<li><p>top -Hp 观察进程中的线程，哪个线程CPU和内存占比高</p>\n</li>\n<li><p><strong>jps</strong>定位具体java进程； <strong>jstack</strong> 定位线程状况，重点关注：WAITING BLOCKED<br>例如：<br>waiting on &lt;0x0000000088ca3310&gt; (a java.lang.Object)<br>假如有一个进程中100个线程，很多线程都在waiting on <xx> ，一定要找到是哪个线程持有这把锁<br>怎么找？搜索jstack dump的信息，找<xx> ，看哪个线程持有这把锁，这个线程状态可能是RUNNABLE</p>\n</li>\n<li><p>为什么阿里规范里规定，线程的名称（尤其是线程池）都要写有意义的名称<br>怎么样自定义线程池里的线程名称？（自定义ThreadFactory）</p>\n</li>\n<li><p><strong>jinfo</strong> pid </p>\n</li>\n<li><p><strong>jstat</strong> -gc 动态观察gc情况 / 阅读GC日志发现频繁GC / arthas观察 / jconsole/jvisualVM/ Jprofiler（最好用）<br>jstat -gc 4655 500 : 每个500个毫秒打印GC的情况<br>如果面试官问你是怎么定位OOM问题的？如果你回答用图形界面（错误）<br>1：已经上线的系统不用图形界面用什么？（cmd line(命令行)、arthas）<br>2：图形界面到底用在什么地方？测试！测试的时候进行监控！（压测观察）</p>\n</li>\n<li><p><strong>jmap</strong> - histo 4655 | head -20，查找有多少对象产生，线上环境定位可以用</p>\n</li>\n<li><p>jmap -dump:format=b,file=xxx pid ：<br>线上系统，内存特别大，jmap执行堆转储期间会对进程产生很大影响，甚至卡顿（电商不适合），这时候怎么办？<br>1：设定了参数HeapDump，OOM的时候会自动产生堆转储文件<br>2：很多服务器备份（高可用），停掉这台服务器对其他服务器不影响（首选说法）<br>3：在线定位(一般小点儿公司用不到)</p>\n<ul>\n<li>我了解jmap一旦执行了堆转储对线上系统影响比较大，所以我们做了隔离，先把那台机器隔离开然后再做这件事</li>\n</ul>\n</li>\n<li><p>java -Xms20M -Xmx20M -XX:+UseParallelGC -XX:+HeapDumpOnOutOfMemoryError com.mashibing.jvm.gc.T15_FullGC_Problem01</p>\n</li>\n<li><p>使用MAT / jhat /jvisualvm 进行dump文件分析<br> <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.cnblogs.com/baihuitestsoftware/articles/6406271.html\" >https://www.cnblogs.com/baihuitestsoftware/articles/6406271.html</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span> </p>\n<ul>\n<li>jhat -J-mx512M xxx.dump</li>\n</ul>\n<p>-J-mx512M设定最大使用内存<br><span class=\"exturl\"><a class=\"exturl__link\"   href=\"http://192.168.17.11:7000/\" >http://192.168.17.11:7000</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span><br>拉到最后：找到对应链接<br>可以使用OQL查找特定问题对象</p>\n</li>\n<li><p>系统已经oom了怎么到处dump文件？</p>\n<ol>\n<li>指定XX:+HeapDumpOnOutOfMemoryError参数会自动生成，不过如果是大内存，会很慢</li>\n<li>oom后不要重启，使用jmap命令</li>\n</ol>\n</li>\n<li><p>找到代码的问题</p>\n<ul>\n<li>cpu/内存飚高-&gt;top/jps命令查-&gt;cpu高可能是死循环死锁，用jstat看哪个县城有问题 -频繁GC有对象回收不了用jmap导出来分析</li>\n</ul>\n</li>\n</ol>\n\n        <h5 id=\"jconsole远程连接\"   >\n          <a href=\"#jconsole远程连接\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>jconsole远程连接</h5>\n      <ol>\n<li>程序启动加入参数：</li>\n</ol>\n<figure class=\"highlight shell\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">java -Djava.rmi.server.hostname=192.168.17.11 -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=11111 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false XXX</span><br></pre></td></tr></table></div></figure>\n\n<ol start=\"2\">\n<li>如果遭遇 Local host name unknown：XXX的错误，修改/etc/hosts文件，把XXX加入进去</li>\n</ol>\n<figure class=\"highlight java\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">192.168</span>.<span class=\"number\">17.11</span> basic localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class=\"line\">::<span class=\"number\">1</span>         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br></pre></td></tr></table></div></figure>\n\n<ol start=\"3\">\n<li>关闭linux防火墙（实战中应该打开对应端口）</li>\n</ol>\n<figure class=\"highlight shell\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">service iptables stop</span><br><span class=\"line\">chkconfig iptables off #永久关闭</span><br></pre></td></tr></table></div></figure>\n<ol start=\"4\">\n<li>windows上打开 jconsole远程连接 192.168.17.11:11111</li>\n</ol>\n\n        <h5 id=\"jvisualvm远程连接\"   >\n          <a href=\"#jvisualvm远程连接\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>jvisualvm远程连接</h5>\n      <p> <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.cnblogs.com/liugh/p/7620336.html\" >https://www.cnblogs.com/liugh/p/7620336.html</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span> （简单做法）</p>\n\n        <h5 id=\"jprofiler-收费\"   >\n          <a href=\"#jprofiler-收费\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>jprofiler (收费)</h5>\n      \n        <h5 id=\"arthas在线排查工具\"   >\n          <a href=\"#arthas在线排查工具\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>arthas在线排查工具</h5>\n      <ul>\n<li>为什么需要在线排查？<br> 在生产上我们经常会碰到一些不好排查的问题，例如线程安全问题，用最简单的threaddump或者heapdump不好查到问题原因。为了排查这些问题，有时我们会临时加一些日志，比如在一些关键的函数里打印出入参，然后重新打包发布，如果打了日志还是没找到问题，继续加日志，重新打包发布。对于上线流程复杂而且审核比较严的公司，从改代码到上线需要层层的流转，会大大影响问题排查的进度。 </li>\n<li>jvm观察jvm信息</li>\n<li>thread观察定位线程问题</li>\n<li>dashboard 观察系统情况</li>\n<li>heapdump + jhat分析</li>\n<li>jad反编译<br> 动态代理生成类的问题定位<br> 第三方的类（观察代码）<br> 版本问题（确定自己最新提交的版本是不是被使用）</li>\n<li>redefine 热替换<br> 目前有些限制条件：只能改方法实现（方法已经运行完成），不能改方法名， 不能改属性</li>\n<li>sc  - search class</li>\n<li>watch  - watch method</li>\n<li>没有包含的功能：jmap（查找有多少对象产生未包含）</li>\n</ul>\n\n        <h3 id=\"GC算法的基础概念\"   >\n          <a href=\"#GC算法的基础概念\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>GC算法的基础概念</h3>\n      <ul>\n<li>Card Table<br>由于做YGC时，需要扫描整个OLD区，效率非常低，所以JVM设计了CardTable， 如果一个OLD区CardTable中有对象指向Y区，就将它设为Dirty（脏的），下次扫描时，只需要扫描Dirty Card<br>在结构上，Card Table用BitMap来实现</li>\n</ul>\n\n        <h3 id=\"三色标记算法\"   >\n          <a href=\"#三色标记算法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>三色标记算法</h3>\n      <ul>\n<li>白色：未被标记的对象</li>\n<li>灰色：自身被标记，成员变量（它引用的对象）未被标记</li>\n<li>黑色：自身和成员变量都被标记</li>\n</ul>\n\n        <h4 id=\"漏标问题及解决方案\"   >\n          <a href=\"#漏标问题及解决方案\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>漏标问题及解决方案</h4>\n      <p>漏标是指，当黑色指向白色，指向白色的其他引用没了，此时白色是存活对象但是没有被标记，就会被当成垃圾回收掉。<br>解决：</p>\n<ul>\n<li>incremental update – 增量更新，跟踪引用的增加，把黑色重新标记为灰色（CMS使用这种方式）</li>\n<li>SATB – 关注引用的删除，当引用消失时，把这个引用放到GC的堆栈，保证消失的引用还能被GC扫描到（G1使用）</li>\n<li>为什么G1使用SATB？<ol>\n<li>因为第一种方式标记为灰色之后，还要重新扫描，效率低</li>\n<li>灰色指向白色的引用消失时，如果没有黑色指向白色，引用会被push到堆栈，下次扫描时拿到这个引用，由于有RSet，不需要扫描整个堆去查找指向白色的引用，SATB配合RSet效率高</li>\n</ol>\n</li>\n</ul>\n\n        <h3 id=\"CMS\"   >\n          <a href=\"#CMS\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>CMS</h3>\n      \n        <h4 id=\"CMS的问题\"   >\n          <a href=\"#CMS的问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>CMS的问题</h4>\n      <ol>\n<li><p>Memory Fragmentation 内存碎片化</p>\n<blockquote>\n<p>-XX:+UseCMSCompactAtFullCollection<br>-XX:CMSFullGCsBeforeCompaction 默认为0 指的是经过多少次FGC才进行压缩</p>\n</blockquote>\n</li>\n<li><p>Floating Garbage 浮动垃圾</p>\n<blockquote>\n<p>Concurrent Mode Failure<br>产生：if the concurrent collector is unable to finish reclaiming the unreachable objects before the tenured generation fills up, or if an allocation cannot be satisfiedwith the available free space blocks in the tenured generation, then theapplication is paused and the collection is completed with all the applicationthreads stopped</p>\n<p>解决方案：<strong>降低触发CMS的阈值</strong></p>\n<p>PromotionFailed</p>\n<p>解决方案类似，保持老年代有足够的空间</p>\n<p>–XX:CMSInitiatingOccupancyFraction 92% 可以降低这个值，让CMS保持老年代足够的空间</p>\n</blockquote>\n</li>\n</ol>\n\n        <h4 id=\"CMS日志分析\"   >\n          <a href=\"#CMS日志分析\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>CMS日志分析</h4>\n      <p>执行命令：java -Xms20M -Xmx20M -XX:+PrintGCDetails -XX:+UseConcMarkSweepGC com.mashibing.jvm.gc.T15_FullGC_Problem01</p>\n<p>[GC (Allocation Failure) [ParNew: 6144K-&gt;640K(6144K), 0.0265885 secs] 6585K-&gt;2770K(19840K), 0.0268035 secs] [Times: user=0.02 sys=0.00, real=0.02 secs] </p>\n<blockquote>\n<p>ParNew：年轻代收集器</p>\n<p>6144-&gt;640：收集前后的对比</p>\n<p>（6144）：整个年轻代容量</p>\n<p>6585 -&gt; 2770：整个堆的情况</p>\n<p>（19840）：整个堆大小</p>\n</blockquote>\n<figure class=\"highlight java\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">[GC (CMS Initial Mark) [<span class=\"number\">1</span> CMS-initial-mark: <span class=\"number\">8511</span>K(<span class=\"number\">13696</span>K)] <span class=\"number\">9866</span>K(<span class=\"number\">19840</span>K), <span class=\"number\">0.0040321</span> secs] [Times: user=<span class=\"number\">0.01</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.00</span> secs] </span><br><span class=\"line\">\t<span class=\"comment\">//8511 (13696) : 老年代使用（最大）</span></span><br><span class=\"line\">\t<span class=\"comment\">//9866 (19840) : 整个堆使用（最大）</span></span><br><span class=\"line\">[CMS-concurrent-mark-start]</span><br><span class=\"line\">[CMS-concurrent-mark: <span class=\"number\">0.018</span>/<span class=\"number\">0.018</span> secs] [Times: user=<span class=\"number\">0.01</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.02</span> secs] </span><br><span class=\"line\">\t<span class=\"comment\">//这里的时间意义不大，因为是并发执行</span></span><br><span class=\"line\">[CMS-concurrent-preclean-start]</span><br><span class=\"line\">[CMS-concurrent-preclean: <span class=\"number\">0.000</span>/<span class=\"number\">0.000</span> secs] [Times: user=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.00</span> secs] </span><br><span class=\"line\">\t<span class=\"comment\">//标记Card为Dirty，也称为Card Marking</span></span><br><span class=\"line\">[GC (CMS Final Remark) [YG occupancy: 1597 K (6144 K)][Rescan (parallel) , 0.0008396 secs][weak refs processing, 0.0000138 secs][class unloading, 0.0005404 secs][scrub symbol table, 0.0006169 secs][scrub string table, 0.0004903 secs][1 CMS-remark: 8511K(13696K)] 10108K(19840K), 0.0039567 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class=\"line\">\t<span class=\"comment\">//STW阶段，YG occupancy:年轻代占用及容量</span></span><br><span class=\"line\">\t<span class=\"comment\">//[Rescan (parallel)：STW下的存活对象标记</span></span><br><span class=\"line\">\t<span class=\"comment\">//weak refs processing: 弱引用处理</span></span><br><span class=\"line\">\t<span class=\"comment\">//class unloading: 卸载用不到的class</span></span><br><span class=\"line\">\t<span class=\"comment\">//scrub symbol(string) table: </span></span><br><span class=\"line\">\t\t<span class=\"comment\">//cleaning up symbol and string tables which hold class-level metadata and </span></span><br><span class=\"line\">\t\t<span class=\"comment\">//internalized string respectively</span></span><br><span class=\"line\">\t<span class=\"comment\">//CMS-remark: 8511K(13696K): 阶段过后的老年代占用及容量</span></span><br><span class=\"line\">\t<span class=\"comment\">//10108K(19840K): 阶段过后的堆占用及容量</span></span><br><span class=\"line\"></span><br><span class=\"line\">[CMS-concurrent-sweep-start]</span><br><span class=\"line\">[CMS-concurrent-sweep: <span class=\"number\">0.005</span>/<span class=\"number\">0.005</span> secs] [Times: user=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.01</span> secs] </span><br><span class=\"line\">\t<span class=\"comment\">//标记已经完成，进行并发清理</span></span><br><span class=\"line\">[CMS-concurrent-reset-start]</span><br><span class=\"line\">[CMS-concurrent-reset: <span class=\"number\">0.000</span>/<span class=\"number\">0.000</span> secs] [Times: user=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.00</span> secs]</span><br><span class=\"line\">\t<span class=\"comment\">//重置内部结构，为下次GC做准备</span></span><br></pre></td></tr></table></div></figure>\n\n\n\n\n        <h3 id=\"G1\"   >\n          <a href=\"#G1\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>G1</h3>\n      <ol>\n<li>▪<span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.oracle.com/technical-resources/articles/java/g1gc.html\" >https://www.oracle.com/technical-resources/articles/java/g1gc.html</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n</ol>\n\n        <h4 id=\"G1逻辑分层，物理不分层\"   >\n          <a href=\"#G1逻辑分层，物理不分层\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>G1逻辑分层，物理不分层</h4>\n      <p>G1吧内存分为一小块一小块的区域，old区存放老年对象；Survivor区存放存活对象；Eden区存放新生对象；Humongous存放大对象。某一个区域可能是年轻代也可能是老年代，但是在同一时刻只能属于某个时代</p>\n\n        <h4 id=\"G1特点\"   >\n          <a href=\"#G1特点\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>G1特点</h4>\n      <ul>\n<li>并发收集</li>\n<li>压缩空闲空间不会延长GC的暂停时间</li>\n<li>更容易的预测GC暂停时间</li>\n<li>适用于不需要很高吞吐量的场景</li>\n<li>G1的内存区域不是固定的E或O，可能是年轻代也可能是老年代，但是在同一时刻只能属于某个时代</li>\n<li>新老年代比例是动态的，最好不要手工指定，因为这是G1预测停顿时间的基准</li>\n</ul>\n\n        <h4 id=\"CSet\"   >\n          <a href=\"#CSet\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>CSet</h4>\n      <p>有哪些需要被回收，会收集到表格里</p>\n\n        <h4 id=\"RSet\"   >\n          <a href=\"#RSet\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>RSet</h4>\n      <p>每一个Region（区域）里面都会有一个hash表，记录了其他Region中的对象到本Region的引用<br>作用：使得垃圾回收器不需要扫描整个堆找到谁引用了当前分区中的对象，只需要扫描RSet即可</p>\n\n        <h4 id=\"G1日志详解\"   >\n          <a href=\"#G1日志详解\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>G1日志详解</h4>\n      <figure class=\"highlight java\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">[<span class=\"function\">GC <span class=\"title\">pause</span> <span class=\"params\">(G1 Evacuation Pause)</span> <span class=\"params\">(young)</span> <span class=\"params\">(initial-mark)</span>, 0.0015790 secs]</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//young -&gt; 年轻代 Evacuation-&gt; 复制存活对象 </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//initial-mark 混合回收的阶段，这里是YGC混合老年代回收</span></span></span><br><span class=\"line\"><span class=\"function\">   [Parallel Time: 1.5 ms, GC Workers: 1] <span class=\"comment\">//一个GC线程</span></span></span><br><span class=\"line\"><span class=\"function\">      [GC Worker <span class=\"title\">Start</span> <span class=\"params\">(ms)</span>:  92635.7]</span></span><br><span class=\"line\"><span class=\"function\">      [Ext Root <span class=\"title\">Scanning</span> <span class=\"params\">(ms)</span>:  1.1]</span></span><br><span class=\"line\"><span class=\"function\">      [Update <span class=\"title\">RS</span> <span class=\"params\">(ms)</span>:  0.0]</span></span><br><span class=\"line\"><span class=\"function\">         [Processed Buffers:  1]</span></span><br><span class=\"line\"><span class=\"function\">      [Scan <span class=\"title\">RS</span> <span class=\"params\">(ms)</span>:  0.0]</span></span><br><span class=\"line\"><span class=\"function\">      [Code Root <span class=\"title\">Scanning</span> <span class=\"params\">(ms)</span>:  0.0]</span></span><br><span class=\"line\"><span class=\"function\">      [Object <span class=\"title\">Copy</span> <span class=\"params\">(ms)</span>:  0.1]</span></span><br><span class=\"line\"><span class=\"function\">      [<span class=\"title\">Termination</span> <span class=\"params\">(ms)</span>:  0.0]</span></span><br><span class=\"line\"><span class=\"function\">         [Termination Attempts:  1]</span></span><br><span class=\"line\"><span class=\"function\">      [GC Worker <span class=\"title\">Other</span> <span class=\"params\">(ms)</span>:  0.0]</span></span><br><span class=\"line\"><span class=\"function\">      [GC Worker <span class=\"title\">Total</span> <span class=\"params\">(ms)</span>:  1.2]</span></span><br><span class=\"line\"><span class=\"function\">      [GC Worker <span class=\"title\">End</span> <span class=\"params\">(ms)</span>:  92636.9]</span></span><br><span class=\"line\"><span class=\"function\">   [Code Root Fixup: 0.0 ms]</span></span><br><span class=\"line\"><span class=\"function\">   [Code Root Purge: 0.0 ms]</span></span><br><span class=\"line\"><span class=\"function\">   [Clear CT: 0.0 ms]</span></span><br><span class=\"line\"><span class=\"function\">   [Other: 0.1 ms]</span></span><br><span class=\"line\"><span class=\"function\">      [Choose CSet: 0.0 ms]</span></span><br><span class=\"line\"><span class=\"function\">      [Ref Proc: 0.0 ms]</span></span><br><span class=\"line\"><span class=\"function\">      [Ref Enq: 0.0 ms]</span></span><br><span class=\"line\"><span class=\"function\">      [Redirty Cards: 0.0 ms]</span></span><br><span class=\"line\"><span class=\"function\">      [Humongous Register: 0.0 ms]</span></span><br><span class=\"line\"><span class=\"function\">      [Humongous Reclaim: 0.0 ms]</span></span><br><span class=\"line\"><span class=\"function\">      [Free CSet: 0.0 ms]</span></span><br><span class=\"line\"><span class=\"function\">   [Eden: 0.0<span class=\"title\">B</span><span class=\"params\">(<span class=\"number\">1024.0</span>K)</span>-&gt;0.0<span class=\"title\">B</span><span class=\"params\">(<span class=\"number\">1024.0</span>K)</span> Survivors: 0.0B-&gt;0.0B Heap: 18.8<span class=\"title\">M</span><span class=\"params\">(<span class=\"number\">20.0</span>M)</span>-&gt;18.8<span class=\"title\">M</span><span class=\"params\">(<span class=\"number\">20.0</span>M)</span>]</span></span><br><span class=\"line\"><span class=\"function\"> [Times: user</span>=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.00</span> secs] </span><br><span class=\"line\"><span class=\"comment\">//以下是混合回收其他阶段</span></span><br><span class=\"line\">[GC concurrent-root-region-scan-start]</span><br><span class=\"line\">[GC concurrent-root-region-scan-end, <span class=\"number\">0.0000078</span> secs]</span><br><span class=\"line\">[GC concurrent-mark-start]</span><br><span class=\"line\"><span class=\"comment\">//无法evacuation，进行FGC</span></span><br><span class=\"line\">[<span class=\"function\">Full <span class=\"title\">GC</span> <span class=\"params\">(Allocation Failure)</span>  18M-&gt;18<span class=\"title\">M</span><span class=\"params\">(<span class=\"number\">20</span>M)</span>, 0.0719656 secs]</span></span><br><span class=\"line\"><span class=\"function\">   [Eden: 0.0<span class=\"title\">B</span><span class=\"params\">(<span class=\"number\">1024.0</span>K)</span>-&gt;0.0<span class=\"title\">B</span><span class=\"params\">(<span class=\"number\">1024.0</span>K)</span> Survivors: 0.0B-&gt;0.0B Heap: 18.8<span class=\"title\">M</span><span class=\"params\">(<span class=\"number\">20.0</span>M)</span>-&gt;18.8<span class=\"title\">M</span><span class=\"params\">(<span class=\"number\">20.0</span>M)</span>], [Metaspace: 38</span></span><br><span class=\"line\"><span class=\"function\">76K-&gt;3876<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">1056768</span>K)</span>] [Times: user</span>=<span class=\"number\">0.07</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.07</span> secs]</span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n\n\n\n\n\n        <h3 id=\"GC常用参数\"   >\n          <a href=\"#GC常用参数\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>GC常用参数</h3>\n      <ul>\n<li>-Xmn -Xms -Xmx -Xss<br>年轻代 最小堆 最大堆 栈空间</li>\n<li>-XX:+UseTLAB<br>使用TLAB，默认打开</li>\n<li>-XX:+PrintTLAB<br>打印TLAB的使用情况</li>\n<li>-XX:TLABSize<br>设置TLAB大小<pre><code>  这三个一般不用动</code></pre>\n</li>\n<li>-XX:+DisableExplictGC<br>System.gc()不管用 ，FGC。线上系统一般都要设置</li>\n<li>-XX:+PrintGC<br>打印GC信息</li>\n<li>-XX:+PrintGCDetails<br>打印GC的详细信息</li>\n<li>-XX:+PrintHeapAtGC<br>GC打印堆栈情况</li>\n<li>-XX:+PrintGCTimeStamps<br>发生GC的系统时间</li>\n<li>-XX:+PrintGCApplicationConcurrentTime (重要性低)<br>打印应用程序时间</li>\n<li>-XX:+PrintGCApplicationStoppedTime （重要性低）<br>打印暂停时长</li>\n<li>-XX:+PrintReferenceGC （重要性低）<br>记录回收了多少种不同引用类型的引用</li>\n<li>-verbose:class<br>类加载详细过程</li>\n<li>-XX:+PrintVMOptions<br>打印JVM的参数</li>\n<li>-XX:+<strong>PrintFlagsFinal</strong>  -XX:+PrintFlagsInitial<br>  分别是最终的初始化/默认参数<br>必须会用</li>\n<li>-Xloggc:opt/log/gc.log<br>记录GC日志</li>\n<li>-XX:MaxTenuringThreshold<br>GC升代年龄，最大值15</li>\n<li>-XX:PreBlockSpin 锁自旋次数 -XX:CompileThreshold 热点代码检测参数 逃逸分析 标量替换 …<br>这些不建议设置</li>\n</ul>\n\n        <h3 id=\"Parallel常用参数\"   >\n          <a href=\"#Parallel常用参数\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Parallel常用参数</h3>\n      <ul>\n<li>-XX:SurvivorRatio<br>Survivor区比例，默认8:1:1，可以调，很少动</li>\n<li>-XX:PreTenureSizeThreshold<br>大对象到底多大，通过这个指定</li>\n<li>-XX:MaxTenuringThreshold<br>GC升代年龄，最大值15</li>\n<li>-XX:+ParallelGCThreads<br>并行收集器的线程数，同样适用于CMS，一般设为和CPU核数相同。一般不会调，会自动检测设置</li>\n<li>-XX:+UseAdaptiveSizePolicy<br>自动选择各区大小比例</li>\n</ul>\n\n        <h3 id=\"CMS常用参数\"   >\n          <a href=\"#CMS常用参数\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>CMS常用参数</h3>\n      <ul>\n<li>-XX:+UseConcMarkSweepGC<br>CMS启动</li>\n<li>-XX:ParallelCMSThreads<br>CMS线程数量，默认是核数的一半</li>\n<li>-XX:CMSInitiatingOccupancyFraction<br>使用多少比例的老年代后开始CMS收集，默认是68%(近似值)，如果频繁发生SerialOld卡顿，应该调小，（频繁CMS回收）</li>\n<li>-XX:+UseCMSCompactAtFullCollection<br>在FGC时进行压缩</li>\n<li>-XX:CMSFullGCsBeforeCompaction<br>多少次FGC之后进行压缩</li>\n<li>-XX:+CMSClassUnloadingEnabled<br> 回收永久代（1.8之前的）</li>\n<li>-XX:CMSInitiatingPermOccupancyFraction<br>达到什么比例时进行Perm回收（1.8之前的）</li>\n<li>GCTimeRatio<br>设置GC时间占用程序运行时间的百分比，是一个建议时间，GC会尝试用各种手段达到这个时间</li>\n<li>-XX:MaxGCPauseMillis<br>停顿时间，是一个建议时间，GC会尝试用各种手段达到这个时间，比如减小年轻代</li>\n</ul>\n\n        <h3 id=\"G1常用参数\"   >\n          <a href=\"#G1常用参数\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>G1常用参数</h3>\n      <ul>\n<li>-XX:+UseG1GC<br>  使用G1 GC</li>\n<li>-XX:MaxGCPauseMillis<br>停顿时间，是一个建议时间，G1会尝试调整Young区的块数来达到这个值</li>\n<li>-XX:GCPauseIntervalMillis<br>？GC的间隔时间，再查一下</li>\n<li>-XX:+G1HeapRegionSize<br>分区大小，建议逐渐增大该值，1 2 4 8 16 32。<br>随着size增加，垃圾的存活时间更长，GC间隔更长，但每次GC的时间也会更长<br>ZGC做了改进（动态区块大小）</li>\n<li>G1NewSizePercent<br>新生代最小比例，默认为5%</li>\n<li>G1MaxNewSizePercent<br>新生代最大比例，默认为60%</li>\n<li>GCTimeRatio<br>GC时间建议比例，G1会根据这个值调整堆空间</li>\n<li>ConcGCThreads<br>线程数量</li>\n<li>InitiatingHeapOccupancyPercent<br>启动G1的堆空间占用比例</li>\n</ul>\n\n        <h3 id=\"参考资料\"   >\n          <a href=\"#参考资料\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>参考资料</h3>\n      <ol>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://blogs.oracle.com/jonthecollector/our-collectors\" >https://blogs.oracle.com/</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://blogs.oracle.com/jonthecollector/our-collectors\" >jonthecollector</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://blogs.oracle.com/jonthecollector/our-collectors\" >/our-collectors</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html\" >https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp\" >http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></li>\n<li>JVM调优参考文档：<span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://docs.oracle.com/en/java/javase/13/gctuning/introduction-garbage-collection-tuning.html#GUID-8A443184-7E07-4B71-9777-4F12947C8184\" >https://docs.oracle.com/en/java/javase/13/gctuning/introduction-garbage-collection-tuning.html#GUID-8A443184-7E07-4B71-9777-4F12947C8184</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span> </li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.cnblogs.com/nxlhero/p/11660854.html\" >https://www.cnblogs.com/nxlhero/p/11660854.html</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span> 在线排查工具</li>\n<li><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.jianshu.com/p/507f7e0cc3a3\" >https://www.jianshu.com/p/507f7e0cc3a3</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span> arthas常用命令</li>\n<li>Arthas手册：<ol>\n<li>启动arthas java -jar arthas-boot.jar</li>\n<li>绑定java进程</li>\n<li>dashboard命令观察系统整体情况</li>\n<li>help 查看帮助</li>\n<li>help xx 查看具体命令帮助</li>\n</ol>\n</li>\n<li>jmap命令参考： <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.jianshu.com/p/507f7e0cc3a3\" >https://www.jianshu.com/p/507f7e0cc3a3</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span> <ol>\n<li>jmap -heap pid</li>\n<li>jmap -histo pid</li>\n<li>jmap -clstats pid</li>\n</ol>\n</li>\n</ol>\n","categories":["JVM"],"tags":["JVM"]},{"title":"java运行时数据区和常用指令","url":"/2020/09/22/java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%92%8C%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/","content":"\n        <h1 id=\"Runtime-Data-Area-and-Instruction-Set\"   >\n          <a href=\"#Runtime-Data-Area-and-Instruction-Set\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Runtime Data Area and Instruction Set</h1>\n      <p>jvms 2.4 2.5</p>\n\n        <h2 id=\"指令集分类（了解）\"   >\n          <a href=\"#指令集分类（了解）\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>指令集分类（了解）</h2>\n      <ol>\n<li>基于寄存器的指令集</li>\n<li>基于栈的指令集<br>Hotspot中的Local Variable Table = JVM中的寄存器</li>\n</ol>\n<a id=\"more\"></a>\n\n\n        <h2 id=\"Runtime-Data-Area\"   >\n          <a href=\"#Runtime-Data-Area\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Runtime Data Area</h2>\n      <p>PC program Counter<br>JVM Stacks<br>Heap<br>Method Area<br>Run - Time Constant Pool<br>Native Method Stack<br>Direct Memory</p>\n\n        <h3 id=\"PC-程序计数器\"   >\n          <a href=\"#PC-程序计数器\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>PC 程序计数器</h3>\n      <blockquote>\n<p>存放指令位置</p>\n<p>虚拟机的运行，类似于这样的循环：</p>\n<p>while( not end ) {</p>\n<p>取PC中的位置，找到对应位置的指令；</p>\n<p>执行该指令；</p>\n<p>PC ++;</p>\n<p>}</p>\n</blockquote>\n\n        <h3 id=\"JVM-Stack\"   >\n          <a href=\"#JVM-Stack\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>JVM Stack</h3>\n      <p> Frame（栈帧） - 一个方法对应一个栈帧，栈帧内包含</p>\n<ol>\n<li>Local Variable Table （局部变量表）</li>\n<li>Operand Stack （操作数据栈）<br>对于long的处理（store and load），多数虚拟机的实现都是原子的<br>jls 17.7，没必要加volatile</li>\n<li>Dynamic Linking（动态链接）<br> <span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://blog.csdn.net/qq_41813060/article/details/88379473\" >https://blog.csdn.net/qq_41813060/article/details/88379473</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span><br>jvms 2.6.3</li>\n<li>return address<br>a() -&gt; b()，方法a调用了方法b, b方法执行结束后要换回到a的什么地方继续执行</li>\n</ol>\n\n        <h3 id=\"Method-Area\"   >\n          <a href=\"#Method-Area\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Method Area</h3>\n      <ol>\n<li>Perm Space (&lt;1.8)<ul>\n<li>字符串常量位于PermSpace</li>\n<li>FGC不会清理</li>\n<li>大小启动的时候指定，不能变</li>\n</ul>\n</li>\n<li>Meta Space (&gt;=1.8)<ul>\n<li>字符串常量位于堆</li>\n<li>会触发FGC清理</li>\n<li>不设定的话，最大就是物理内存</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>Perm Space与Meta Space是不同版本的Method Area的实现</li>\n<li>方法区是不被所有线程共享的，方法区内装的是每一class的结构</li>\n</ul>\n\n        <h3 id=\"Run-Time-Constant-Pool\"   >\n          <a href=\"#Run-Time-Constant-Pool\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Run - Time Constant Pool</h3>\n      <p>常量池的内容在运行的时候就扔在Run - Time Constant Pool中</p>\n<hr>\n<p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f698a56160a154a671f0967.png\"  alt=\"f7371bcaf97d345ec46b864c316ed0d5.png\">\n      </p>\n\n        <h2 id=\"常用java字节码指令\"   >\n          <a href=\"#常用java字节码指令\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>常用java字节码指令</h2>\n      <p>store  将一个数值从操作数栈存储到局部变量表的指令</p>\n<p>push 将一个常量加载到操作数栈的指令</p>\n<p>load  将一个局部变量加载到操作栈的指令</p>\n<p>pop 弹出</p>\n<p>mul 乘法</p>\n<p>sub 减法</p>\n<p>add 加法</p>\n<p>invoke</p>\n<ol>\n<li>InvokeStatic  <ul>\n<li>调用静态方法 </li>\n</ul>\n</li>\n<li>InvokeVirtual <ul>\n<li>自带多态，new一个对象调用m方法，在里面压栈，压的是谁调用的就是那个对象的方法</li>\n</ul>\n</li>\n<li>InvokeInterface <ul>\n<li>比如List是interface然后new了一个对象，再调用add方法，就是InvokeInterface</li>\n<li>List<String> = new ArrayList<String>();</li>\n<li>但是如果是ArrayList<String> = new ArrayList<String>();再调用add方法，就是InvokeVirtual</li>\n</ul>\n</li>\n<li>InovkeSpecial<ul>\n<li>可以直接定位，不需要多态的方法</li>\n<li>private 方法 ， 构造方法</li>\n</ul>\n</li>\n<li>InvokeDynamic<ul>\n<li>JVM最难的指令</li>\n<li>lambda表达式或者反射或者其他动态语言（scala kotlin），或者CGLib ASM，动态产生的class，会用到的指令</li>\n<li>内部类的内部类</li>\n</ul>\n</li>\n</ol>\n\n        <h2 id=\"分析一个递归程序的运行过程\"   >\n          <a href=\"#分析一个递归程序的运行过程\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>分析一个递归程序的运行过程</h2>\n      <p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f698a56160a154a671f0964.png\"  alt=\"261c73238d2ec44b6bbbeaeb2c0dfc8c.png\">\n      </p>\n<ul>\n<li>注意在m方法的栈帧中的局部变量表中，因为不是静态方法，所以第0个是this，第1个是n；</li>\n<li>main方法的栈帧中的局部变量表中，是静态的没有this，第一个是args，第1个是h，第2个是i</li>\n</ul>\n<p>main方法过程</p>\n<ol>\n<li>new出Hello_04对象，之后对象地址压栈，这个时候这里的值是默认值</li>\n<li>此时会有dup指令把这个对象地址在栈顶上再复制一个</li>\n<li>执行InovkeSpecial指令来执行构造方法，此时会把上面复制的对象地址弹出栈。初始化完成</li>\n<li>执行astore_1，赋值给h</li>\n<li>aload_1压栈-&gt;InvokeVirtual调用m方法</li>\n<li>m方法结束后返回一个值放到栈顶-&gt;执行astore_2赋值给i</li>\n<li>结束</li>\n</ol>\n<p>m方法过程</p>\n<ul>\n<li>一个方法对应一个栈帧</li>\n</ul>\n<ol>\n<li>iload_1把3压栈</li>\n<li>iconst_1把这个常量值1压栈，后面作比较使用</li>\n<li>if_icmpne 把两个值进行比较，ne是not equal，不等就跳到第七条指令</li>\n<li>iload_1把3压栈 -&gt;iload_0 this压栈 -&gt; iload_1把3压栈-&gt;iconst_1常量值1压栈</li>\n<li>isub做减法，吧3和1相减放到这</li>\n<li>InvokeVirtual调用m方法（此时是m(2)）<br>.<br>.<br>.</li>\n<li>InvokeVirtual调用m方法（此时是m(1)）</li>\n<li>m(1)方法执行到if_icmpne指令时相等了，此时继续执行5、6指令返回到m(2)方法</li>\n<li>m(2)方法继续向下执行imul指令做乘法（2 * 1），计算完成后返回m(3)</li>\n<li>m(3)方法继续向下执行imul指令做乘法（3 * 2 * 1），计算完成后返回给main方法的i赋值</li>\n</ol>\n","categories":["JVM"],"tags":["JVM"]},{"title":"JMM","url":"/2020/09/22/JMM/","content":"\n        <h1 id=\"JMM\"   >\n          <a href=\"#JMM\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>JMM</h1>\n      \n        <h2 id=\"硬件层数据一致性\"   >\n          <a href=\"#硬件层数据一致性\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>硬件层数据一致性</h2>\n      <p>一致性协议很多,intel 用的是MESI</p>\n<p>现代CPU的数据一致性实现 = 缓存锁(MESI …) + 总线锁</p>\n<p>问题：有了缓存锁还需要总线锁吗？需要，如果需要的数据缓存装不下，此时还是需要锁总线</p>\n<a id=\"more\"></a>\n\n<blockquote>\n<p><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://www.cnblogs.com/z00377750/p/9180644.html\" >https://www.cnblogs.com/z00377750/p/9180644.html</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n</blockquote>\n<p>读取缓存以cache line（缓存行）为基本单位，目前64bytes，位于同一缓存行的两个不同数据，被两个不同CPU锁定，产生互相影响的伪共享问题</p>\n\n        <h3 id=\"伪共享问题\"   >\n          <a href=\"#伪共享问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>伪共享问题</h3>\n      <p>伪共享问题：有两个无关变量x、y位于同一个缓存行，这时CPU1要使用x，就会把这个缓存行加载进来，CPU2要使用y，也会把这个缓存行加载进来，当CPU1对x的值进行改变，此时在CPU2中的这个缓存行状态变为I（Invalid）。CPU2要使用y就需要去重新加载，其实变量y并无改变，此时效率会变低，反之亦然。</p>\n<p>解决方案：<strong>使用缓存行的对齐能够提高效率</strong></p>\n\n        <h2 id=\"乱序问题\"   >\n          <a href=\"#乱序问题\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>乱序问题</h2>\n      <p>CPU为了提高指令执行效率，会在一条指令执行过程中（比如去内存读数据，这时速度相对很慢），去同时执行另一条指令，前提是，两条指令没有依赖关系。这样指令就不会按顺序执行，造成乱序问题</p>\n<p>问题：下图中的Mgr06需不需要加volatile？<br>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6989c5160a154a671eb2d0.png\"  alt=\"cc936e0a540cc9b8ee5affe000d337af.png\">\n      <br>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6989c5160a154a671eb2ce.png\"  alt=\"3fdf5fb1005fb8ce8e9f5408a13ba73d.png\">\n      </p>\n<p>回答：需要加volatile，可能会因为指令重排造成乱序。在多线程情况下，第一个线程进来进行双重检查通过后，对INSTANCE进行初始化，当初始化到一半的时候，此时内存空间已经分配，INSTANCE赋了默认值。这时候第二个线程进来，检查INSTANCE发现不为null就拿走使用了，但此时INSTANCE并未初始化结束，线程二拿走使用的数据是不正确的。所以需要加volatile</p>\n\n        <h2 id=\"如何保证特定情况下不乱序\"   >\n          <a href=\"#如何保证特定情况下不乱序\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>如何保证特定情况下不乱序</h2>\n      \n        <h3 id=\"硬件方面\"   >\n          <a href=\"#硬件方面\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>硬件方面</h3>\n      <ol>\n<li><p>硬件内存屏障 X86 有三条指令</p>\n<ol>\n<li>sfence:  store| 在sfence指令前的写操作当必须在sfence指令后的写操作前完成。</li>\n<li>lfence：load | 在lfence指令前的读操作当必须在lfence指令后的读操作前完成。</li>\n<li>mfence：modify/mix | 在mfence指令前的读写操作当必须在mfence指令后的读写操作前完成。</li>\n</ol>\n</li>\n<li><p>原子指令，如x86上的”lock …” 指令是一个Full Barrier，执行时会锁住内存子系统来确保执行顺序，甚至跨多个CPU。Software Locks通常使用了内存屏障或原子指令来实现变量可见性和保持程序顺序</p>\n</li>\n</ol>\n\n        <h3 id=\"JVM方面\"   >\n          <a href=\"#JVM方面\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>JVM方面</h3>\n      <p>JVM级别如何规范（JSR133），这只是规范，具体实现看jvm</p>\n<ol>\n<li>LoadLoad屏障：<br> 对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</li>\n<li>StoreStore屏障：<br> 对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</li>\n<li>LoadStore屏障：<br> 对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</li>\n<li>StoreLoad屏障：<br>  对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。</li>\n</ol>\n\n        <h3 id=\"volatile的实现细节\"   >\n          <a href=\"#volatile的实现细节\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>volatile的实现细节</h3>\n      <ol>\n<li><p>字节码层面<br> 说白了就是在字节码层面加了一volatile，只是加了一个访问符<strong>ACC_VOLATILE</strong> </p>\n</li>\n<li><p>JVM层面<br> volatile内存区的读写 都加屏障</p>\n<ol>\n<li>写操作前面加StoreStore屏障，后面加StoreLoad屏障</li>\n<li>读操作前面加LoadLoad屏障，后面加LoadStore屏障</li>\n</ol>\n<blockquote>\n<p>StoreStoreBarrier<br>volatile 写操作<br>StoreLoadBarrier</p>\n</blockquote>\n<blockquote>\n<p>LoadLoadBarrier<br>volatile 读操作<br>LoadStoreBarrier</p>\n</blockquote>\n</li>\n<li><p>OS和硬件层面<br>在windows上，lock 指令实现 | MESI实现</p>\n</li>\n</ol>\n\n        <h3 id=\"synchronized实现细节\"   >\n          <a href=\"#synchronized实现细节\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>synchronized实现细节</h3>\n      <ol>\n<li>字节码层面<br> 实际上字节码层面<br> 如果同步语句块，就是<strong>monitorenter monitorexit</strong>指令<br> 如果同步方法，就是加了一个<strong>ACC_SYNCHRONIZED</strong>修饰符</li>\n<li>JVM层面<br>C和C++ 调用了操作系统提供的同步机制</li>\n<li>OS和硬件层面<br>X86 : lock指令</li>\n</ol>\n","categories":["JVM"],"tags":["JVM"]},{"title":"MYSQL performance schema详解","url":"/2020/09/22/MYSQL-performance-schema%E8%AF%A6%E8%A7%A3/","content":"\n        <h1 id=\"MYSQL-performance-schema详解\"   >\n          <a href=\"#MYSQL-performance-schema详解\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>MYSQL performance schema详解</h1>\n      \n        <h2 id=\"performance-schema的介绍\"   >\n          <a href=\"#performance-schema的介绍\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>performance_schema的介绍</h2>\n      <p><strong>MySQL的performance schema 用于监控MySQL server在一个较低级别的运行过程中的资源消耗、资源等待等情况</strong>。</p>\n<p>特点如下：</p>\n<a id=\"more\"></a>\n\n<ol>\n<li>提供了一种在数据库运行时实时检查server的内部执行情况的方法。performance_schema 数据库中的表使用performance_schema存储引擎。该数据库主要关注数据库运行过程中的性能相关的数据，与information_schema不同，information_schema主要关注server运行过程中的元数据信息</li>\n<li>performance_schema通过监视server的事件来实现监视server内部运行情况， “事件”就是server内部活动中所做的任何事情以及对应的时间消耗，利用这些信息来判断server中的相关资源消耗在了哪里？一般来说，事件可以是函数调用、操作系统的等待、SQL语句执行的阶段（如sql语句执行过程中的parsing 或 sorting阶段）或者整个SQL语句与SQL语句集合。事件的采集可以方便的提供server中的相关存储引擎对磁盘文件、表I/O、表锁等资源的同步调用信息。</li>\n<li>performance_schema中的事件与写入二进制日志中的事件（描述数据修改的events）、事件计划调度程序（这是一种存储程序）的事件不同。performance_schema中的事件记录的是server执行某些活动对某些资源的消耗、耗时、这些活动执行的次数等情况。</li>\n<li>performance_schema中的事件只记录在本地server的performance_schema中，其下的这些表中数据发生变化时不会被写入binlog中，也不会通过复制机制被复制到其他server中。</li>\n<li>当前活跃事件、历史事件和事件摘要相关的表中记录的信息。能提供某个事件的执行次数、使用时长。进而可用于分析某个特定线程、特定对象（如mutex或file）相关联的活动。</li>\n<li>PERFORMANCE_SCHEMA存储引擎使用server源代码中的“检测点”来实现事件数据的收集。对于performance_schema实现机制本身的代码没有相关的单独线程来检测，这与其他功能（如复制或事件计划程序）不同</li>\n<li>收集的事件数据存储在performance_schema数据库的表中。这些表可以使用SELECT语句查询，也可以使用SQL语句更新performance_schema数据库中的表记录（如动态修改performance_schema的setup_* 开头的几个配置表，但要注意：配置表的更改会立即生效，这会影响数据收集）</li>\n<li>performance_schema的表中的数据不会持久化存储在磁盘中，而是保存在内存中，一旦服务器重启，这些数据会丢失（包括配置表在内的整个performance_schema下的所有数据）</li>\n<li>MySQL支持的所有平台中事件监控功能都可用，但不同平台中用于统计事件时间开销的计时器类型可能会有所差异。</li>\n</ol>\n\n        <h2 id=\"performance-schema入门\"   >\n          <a href=\"#performance-schema入门\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>performance schema入门</h2>\n      <p>在mysql的5.7版本中，性能模式是默认开启的，如果想要显式的关闭的话需要修改配置文件，不能直接进行修改，会报错Variable ‘performance_schema’ is a read only variable。</p>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--查看performance_schema的属性</span></span><br><span class=\"line\">mysql&gt; SHOW VARIABLES LIKE &#x27;performance_schema&#x27;;</span><br><span class=\"line\">+<span class=\"comment\">--------------------+-------+</span></span><br><span class=\"line\">| Variable_name      | Value |</span><br><span class=\"line\">+<span class=\"comment\">--------------------+-------+</span></span><br><span class=\"line\">| performance_schema | ON    |</span><br><span class=\"line\">+<span class=\"comment\">--------------------+-------+</span></span><br><span class=\"line\">1 row in <span class=\"keyword\">set</span> (<span class=\"number\">0.01</span> sec)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--在配置文件中修改performance_schema的属性值，on表示开启，off表示关闭</span></span><br><span class=\"line\">[mysqld]</span><br><span class=\"line\">performance_schema=<span class=\"keyword\">ON</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--切换数据库</span></span><br><span class=\"line\"><span class=\"keyword\">use</span> performance_schema;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--查看当前数据库下的所有表,会看到有很多表存储着相关的信息</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">tables</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--可以通过show create table tablename来查看创建表的时候的表结构</span></span><br><span class=\"line\">mysql&gt; show create table setup_consumers;</span><br><span class=\"line\">+<span class=\"comment\">-----------------+---------------------------------</span></span><br><span class=\"line\">| Table           | <span class=\"keyword\">Create</span> <span class=\"keyword\">Table</span>                    </span><br><span class=\"line\">+<span class=\"comment\">-----------------+---------------------------------</span></span><br><span class=\"line\">| setup_consumers | <span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`setup_consumers`</span> (</span><br><span class=\"line\">  <span class=\"string\">`NAME`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">64</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,                      </span><br><span class=\"line\">  <span class=\"string\">`ENABLED`</span> enum(<span class=\"string\">&#x27;YES&#x27;</span>,<span class=\"string\">&#x27;NO&#x27;</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>               </span><br><span class=\"line\">) <span class=\"keyword\">ENGINE</span>=PERFORMANCE_SCHEMA <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8 |  </span><br><span class=\"line\">+<span class=\"comment\">-----------------+---------------------------------</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"keyword\">row</span> <span class=\"keyword\">in</span> <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)                             </span><br></pre></td></tr></table></div></figure>\n\n<p>想要搞明白后续的内容，需要理解两个基本概念：</p>\n<p>instruments: 生产者，用于采集mysql中各种各样的操作产生的事件信息，对应配置表中的配置项我们可以称为监控采集配置项。</p>\n<p>consumers:消费者，对应的消费者表用于存储来自instruments采集的数据，对应配置表中的配置项我们可以称为消费存储配置项。</p>\n\n        <h2 id=\"performance-schema表的分类\"   >\n          <a href=\"#performance-schema表的分类\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>performance_schema表的分类</h2>\n      <p>performance_schema库下的表可以按照监视不同的纬度就行分组。</p>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--语句事件记录表，这些表记录了语句事件信息，当前语句事件表events_statements_current、历史语句事件表events_statements_history和长语句历史事件表events_statements_history_long、以及聚合后的摘要表summary，其中，summary表还可以根据帐号(account)，主机(host)，程序(program)，线程(thread)，用户(user)和全局(global)再进行细分)</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">tables</span> <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%statement%&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--等待事件记录表，与语句事件类型的相关记录表类似：</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">tables</span> <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%wait%&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--阶段事件记录表，记录语句执行的阶段事件的表</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">tables</span> <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%stage%&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--事务事件记录表，记录事务相关的事件的表</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">tables</span> <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%transaction%&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--监控文件系统层调用的表</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">tables</span> <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%file%&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--监视内存使用的表</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">tables</span> <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%memory%&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--动态对performance_schema进行配置的配置表</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">tables</span> <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%setup%&#x27;</span>;</span><br></pre></td></tr></table></div></figure>\n\n\n        <h2 id=\"performance-schema的简单配置与使用\"   >\n          <a href=\"#performance-schema的简单配置与使用\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>performance_schema的简单配置与使用</h2>\n      <p>数据库刚刚初始化并启动时，并非所有instruments(事件采集项，在采集项的配置表中每一项都有一个开关字段，或为YES，或为NO)和consumers(与采集项类似，也有一个对应的事件类型保存表配置项，为YES就表示对应的表保存性能数据，为NO就表示对应的表不保存性能数据)都启用了，所以默认不会收集所有的事件，可能你需要检测的事件并没有打开，需要进行设置，可以使用如下两个语句打开对应的instruments和consumers（行计数可能会因MySQL版本而异)。</p>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--打开等待事件的采集器配置项开关，需要修改setup_instruments配置表中对应的采集器配置项</span></span><br><span class=\"line\"><span class=\"keyword\">UPDATE</span> setup_instruments <span class=\"keyword\">SET</span> ENABLED = <span class=\"string\">&#x27;YES&#x27;</span>, TIMED = <span class=\"string\">&#x27;YES&#x27;</span><span class=\"keyword\">where</span> <span class=\"keyword\">name</span> <span class=\"keyword\">like</span> <span class=\"string\">&#x27;wait%&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--打开等待事件的保存表配置开关，修改setup_consumers配置表中对应的配置项</span></span><br><span class=\"line\"><span class=\"keyword\">UPDATE</span> setup_consumers <span class=\"keyword\">SET</span> ENABLED = <span class=\"string\">&#x27;YES&#x27;</span><span class=\"keyword\">where</span> <span class=\"keyword\">name</span> <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%wait%&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--当配置完成之后可以查看当前server正在做什么，可以通过查询events_waits_current表来得知，该表中每个线程只包含一行数据，用于显示每个线程的最新监视事件</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> events_waits_current\\G</span><br><span class=\"line\">*************************** <span class=\"number\">1.</span> <span class=\"keyword\">row</span> ***************************</span><br><span class=\"line\">            THREAD_ID: <span class=\"number\">11</span></span><br><span class=\"line\">             EVENT_ID: <span class=\"number\">570</span></span><br><span class=\"line\">         END_EVENT_ID: <span class=\"number\">570</span></span><br><span class=\"line\">           EVENT_NAME: <span class=\"keyword\">wait</span>/synch/<span class=\"keyword\">mutex</span>/<span class=\"keyword\">innodb</span>/buf_dblwr_mutex</span><br><span class=\"line\">               <span class=\"keyword\">SOURCE</span>: </span><br><span class=\"line\">          TIMER_START: <span class=\"number\">4508505105239280</span></span><br><span class=\"line\">            TIMER_END: <span class=\"number\">4508505105270160</span></span><br><span class=\"line\">           TIMER_WAIT: <span class=\"number\">30880</span></span><br><span class=\"line\">                SPINS: <span class=\"literal\">NULL</span></span><br><span class=\"line\">        OBJECT_SCHEMA: <span class=\"literal\">NULL</span></span><br><span class=\"line\">          OBJECT_NAME: <span class=\"literal\">NULL</span></span><br><span class=\"line\">           INDEX_NAME: <span class=\"literal\">NULL</span></span><br><span class=\"line\">          OBJECT_TYPE: <span class=\"literal\">NULL</span></span><br><span class=\"line\">OBJECT_INSTANCE_BEGIN: <span class=\"number\">67918392</span></span><br><span class=\"line\">     NESTING_EVENT_ID: <span class=\"literal\">NULL</span></span><br><span class=\"line\">   NESTING_EVENT_TYPE: <span class=\"literal\">NULL</span></span><br><span class=\"line\">            OPERATION: <span class=\"keyword\">lock</span></span><br><span class=\"line\">      NUMBER_OF_BYTES: <span class=\"literal\">NULL</span></span><br><span class=\"line\">                FLAGS: <span class=\"literal\">NULL</span></span><br><span class=\"line\"><span class=\"comment\">/*该信息表示线程id为11的线程正在等待buf_dblwr_mutex锁，等待事件为30880</span></span><br><span class=\"line\"><span class=\"comment\">属性说明：</span></span><br><span class=\"line\"><span class=\"comment\">\tid:事件来自哪个线程，事件编号是多少</span></span><br><span class=\"line\"><span class=\"comment\">\tevent_name:表示检测到的具体的内容</span></span><br><span class=\"line\"><span class=\"comment\">\tsource:表示这个检测代码在哪个源文件中以及行号</span></span><br><span class=\"line\"><span class=\"comment\">\ttimer_start:表示该事件的开始时间</span></span><br><span class=\"line\"><span class=\"comment\">\ttimer_end:表示该事件的结束时间</span></span><br><span class=\"line\"><span class=\"comment\">\ttimer_wait:表示该事件总的花费时间</span></span><br><span class=\"line\"><span class=\"comment\">注意：_current表中每个线程只保留一条记录，一旦线程完成工作，该表中不会再记录该线程的事件信息</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">_history表中记录每个线程应该执行完成的事件信息，但每个线程的事件信息只会记录10条，再多就会被覆盖，*_history_long表中记录所有线程的事件信息，但总记录数量是10000，超过就会被覆盖掉</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> thread_id,event_id,event_name,timer_wait <span class=\"keyword\">from</span> events_waits_history <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> thread_id <span class=\"keyword\">limit</span> <span class=\"number\">21</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">summary表提供所有事件的汇总信息，该组中的表以不同的方式汇总事件数据（如：按用户，按主机，按线程等等）。例如：要查看哪些instruments占用最多的时间，可以通过对events_waits_summary_global_by_event_name表的COUNT_STAR或SUM_TIMER_WAIT列进行查询（这两列是对事件的记录数执行COUNT（*）、事件记录的TIMER_WAIT列执行SUM（TIMER_WAIT）统计而来）</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> EVENT_NAME,COUNT_STAR <span class=\"keyword\">FROM</span> events_waits_summary_global_by_event_name  <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> COUNT_STAR <span class=\"keyword\">DESC</span> <span class=\"keyword\">LIMIT</span> <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">instance表记录了哪些类型的对象会被检测。这些对象在被server使用时，在该表中将会产生一条事件记录，例如，file_instances表列出了文件I/O操作及其关联文件名</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> file_instances <span class=\"keyword\">limit</span> <span class=\"number\">20</span>; </span><br></pre></td></tr></table></div></figure>\n\n\n        <h2 id=\"常用配置项的参数说明\"   >\n          <a href=\"#常用配置项的参数说明\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>常用配置项的参数说明</h2>\n      <ol>\n<li>启动选项</li>\n</ol>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\">performance_schema_consumer_events_statements_current=TRUE</span><br><span class=\"line\">是否在mysql server启动时就开启events_statements_current表的记录功能(该表记录当前的语句事件信息)，启动之后也可以在setup_consumers表中使用<span class=\"keyword\">UPDATE</span>语句进行动态更新setup_consumers配置表中的events_statements_current配置项，默认值为<span class=\"literal\">TRUE</span></span><br><span class=\"line\"></span><br><span class=\"line\">performance_schema_consumer_events_statements_history=<span class=\"literal\">TRUE</span></span><br><span class=\"line\">与performance_schema_consumer_events_statements_current选项类似，但该选项是用于配置是否记录语句事件短历史信息，默认为<span class=\"literal\">TRUE</span></span><br><span class=\"line\"></span><br><span class=\"line\">performance_schema_consumer_events_stages_history_long=<span class=\"literal\">FALSE</span></span><br><span class=\"line\">与performance_schema_consumer_events_statements_current选项类似，但该选项是用于配置是否记录语句事件长历史信息，默认为<span class=\"literal\">FALSE</span></span><br><span class=\"line\"></span><br><span class=\"line\">除了<span class=\"keyword\">statement</span>(语句)事件之外，还支持：<span class=\"keyword\">wait</span>(等待)事件、state(阶段)事件、<span class=\"keyword\">transaction</span>(事务)事件，他们与<span class=\"keyword\">statement</span>事件一样都有三个启动项分别进行配置，但这些等待事件默认未启用，如果需要在MySQL <span class=\"keyword\">Server</span>启动时一同启动，则通常需要写进my.cnf配置文件中</span><br><span class=\"line\">performance_schema_consumer_global_instrumentation=<span class=\"literal\">TRUE</span></span><br><span class=\"line\">是否在MySQL <span class=\"keyword\">Server</span>启动时就开启全局表（如：mutex_instances、rwlock_instances、cond_instances、file_instances、<span class=\"keyword\">users</span>、hostsaccounts、socket_summary_by_event_name、file_summary_by_instance等大部分的全局对象计数统计和事件汇总统计信息表 ）的记录功能，启动之后也可以在setup_consumers表中使用<span class=\"keyword\">UPDATE</span>语句进行动态更新全局配置项</span><br><span class=\"line\">默认值为<span class=\"literal\">TRUE</span></span><br><span class=\"line\"></span><br><span class=\"line\">performance_schema_consumer_statements_digest=<span class=\"literal\">TRUE</span></span><br><span class=\"line\">是否在MySQL <span class=\"keyword\">Server</span>启动时就开启events_statements_summary_by_digest 表的记录功能，启动之后也可以在setup_consumers表中使用<span class=\"keyword\">UPDATE</span>语句进行动态更新digest配置项</span><br><span class=\"line\">默认值为<span class=\"literal\">TRUE</span></span><br><span class=\"line\"></span><br><span class=\"line\">performance_schema_consumer_thread_instrumentation=<span class=\"literal\">TRUE</span></span><br><span class=\"line\">是否在MySQL <span class=\"keyword\">Server</span>启动时就开启</span><br><span class=\"line\"></span><br><span class=\"line\">events_xxx_summary_by_yyy_by_event_name表的记录功能，启动之后也可以在setup_consumers表中使用<span class=\"keyword\">UPDATE</span>语句进行动态更新线程配置项</span><br><span class=\"line\">默认值为<span class=\"literal\">TRUE</span></span><br><span class=\"line\"></span><br><span class=\"line\">performance_schema_instrument[=<span class=\"keyword\">name</span>]</span><br><span class=\"line\">是否在MySQL <span class=\"keyword\">Server</span>启动时就启用某些采集器，由于instruments配置项多达数千个，所以该配置项支持<span class=\"keyword\">key</span>-<span class=\"keyword\">value</span>模式，还支持%号进行通配等，如下:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># [=name]可以指定为具体的Instruments名称（但是这样如果有多个需要指定的时候，就需要使用该选项多次），也可以使用通配符，可以指定instruments相同的前缀+通配符，也可以使用%代表所有的instruments</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 指定开启单个instruments</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--performance-schema-instrument= &#x27;instrument_name=value&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 使用通配符指定开启多个instruments</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--performance-schema-instrument= &#x27;wait/synch/cond/%=COUNTED&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 开关所有的instruments</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--performance-schema-instrument= &#x27;%=ON&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--performance-schema-instrument= &#x27;%=OFF&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">注意，这些启动选项要生效的前提是，需要设置performance_schema=<span class=\"keyword\">ON</span>。另外，这些启动选项虽然无法使用<span class=\"keyword\">show</span> <span class=\"keyword\">variables</span>语句查看，但我们可以通过setup_instruments和setup_consumers表查询这些选项指定的值。</span><br></pre></td></tr></table></div></figure>\n\n<ol start=\"2\">\n<li>系统变量</li>\n</ol>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">variables</span> <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%performance_schema%&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">--重要的属性解释</span></span><br><span class=\"line\">performance_schema=ON</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">控制performance_schema功能的开关，要使用MySQL的performance_schema，需要在mysqld启动时启用，以启用事件收集功能</span></span><br><span class=\"line\"><span class=\"comment\">该参数在5.7.x之前支持performance_schema的版本中默认关闭，5.7.x版本开始默认开启</span></span><br><span class=\"line\"><span class=\"comment\">注意：如果mysqld在初始化performance_schema时发现无法分配任何相关的内部缓冲区，则performance_schema将自动禁用，并将performance_schema设置为OFF</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">performance_schema_digests_size=10000</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">控制events_statements_summary_by_digest表中的最大行数。如果产生的语句摘要信息超过此最大值，便无法继续存入该表，此时performance_schema会增加状态变量</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">performance_schema_events_statements_history_long_size=10000</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">控制events_statements_history_long表中的最大行数，该参数控制所有会话在events_statements_history_long表中能够存放的总事件记录数，超过这个限制之后，最早的记录将被覆盖</span></span><br><span class=\"line\"><span class=\"comment\">全局变量，只读变量，整型值，5.6.3版本引入 * 5.6.x版本中，5.6.5及其之前的版本默认为10000，5.6.6及其之后的版本默认值为-1，通常情况下，自动计算的值都是10000 * 5.7.x版本中，默认值为-1，通常情况下，自动计算的值都是10000</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">performance_schema_events_statements_history_size=10</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">控制events_statements_history表中单个线程（会话）的最大行数，该参数控制单个会话在events_statements_history表中能够存放的事件记录数，超过这个限制之后，单个会话最早的记录将被覆盖</span></span><br><span class=\"line\"><span class=\"comment\">全局变量，只读变量，整型值，5.6.3版本引入 * 5.6.x版本中，5.6.5及其之前的版本默认为10，5.6.6及其之后的版本默认值为-1，通常情况下，自动计算的值都是10 * 5.7.x版本中，默认值为-1，通常情况下，自动计算的值都是10</span></span><br><span class=\"line\"><span class=\"comment\">除了statement(语句)事件之外，wait(等待)事件、state(阶段)事件、transaction(事务)事件，他们与statement事件一样都有三个参数分别进行存储限制配置，有兴趣的自行研究，这里不再赘述</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">performance_schema_max_digest_length=1024</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">用于控制标准化形式的SQL语句文本在存入performance_schema时的限制长度，该变量与max_digest_length变量相关(max_digest_length变量含义请自行查阅相关资料)</span></span><br><span class=\"line\"><span class=\"comment\">全局变量，只读变量，默认值1024字节，整型值，取值范围0~1048576</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">performance_schema_max_sql_text_length=1024</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">控制存入events_statements_current，events_statements_history和events_statements_history_long语句事件表中的SQL_TEXT列的最大SQL长度字节数。 超出系统变量performance_schema_max_sql_text_length的部分将被丢弃，不会记录，一般情况下不需要调整该参数，除非被截断的部分与其他SQL比起来有很大差异</span></span><br><span class=\"line\"><span class=\"comment\">全局变量，只读变量，整型值，默认值为1024字节，取值范围为0~1048576，5.7.6版本引入</span></span><br><span class=\"line\"><span class=\"comment\">降低系统变量performance_schema_max_sql_text_length值可以减少内存使用，但如果汇总的SQL中，被截断部分有较大差异，会导致没有办法再对这些有较大差异的SQL进行区分。 增加该系统变量值会增加内存使用，但对于汇总SQL来讲可以更精准地区分不同的部分。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></div></figure>\n\n\n        <h2 id=\"重要配置表的相关说明\"   >\n          <a href=\"#重要配置表的相关说明\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>重要配置表的相关说明</h2>\n      <p>配置表之间存在相互关联关系，按照配置影响的先后顺序，可添加为</p>\n<p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://wx2.sbimg.cn/2020/09/22/GJvuk.png\"  alt=\"a\">\n      </p>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">performance_timers表中记录了server中有哪些可用的事件计时器</span></span><br><span class=\"line\"><span class=\"comment\">字段解释：</span></span><br><span class=\"line\"><span class=\"comment\">\ttimer_name:表示可用计时器名称，CYCLE是基于CPU周期计数器的定时器</span></span><br><span class=\"line\"><span class=\"comment\">\ttimer_frequency:表示每秒钟对应的计时器单位的数量,CYCLE计时器的换算值与CPU的频率相关、</span></span><br><span class=\"line\"><span class=\"comment\">\ttimer_resolution:计时器精度值，表示在每个计时器被调用时额外增加的值</span></span><br><span class=\"line\"><span class=\"comment\">\ttimer_overhead:表示在使用定时器获取事件时开销的最小周期值</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> performance_timers;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">setup_timers表中记录当前使用的事件计时器信息</span></span><br><span class=\"line\"><span class=\"comment\">字段解释：</span></span><br><span class=\"line\"><span class=\"comment\">\tname:计时器类型，对应某个事件类别</span></span><br><span class=\"line\"><span class=\"comment\">\ttimer_name:计时器类型名称</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> setup_timers;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">setup_consumers表中列出了consumers可配置列表项</span></span><br><span class=\"line\"><span class=\"comment\">字段解释：</span></span><br><span class=\"line\"><span class=\"comment\">\tNAME：consumers配置名称</span></span><br><span class=\"line\"><span class=\"comment\">\tENABLED：consumers是否启用，有效值为YES或NO，此列可以使用UPDATE语句修改。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> setup_consumers;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">setup_instruments 表列出了instruments 列表配置项，即代表了哪些事件支持被收集：</span></span><br><span class=\"line\"><span class=\"comment\">字段解释：</span></span><br><span class=\"line\"><span class=\"comment\">\tNAME：instruments名称，instruments名称可能具有多个部分并形成层次结构</span></span><br><span class=\"line\"><span class=\"comment\">\tENABLED：instrumetns是否启用，有效值为YES或NO，此列可以使用UPDATE语句修改。如果设置为NO，则这个instruments不会被执行，不会产生任何的事件信息</span></span><br><span class=\"line\"><span class=\"comment\">\tTIMED：instruments是否收集时间信息，有效值为YES或NO，此列可以使用UPDATE语句修改，如果设置为NO，则这个instruments不会收集时间信息</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> setup_instruments;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">setup_actors表的初始内容是匹配任何用户和主机，因此对于所有前台线程，默认情况下启用监视和历史事件收集功能</span></span><br><span class=\"line\"><span class=\"comment\">字段解释：</span></span><br><span class=\"line\"><span class=\"comment\">\tHOST：与grant语句类似的主机名，一个具体的字符串名字，或使用“％”表示“任何主机”</span></span><br><span class=\"line\"><span class=\"comment\">\tUSER：一个具体的字符串名称，或使用“％”表示“任何用户”</span></span><br><span class=\"line\"><span class=\"comment\">\tROLE：当前未使用，MySQL 8.0中才启用角色功能</span></span><br><span class=\"line\"><span class=\"comment\">\tENABLED：是否启用与HOST，USER，ROLE匹配的前台线程的监控功能，有效值为：YES或NO</span></span><br><span class=\"line\"><span class=\"comment\">\tHISTORY：是否启用与HOST， USER，ROLE匹配的前台线程的历史事件记录功能，有效值为：YES或NO</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> setup_actors;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">setup_objects表控制performance_schema是否监视特定对象。默认情况下，此表的最大行数为100行。</span></span><br><span class=\"line\"><span class=\"comment\">字段解释：</span></span><br><span class=\"line\"><span class=\"comment\">\tOBJECT_TYPE：instruments类型，有效值为：“EVENT”（事件调度器事件）、“FUNCTION”（存储函数）、“PROCEDURE”（存储过程）、“TABLE”（基表）、“TRIGGER”（触发器），TABLE对象类型的配置会影响表I/O事件（wait/io/table/sql/handler instrument）和表锁事件（wait/lock/table/sql/handler instrument）的收集</span></span><br><span class=\"line\"><span class=\"comment\">\tOBJECT_SCHEMA：某个监视类型对象涵盖的数据库名称，一个字符串名称，或“％”(表示“任何数据库”)</span></span><br><span class=\"line\"><span class=\"comment\">\tOBJECT_NAME：某个监视类型对象涵盖的表名，一个字符串名称，或“％”(表示“任何数据库内的对象”)</span></span><br><span class=\"line\"><span class=\"comment\">\tENABLED：是否开启对某个类型对象的监视功能，有效值为：YES或NO。此列可以修改</span></span><br><span class=\"line\"><span class=\"comment\">\tTIMED：是否开启对某个类型对象的时间收集功能，有效值为：YES或NO，此列可以修改</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> setup_objects;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">threads表对于每个server线程生成一行包含线程相关的信息，</span></span><br><span class=\"line\"><span class=\"comment\">字段解释：</span></span><br><span class=\"line\"><span class=\"comment\">\tTHREAD_ID：线程的唯一标识符（ID）</span></span><br><span class=\"line\"><span class=\"comment\">\tNAME：与server中的线程检测代码相关联的名称(注意，这里不是instruments名称)</span></span><br><span class=\"line\"><span class=\"comment\">\tTYPE：线程类型，有效值为：FOREGROUND、BACKGROUND。分别表示前台线程和后台线程</span></span><br><span class=\"line\"><span class=\"comment\">\tPROCESSLIST_ID：对应INFORMATION_SCHEMA.PROCESSLIST表中的ID列。</span></span><br><span class=\"line\"><span class=\"comment\">\tPROCESSLIST_USER：与前台线程相关联的用户名，对于后台线程为NULL。</span></span><br><span class=\"line\"><span class=\"comment\">\tPROCESSLIST_HOST：与前台线程关联的客户端的主机名，对于后台线程为NULL。</span></span><br><span class=\"line\"><span class=\"comment\">\tPROCESSLIST_DB：线程的默认数据库，如果没有，则为NULL。</span></span><br><span class=\"line\"><span class=\"comment\">\tPROCESSLIST_COMMAND：对于前台线程，该值代表着当前客户端正在执行的command类型，如果是sleep则表示当前会话处于空闲状态</span></span><br><span class=\"line\"><span class=\"comment\">\tPROCESSLIST_TIME：当前线程已处于当前线程状态的持续时间（秒）</span></span><br><span class=\"line\"><span class=\"comment\">\tPROCESSLIST_STATE：表示线程正在做什么事情。</span></span><br><span class=\"line\"><span class=\"comment\">\tPROCESSLIST_INFO：线程正在执行的语句，如果没有执行任何语句，则为NULL。</span></span><br><span class=\"line\"><span class=\"comment\">\tPARENT_THREAD_ID：如果这个线程是一个子线程（由另一个线程生成），那么该字段显示其父线程ID</span></span><br><span class=\"line\"><span class=\"comment\">\tROLE：暂未使用</span></span><br><span class=\"line\"><span class=\"comment\">\tINSTRUMENTED：线程执行的事件是否被检测。有效值：YES、NO </span></span><br><span class=\"line\"><span class=\"comment\">\tHISTORY：是否记录线程的历史事件。有效值：YES、NO * </span></span><br><span class=\"line\"><span class=\"comment\">\tTHREAD_OS_ID：由操作系统层定义的线程或任务标识符（ID）：</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> threads</span><br></pre></td></tr></table></div></figure>\n\n<p>注意：在performance_schema库中还包含了很多其他的库和表，能对数据库的性能做完整的监控，大家需要参考官网详细了解。</p>\n\n        <h2 id=\"performance-schema实践操作\"   >\n          <a href=\"#performance-schema实践操作\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>performance_schema实践操作</h2>\n      <p>基本了解了表的相关信息之后，可以通过这些表进行实际的查询操作来进行实际的分析。</p>\n<figure class=\"highlight sql\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--1、哪类的SQL执行最多？</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> DIGEST_TEXT,COUNT_STAR,FIRST_SEEN,LAST_SEEN <span class=\"keyword\">FROM</span> events_statements_summary_by_digest <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> COUNT_STAR <span class=\"keyword\">DESC</span></span><br><span class=\"line\"><span class=\"comment\">--2、哪类SQL的平均响应时间最多？</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> DIGEST_TEXT,AVG_TIMER_WAIT <span class=\"keyword\">FROM</span> events_statements_summary_by_digest <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> COUNT_STAR <span class=\"keyword\">DESC</span></span><br><span class=\"line\"><span class=\"comment\">--3、哪类SQL排序记录数最多？</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> DIGEST_TEXT,SUM_SORT_ROWS <span class=\"keyword\">FROM</span> events_statements_summary_by_digest <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> COUNT_STAR <span class=\"keyword\">DESC</span></span><br><span class=\"line\"><span class=\"comment\">--4、哪类SQL扫描记录数最多？</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> DIGEST_TEXT,SUM_ROWS_EXAMINED <span class=\"keyword\">FROM</span> events_statements_summary_by_digest <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> COUNT_STAR <span class=\"keyword\">DESC</span></span><br><span class=\"line\"><span class=\"comment\">--5、哪类SQL使用临时表最多？</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> DIGEST_TEXT,SUM_CREATED_TMP_TABLES,SUM_CREATED_TMP_DISK_TABLES <span class=\"keyword\">FROM</span> events_statements_summary_by_digest <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> COUNT_STAR <span class=\"keyword\">DESC</span></span><br><span class=\"line\"><span class=\"comment\">--6、哪类SQL返回结果集最多？</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> DIGEST_TEXT,SUM_ROWS_SENT <span class=\"keyword\">FROM</span> events_statements_summary_by_digest <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> COUNT_STAR <span class=\"keyword\">DESC</span></span><br><span class=\"line\"><span class=\"comment\">--7、哪个表物理IO最多？</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> file_name,event_name,SUM_NUMBER_OF_BYTES_READ,SUM_NUMBER_OF_BYTES_WRITE <span class=\"keyword\">FROM</span> file_summary_by_instance <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> SUM_NUMBER_OF_BYTES_READ + SUM_NUMBER_OF_BYTES_WRITE <span class=\"keyword\">DESC</span></span><br><span class=\"line\"><span class=\"comment\">--8、哪个表逻辑IO最多？</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> object_name,COUNT_READ,COUNT_WRITE,COUNT_FETCH,SUM_TIMER_WAIT <span class=\"keyword\">FROM</span> table_io_waits_summary_by_table <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> sum_timer_wait <span class=\"keyword\">DESC</span></span><br><span class=\"line\"><span class=\"comment\">--9、哪个索引访问最多？</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> OBJECT_NAME,INDEX_NAME,COUNT_FETCH,COUNT_INSERT,COUNT_UPDATE,COUNT_DELETE <span class=\"keyword\">FROM</span> table_io_waits_summary_by_index_usage <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> SUM_TIMER_WAIT <span class=\"keyword\">DESC</span></span><br><span class=\"line\"><span class=\"comment\">--10、哪个索引从来没有用过？</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> OBJECT_SCHEMA,OBJECT_NAME,INDEX_NAME <span class=\"keyword\">FROM</span> table_io_waits_summary_by_index_usage <span class=\"keyword\">WHERE</span> INDEX_NAME <span class=\"keyword\">IS</span> <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> <span class=\"keyword\">AND</span> COUNT_STAR = <span class=\"number\">0</span> <span class=\"keyword\">AND</span> OBJECT_SCHEMA &lt;&gt; <span class=\"string\">&#x27;mysql&#x27;</span> <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> OBJECT_SCHEMA,OBJECT_NAME;</span><br><span class=\"line\"><span class=\"comment\">--11、哪个等待事件消耗时间最多？</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> EVENT_NAME,COUNT_STAR,SUM_TIMER_WAIT,AVG_TIMER_WAIT <span class=\"keyword\">FROM</span> events_waits_summary_global_by_event_name <span class=\"keyword\">WHERE</span> event_name != <span class=\"string\">&#x27;idle&#x27;</span> <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> SUM_TIMER_WAIT <span class=\"keyword\">DESC</span></span><br><span class=\"line\"><span class=\"comment\">--12-1、剖析某条SQL的执行情况，包括statement信息，stege信息，wait信息</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> EVENT_ID,sql_text <span class=\"keyword\">FROM</span> events_statements_history <span class=\"keyword\">WHERE</span> sql_text <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;%count(*)%&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">--12-2、查看每个阶段的时间消耗</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> event_id,EVENT_NAME,<span class=\"keyword\">SOURCE</span>,TIMER_END - TIMER_START <span class=\"keyword\">FROM</span> events_stages_history_long <span class=\"keyword\">WHERE</span> NESTING_EVENT_ID = <span class=\"number\">1553</span>;</span><br><span class=\"line\"><span class=\"comment\">--12-3、查看每个阶段的锁等待情况</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> event_id,event_name,<span class=\"keyword\">source</span>,timer_wait,object_name,index_name,operation,nesting_event_id <span class=\"keyword\">FROM</span> events_waits_history_longWHERE nesting_event_id = <span class=\"number\">1553</span>;</span><br></pre></td></tr></table></div></figure>","categories":["MySQL"],"tags":["MySQL","MySQL调优"]},{"title":"Class加载过程","url":"/2020/09/16/Class%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/","content":"\n        <h1 id=\"class加载过程\"   >\n          <a href=\"#class加载过程\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>class加载过程</h1>\n      <p>有一个class文件在硬盘，需要怎样的过程才能加载到内存中？</p>\n<ol>\n<li>Loading</li>\n<li>Linking</li>\n<li>Initializing</li>\n</ol>\n<a id=\"more\"></a>\n\n<hr>\n<ol>\n<li>Loading是把class文件装载到内存中</li>\n<li>Linking分为三步<ol>\n<li>Verification 验证文件是否符合JVM规定</li>\n<li>Preparation  静态成员变量赋<strong>默认值</strong></li>\n<li>Resolution  将类、方法、属性等符号引用解析为直接引用；常量池中的各种符号引用解析为指针、偏移量等内存地址的直接引用</li>\n</ol>\n</li>\n<li>Initializing 调用类初始化代码 <clinit>，给静态成员变量赋初始值</li>\n</ol>\n<p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f698927160a154a671e4aed.png\"  alt=\"2f421b5c7a9aeb1f217a248523422f57.png\">\n      </p>\n\n        <h2 id=\"Loading\"   >\n          <a href=\"#Loading\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Loading</h2>\n      <p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f698927160a154a671e4acc.png\"  alt=\"b05863bf80d05571f5e4fe0fba85b3c9.png\">\n      </p>\n<p>不同的加载器负责加载不同的class</p>\n<ol>\n<li>BootStrap 加载lib里jdk最核心的内容，比如rt.jar charset.jar。当调用getClassLoader()为null的时候，代表到达了最顶层的加载器</li>\n<li>Extension 加载器拓展类，加载jre/lib/ext目录下拓展包的内容</li>\n<li>Application 加载classpath指定内容</li>\n<li>自定义加载器ClassLoader（Custom ClassLoader），加载自定义的加载器</li>\n</ol>\n<p><u><strong>注意：父加载器不是“类加载器的加载器”，也不是“类加载器的父类加载器”</strong></u></p>\n\n        <h3 id=\"双亲委派\"   >\n          <a href=\"#双亲委派\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>双亲委派</h3>\n      <p>一个class文件需要被load内存时候是这样的<br>任何一个class，假如自定义了ClassLoader，就先尝试去自定义的内部缓存里面找，如果加载进来就返回，不需要加载第二遍。如果没找到，也并不是直接去加载，而是去他的父亲application父加载器，说爸爸你有没有把这个类加载进来，这时候application就会去他的缓存里面找有没有这个类，如果有返回，如果没有委托给他的父亲 Extension，如果有返回，如果没有委托给他的父亲 Bootstrap有就返回，如果都没有就往回再委托。说Extension我这没有你去加载， Extension说我只负责我扩展jar包部分，你的类我找不到，application去加载，application说我只负责加载classpath指定内容，其他的找不到，然后委托ClassLoader去找，整个过程是转了一圈，才真正把这个类加载进来，当我们能够把这个类加载进来的时候成功返回，如果加载不进来，抛ClassNotfound异常。这就叫做双亲委派。</p>\n\n        <h4 id=\"为什么要使用双亲委派？\"   >\n          <a href=\"#为什么要使用双亲委派？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>为什么要使用双亲委派？</h4>\n      <ol>\n<li>安全问题</li>\n<li>减少资源浪费，加载过得不需要再加载一遍</li>\n</ol>\n<p>解释：<br>如果任何一个class都可以load进内存，那我可以自定义一个java.lang.String交给自定义的类加载器加载到内存，打包给客户，然后客户只要使用String存储敏感信息，都可以暗中发送给我。因为自定义的，想干什么都可以，不安全。<br>使用双亲委派就可以避免这个问题，当自定义加载器加载java.lang.String的时候，会向上面查又没有加载过，加载过直接返回，不会再次加载。</p>\n\n        <h4 id=\"打破双亲委派机制\"   >\n          <a href=\"#打破双亲委派机制\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>打破双亲委派机制</h4>\n      <ol>\n<li>重写loadClass（）方法</li>\n<li>何时打破过？<ol>\n<li>JDK1.2之前，自定义ClassLoader都必须重写loadClass()</li>\n<li>ThreadContextClassLoader可以实现基础类调用实现类代码，通过thread.setContextClassLoader指定</li>\n<li>热启动，热部署<ul>\n<li>osgi tomcat 都有自己的模块指定classloader（可以加载同一类库的不同版本）</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n\n        <h3 id=\"自定义类加载器\"   >\n          <a href=\"#自定义类加载器\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>自定义类加载器</h3>\n      <ol>\n<li>继承ClassLoader</li>\n<li>重写模板方法findClass<ul>\n<li>调用defindClass （将二进制流转换为class对象并返回）</li>\n</ul>\n</li>\n<li>自定义类加载器加载自加密的class（可有可无）<ul>\n<li>防止反编译 防止篡改</li>\n</ul>\n</li>\n</ol>\n\n        <h3 id=\"Classloader源码解析\"   >\n          <a href=\"#Classloader源码解析\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Classloader源码解析</h3>\n      <p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f698927160a154a671e4ad9.png\"  alt=\"dde4c5b14067b17e281dd1fa322c37a7.png\">\n      </p>\n<ul>\n<li>每一个ClassLoader内部的parent都是一个final值，无法改变。</li>\n<li>findclass的权限是protected受保护的，只能在子类中访问</li>\n<li>\n        <h3 id=\"如何加载一个类\"   >\n          <a href=\"#如何加载一个类\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>如何加载一个类</h3>\n      </li>\n</ul>\n<figure class=\"highlight java\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T005_LoadClassByHand</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ClassNotFoundException </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//首先拿到app这个类加载器，之后调用他的loadClass方法，只需要把类的全名传进去，就可以加载到内存</span></span><br><span class=\"line\">        Class clazz = T005_LoadClassByHand.class.getClassLoader().loadClass(<span class=\"string\">&quot;com.learn.jvm.c2_classloader.T002_ClassLoaderLevel&quot;</span>);</span><br><span class=\"line\">        System.out.println(clazz.getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<ul>\n<li>要加载一个类，只需要调用classLoad的loadclass()方法，加载到内存后会返回一个class对象</li>\n</ul>\n\n        <h3 id=\"自定义类加载器代码实现\"   >\n          <a href=\"#自定义类加载器代码实现\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>自定义类加载器代码实现</h3>\n      <p>自定义ClassLoader只需要重写findClass，使用了<strong>模板方法</strong>的设计模式</p>\n<figure class=\"highlight java\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.mashibing.jvm.c2_classloader;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.mashibing.jvm.Hello;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.ByteArrayOutputStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.File;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.FileInputStream;</span><br><span class=\"line\"><span class=\"comment\">//继承ClassLoader</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T006_MSBClassLoader</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClassLoader</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//重写findClass方法，然后找到要load进来的二进制内容，load之后再转换为对象</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Class&lt;?&gt; findClass(String name) <span class=\"keyword\">throws</span> ClassNotFoundException &#123;</span><br><span class=\"line\">        File f = <span class=\"keyword\">new</span> File(<span class=\"string\">&quot;c:/test/&quot;</span>, name.replace(<span class=\"string\">&quot;.&quot;</span>, <span class=\"string\">&quot;/&quot;</span>).concat(<span class=\"string\">&quot;.class&quot;</span>));</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            FileInputStream fis = <span class=\"keyword\">new</span> FileInputStream(f);</span><br><span class=\"line\">            ByteArrayOutputStream baos = <span class=\"keyword\">new</span> ByteArrayOutputStream();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> b = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">while</span> ((b=fis.read()) !=<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                baos.write(b);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] bytes = baos.toByteArray();</span><br><span class=\"line\">            baos.close();</span><br><span class=\"line\">            fis.close();<span class=\"comment\">//可以写的更加严谨</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//defineClass方法将二进制流转换为class对象</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> defineClass(name, bytes, <span class=\"number\">0</span>, bytes.length);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.findClass(name); <span class=\"comment\">//throws ClassNotFoundException</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        ClassLoader l = <span class=\"keyword\">new</span> T006_MSBClassLoader();</span><br><span class=\"line\">        Class clazz = l.loadClass(<span class=\"string\">&quot;com.mashibing.jvm.Hello&quot;</span>);</span><br><span class=\"line\">        Class clazz1 = l.loadClass(<span class=\"string\">&quot;com.mashibing.jvm.Hello&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(clazz == clazz1);<span class=\"comment\">//true</span></span><br><span class=\"line\"></span><br><span class=\"line\">        Hello h = (Hello)clazz.newInstance();</span><br><span class=\"line\">        h.m();</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(l.getClass().getClassLoader());<span class=\"comment\">//AppClassLoader</span></span><br><span class=\"line\">        System.out.println(l.getParent());<span class=\"comment\">//AppClassLoader</span></span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(getSystemClassLoader());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n<p>简单加密的</p>\n<figure class=\"highlight java\"><div class=\"table-container\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.mashibing.jvm.c2_classloader;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.mashibing.jvm.Hello;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.ByteArrayOutputStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.File;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.FileInputStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.FileOutputStream;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T007_MSBClassLoaderWithEncription</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClassLoader</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//异或种子值</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> seed = <span class=\"number\">0B10110110</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Class&lt;?&gt; findClass(String name) <span class=\"keyword\">throws</span> ClassNotFoundException &#123;</span><br><span class=\"line\">        File f = <span class=\"keyword\">new</span> File(<span class=\"string\">&quot;c:/test/&quot;</span>, name.replace(<span class=\"string\">&#x27;.&#x27;</span>, <span class=\"string\">&#x27;/&#x27;</span>).concat(<span class=\"string\">&quot;.msbclass&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            FileInputStream fis = <span class=\"keyword\">new</span> FileInputStream(f);</span><br><span class=\"line\">            ByteArrayOutputStream baos = <span class=\"keyword\">new</span> ByteArrayOutputStream();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> b = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">while</span> ((b=fis.read()) !=<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                baos.write(b ^ seed);<span class=\"comment\">//异或解密</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] bytes = baos.toByteArray();</span><br><span class=\"line\">            baos.close();</span><br><span class=\"line\">            fis.close();<span class=\"comment\">//可以写的更加严谨</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> defineClass(name, bytes, <span class=\"number\">0</span>, bytes.length);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.findClass(name); <span class=\"comment\">//throws ClassNotFoundException</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        encFile(<span class=\"string\">&quot;com.mashibing.jvm.hello&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        ClassLoader l = <span class=\"keyword\">new</span> T007_MSBClassLoaderWithEncription();</span><br><span class=\"line\">        Class clazz = l.loadClass(<span class=\"string\">&quot;com.mashibing.jvm.Hello&quot;</span>);</span><br><span class=\"line\">        Hello h = (Hello)clazz.newInstance();</span><br><span class=\"line\">        h.m();</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(l.getClass().getClassLoader());</span><br><span class=\"line\">        System.out.println(l.getParent());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//简单加密方法，一般class就是一个二进制流，采用异或方式加密（再异或一次就是原值，两次异或值不变）</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">encFile</span><span class=\"params\">(String name)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        File f = <span class=\"keyword\">new</span> File(<span class=\"string\">&quot;c:/test/&quot;</span>, name.replace(<span class=\"string\">&#x27;.&#x27;</span>, <span class=\"string\">&#x27;/&#x27;</span>).concat(<span class=\"string\">&quot;.class&quot;</span>));</span><br><span class=\"line\">        FileInputStream fis = <span class=\"keyword\">new</span> FileInputStream(f);</span><br><span class=\"line\">        FileOutputStream fos = <span class=\"keyword\">new</span> FileOutputStream(<span class=\"keyword\">new</span> File(<span class=\"string\">&quot;c:/test/&quot;</span>, name.replaceAll(<span class=\"string\">&quot;.&quot;</span>, <span class=\"string\">&quot;/&quot;</span>).concat(<span class=\"string\">&quot;.msbclass&quot;</span>)));</span><br><span class=\"line\">        <span class=\"keyword\">int</span> b = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>((b = fis.read()) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            fos.write(b ^ seed);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        fis.close();</span><br><span class=\"line\">        fos.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></div></figure>\n\n        <h3 id=\"lazyloading-懒加载-懒初始化\"   >\n          <a href=\"#lazyloading-懒加载-懒初始化\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>lazyloading 懒加载 懒初始化</h3>\n      <p>jvm虚拟机的实现都是使用了懒加载，什么时候用什么时候加载。</p>\n<p><strong>注意：jvm规范没有规定何时加载，但是以下五种情况必须初始化</strong></p>\n<ol>\n<li>–new getstatic putstatic invokestatic指令，访问final变量除外</li>\n<li>java.lang.reflect对类进行反射调用时</li>\n<li>初始化子类的时候，父类首先初始化</li>\n<li>虚拟机启动时，被执行的主类必须初始化</li>\n<li>动态语言支持java.lang.invoke.MethodHandle解析的结果为REF_getstatic REF_putstatic REF_invokestatic的方法句柄时，该类必须初始化</li>\n</ol>\n\n        <h2 id=\"java执行模式\"   >\n          <a href=\"#java执行模式\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>java执行模式</h2>\n      <p>默认是混合模式，可修改配置为纯解释模式或者纯编译模式</p>\n<p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f698927160a154a671e4adc.png\"  alt=\"bb52a64035ef08c3b1931ff23e504414.png\">\n      </p>\n<p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f698927160a154a671e4ae4.png\"  alt=\"346cb0ae6b06099ae8105b078335ced2.png\">\n      </p>\n\n        <h2 id=\"Linking\"   >\n          <a href=\"#Linking\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Linking</h2>\n      <ol>\n<li>Verification<ol>\n<li>验证文件是否符合JVM规定</li>\n</ol>\n</li>\n<li>Preparation<ol>\n<li>静态成员变量赋默认值（0，null ）</li>\n</ol>\n</li>\n<li>Resolution<ul>\n<li>将类、方法、属性等符号引用解析为直接引用；常量池中的各种符号引用解析为指针、偏移量等内存地址的直接引用</li>\n</ul>\n</li>\n</ol>\n\n        <h2 id=\"Initializing\"   >\n          <a href=\"#Initializing\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Initializing</h2>\n      <ul>\n<li>调用类初始化代码 <clinit>，给静态成员变量赋初始值</li>\n</ul>\n\n        <h2 id=\"注意\"   >\n          <a href=\"#注意\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>注意</h2>\n      <ol>\n<li>load - 默认值 - 初始值</li>\n<li>new - 申请内存 - 默认值 - 初始值</li>\n</ol>\n","categories":["JVM"],"tags":["JVM"]},{"title":"Class文件简介","url":"/2020/09/15/Class%E6%96%87%E4%BB%B6%E7%AE%80%E4%BB%8B/","content":"\n        <h1 id=\"Class文件\"   >\n          <a href=\"#Class文件\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>Class文件</h1>\n      \n        <h2 id=\"classFile\"   >\n          <a href=\"#classFile\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>classFile</h2>\n      <p>整个class文件的格式就是个二进制字节流，由JVM来解释</p>\n<a id=\"more\"></a>\n\n\n        <h2 id=\"ClassFileFormat\"   >\n          <a href=\"#ClassFileFormat\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>ClassFileFormat</h2>\n      <p><span class=\"exturl\"><a class=\"exturl__link\"   href=\"https://app.yinxiang.com/shard/s22/nl/23898398/a1e81fa6-a639-4c35-94a8-f770a3500ffd\" >java1.8类文件格式</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n<ol>\n<li>Magic Number 文件头</li>\n<li>Minor Version</li>\n<li>Major Version 2.3组成了class文件的版本号，1.7默认51,1.8默认52</li>\n<li>constant_pool_count 有多少个常量池</li>\n<li>constant_pool  常量池-1具体内容有多种类型，常量池是从1开始的，0号做了预留</li>\n<li>access_flags class文件的修饰符（public、privote等）</li>\n<li>this_class 当前的类是谁</li>\n<li>super_class 父类是谁</li>\n<li>interfaces_count 实现接口数量</li>\n<li>interfaces 具体实现了哪些</li>\n<li>fields_count 有哪些属性</li>\n<li>fields 具体有哪些属性</li>\n<li>methods_count 有哪些方法</li>\n<li>methods 具体有哪些方法</li>\n<li>attributes_count 有哪些其他的附加属性</li>\n<li>attributes 具体有哪些其他的附加属性</li>\n</ol>\n<div class=\"table-container\"><table>\n<thead>\n<tr>\n<th></th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Magic Number</td>\n<td>文件头</td>\n</tr>\n<tr>\n<td>Minor Version</td>\n<td></td>\n</tr>\n<tr>\n<td>Major Version</td>\n<td>与上一个组成了class文件的版本号，1.7默认51,1.8默认52</td>\n</tr>\n<tr>\n<td>constant_pool_count</td>\n<td>有多少个常量池</td>\n</tr>\n<tr>\n<td>constant_pool</td>\n<td>常量池-1具体内容有多种类型，常量池是从1开始的，0号做了预留</td>\n</tr>\n<tr>\n<td>access_flags</td>\n<td>class文件的修饰符（public、privote等）</td>\n</tr>\n<tr>\n<td>this_class</td>\n<td>当前的类是谁</td>\n</tr>\n<tr>\n<td>super_class</td>\n<td>父类是谁</td>\n</tr>\n<tr>\n<td>interfaces_count</td>\n<td>实现接口数量</td>\n</tr>\n<tr>\n<td>interfaces</td>\n<td>具体实现了哪些</td>\n</tr>\n<tr>\n<td>fields_count</td>\n<td>有哪些属性</td>\n</tr>\n<tr>\n<td>fields</td>\n<td>具体有哪些属性</td>\n</tr>\n<tr>\n<td>methods_count</td>\n<td>有哪些方法</td>\n</tr>\n<tr>\n<td>methods</td>\n<td>具体有哪些方法</td>\n</tr>\n<tr>\n<td>attributes_count</td>\n<td>有哪些其他的附加属性</td>\n</tr>\n<tr>\n<td>attributes</td>\n<td>具体有哪些其他的附加属性</td>\n</tr>\n</tbody></table></div>\n\n        <h3 id=\"constant-pool\"   >\n          <a href=\"#constant-pool\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>constant_pool</h3>\n      <p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6aeae4160a154a67b24116.png\"  alt=\"constant_pool\">\n      </p>\n\n        <h3 id=\"access-flags\"   >\n          <a href=\"#access-flags\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>access_flags</h3>\n      <p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f6aeae4160a154a67b24111.png\"  alt=\"access_flags\">\n      </p>\n\n        <h3 id=\"fields\"   >\n          <a href=\"#fields\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>fields</h3>\n      <p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f69886f160a154a671dd22a.png\"  alt=\"fields\">\n      </p>\n\n        <h3 id=\"methods\"   >\n          <a href=\"#methods\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>methods</h3>\n      <p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f69887e160a154a671ddcd7.png\"  alt=\"methods\">\n      </p>\n\n        <h3 id=\"attributes\"   >\n          <a href=\"#attributes\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>attributes</h3>\n      <p>\n        <img   class=\"lazyload lazyload-gif\"\n          src=\"/images/loading.svg\" data-src=\"https://pic.downk.cc/item/5f698887160a154a671de44f.png\"  alt=\"attributes\">\n      </p>\n\n        <h2 id=\"JVM只有8个指令是原子性\"   >\n          <a href=\"#JVM只有8个指令是原子性\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a>JVM只有8个指令是原子性</h2>\n      <p>1.lock（锁定） 2.unlock（解锁） 3.write（写入） 4.read（读取）<br>这四个作用与<strong>主内存</strong><br>5.load（载入） 6.use（使用） 7.assign（赋值） 8.store（存储）<br>这四个作用与<strong>工作内存</strong></p>\n","categories":["JVM"],"tags":["JVM"]}]