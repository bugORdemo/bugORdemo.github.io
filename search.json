[{"title":"GC和GC Tuning","url":"/2020/09/22/GC和GC-Tuning/","content":"\n\n\n# GC和GC Tuning\n\n## GC的基础知识\n\n### 1.什么是垃圾\n\n没有任何**引用指向**的一个对象或者多个对象（循环引用）\n\n### 2.如何定位垃圾\n\n1. 引用计数算法\n\n    对象有一个引用指向就是1，两个就是2，没有就是0，这时就是垃圾\n    问题：循环引用无法解决，比如下图是一堆垃圾相互引用，**会导致内存泄漏**\n    ![927f4bafb08942bf8727477973d2456b.png](https://pic.downk.cc/item/5f698ab9160a154a671f4635.png)\n    \n2. 根可达（根搜索、Root Searching）算法\n   \n    通过根对象能够找到的就不是垃圾，反之就是垃圾\n\n    根有哪些：\n    1. 线程栈变量 \n        * 一个main方法开始运行，main线程栈中的变量调用了其他方法，main线程栈中的方法访问到的对象是根对象 \n    2. 静态变量\n        * T.class对静态变量初始化能够访问到的对象是根对象 \n    3. 常量池 \n        * 如果一个class能够用到其他的class对象叫根对象\n    4. JNI指针\n        * 如果调用了本地方法运用到本地的对象叫根对象\n    * 根对象：当一个程序启动时就需要用到的对象叫做根对象\n\n    ![efccd4a1d60db196fe6595fcc097d7ee.png](https://pic.downk.cc/item/5f698ab9160a154a671f462e.png)\n\n### 3.常见的垃圾回收算法\n\n1. 标记清除(mark sweep) \n    * 算法相对简单，存货对象比较多的情况下效率比较高 \n    * 位置不连续，容易产生碎片，需要经过两遍扫描（第一遍标记有用的，第二遍清除无用的）\n2. 拷贝算法 (copying)  - 适合Eden区\n    * 适用于存活对象较少的情况，只扫描一次，效率提高，没有碎片\n    * 比较浪费空间，移动复制对象，需要调整对象引用\n3. 标记压缩(mark compact) \n    * 没有碎片，方便对象分配，不会产生内存减半\n    * 扫描两次，需要移动对象并调整指针，效率偏低\n\n### 4.JVM内存分代模型（用于分代垃圾回收算法）\n\n![c62ce51447e2af5dfb9ca8000ab89e73.png](https://pic.downk.cc/item/5f698b5b160a154a671f9efa.png)\n![e35f7af17d149845bbf8a9f21dc2a7f6.png](https://pic.downk.cc/item/5f698b69160a154a671fa803.png)\n\n* -Xms -Xmx -Xmn X是分标参数，m是memory，s是最小值，x是最大值，n是new,新生代的大小\n\n1. 部分垃圾回收器使用的模型\n   * 除Epsilon ZGC Shenandoah之外的GC都是使用逻辑分代模型\n   * G1是逻辑分代，物理不分代\n   * 除此之外不仅逻辑分代，而且物理分代\n\n2. 新生代 + 老年代 + 永久代（1.7）Perm Generation/ 元数据区(1.8) Metaspace\n   1. 永久代 元数据 - 存放Class信息、代码编译信息等\n   2. 永久代必须指定大小限制 ，元数据可以设置，也可以不设置，不设置受限于物理内存\n   3. 字符串常量 1.7 - 永久代，1.8 - 堆\n   4. MethodArea是逻辑概念 - 他的实现在1.7叫永久代、1.8叫元数据\n   5. 新生代、老年代是堆，永久代 元数据区是堆之外的空间\n   \n3. 新生代 = Eden + 2个suvivor区 （三个区域比例8:1:1）\n   1. YGC回收之后，大多数的对象会被回收，活着的进入s0\n   2. 再次YGC，活着的对象eden + s0 -> s1\n   3. 再次YGC，eden + s1 -> s0\n   4. 年龄足够 -> 老年代 （可以指定，默认PS 15次，CMS 6次，G1 15次。注意：文件头中存贮次数的地方是4位，最大就是15）\n   5. s区装不下 -> 老年代\n   \n4. 老年代（老年代：新生代 = 3:1）\n   1. 顽固分子\n   2. 老年代满了FGC （Full GC）\n   \n5. GC 调优(Generation分代模型)\n   1. 尽量减少FGC\n   2. MinorGC = YGC\n   3. MajorGC = FGC\n   \n6. 动态年龄：（不重要）\n   当YGC一次后，Eden和s0中的存活对象进入s1，如果超过s1容量的50%，其中年龄最大的对象会被放入老年代\n   参考：https://www.jianshu.com/p/989d3b06a49d\n\n7. 分配担保：（不重要）\n   YGC期间 survivor区空间不够了 空间担保直接进入老年代\n   参考：https://cloud.tencent.com/developer/article/1082730\n   \n8. 对象分配过程如下图：\n![86795f58498f8eb819d4b430c45742a6.png](https://pic.downk.cc/item/5f698b74160a154a671fae5c.png)\n首先在栈上分配，如果能分配就分配到栈上，分配不下就会判断大不大（用一个参数制定），如果特别大，就直接进入old区，否则进去TLAB，到Eden区，进行FGC，如果没被清除还存活进入S1，再FGC还存活进S2，当年龄足够进入old区\n\n### 5.常见的垃圾回收器\n\n![aff0a0be7e69d5d1f359ff9162fd0300.png](https://pic.downk.cc/item/5f698b8b160a154a671fbad9.png)\n\n* JDK诞生时就是Serial，为了提高效率，诞生了PS，为了配合CMS，诞生了PN。CMS是1.4版本后期引入，CMS是里程碑式的GC，它开启了并发回收的过程，但是CMS毛病较多，因此目前任何一个JDK版本默认是CMS\n * 并发垃圾回收是因为无法忍受STW\n1. Serial 年轻代 串行回收（满了就在安全点上STW(stop-the-world)然后**单线程**回收，依次循环）\n2. Parallel Scavenge(PS) 年轻代 并行回收（满了就STW(stop-the-world)然后**多线程**回收，依次循环） java14已弃用\n3. ParNew 年轻代 对PS做了一些增强，能够配合CMS的并行回收\n4. SerialOld 老年代的Serial  java14已弃用\n5. ParallelOld 老年代的PS\n6. ConcurrentMarkSweep 老年代 并发的， 垃圾回收和应用程序同时运行，降低STW的时间(200ms)\n   * CMS问题比较多，所以现在没有一个版本默认是CMS，只能手工指定\n   * CMS既然是MarkSweep，就一定会有碎片化的问题，碎片到达一定程度，CMS的老年代分配对象分配不下的时候，使用SerialOld 进行老年代回收\n   想象一下：\n   PS + PO -> 加内存 换垃圾回收器 -> PN + CMS + SerialOld（几个小时 - 几天的STW）\n   几十个G的内存，单线程回收 -> G1 + FGC 几十个G -> 上T内存的服务器 ZGC\n   算法：三色标记 + Incremental Update\n7. G1(10ms)\n   算法：三色标记 + SATB\n8. ZGC (1ms) 能够PK C++\n   算法：ColoredPointers + LoadBarrier（读屏障）\n9. Shenandoah\n    算法：ColoredPointers + WriteBarrier（写屏障）\n10. Eplison\n11. PS 和 PN区别的延伸阅读：\n    ▪[https://docs.oracle.com/en/java/javase/13/gctuning/ergonomics.html#GUID-3D0BB91E-9BFF-4EBB-B523-14493A860E73](https://docs.oracle.com/en/java/javase/13/gctuning/ergonomics.html)\n12. 垃圾收集器跟内存大小的关系\n    1. Serial 几十兆\n    2. PS 上百兆 - 几个G\n    3. CMS - 20G\n    4. G1 - 上百G\n    5. ZGC - 4T - 16T（JDK13）\n\n**1.8默认的垃圾回收：PS + ParallelOld（PO）**\n\n## 常见垃圾回收器组合参数设定：(1.8)\n\n* -XX:+UseSerialGC = Serial New (DefNew) + Serial Old\n  * 小型程序。默认情况下不会是这种选项，HotSpot会根据计算及配置和JDK版本自动选择收集器\n* -XX:+UseParNewGC = ParNew + SerialOld\n  * 这个组合已经很少用（在某些版本中已经废弃）\n  * https://stackoverflow.com/questions/34962257/why-remove-support-for-parnewserialold-anddefnewcms-in-the-future\n* -XX:+UseConc(urrent)MarkSweepGC = ParNew + CMS + Serial Old（括号内的内容在默写版本需要加上）\n* -XX:+UseParallelGC = Parallel Scavenge + Parallel Old (1.8默认) 【PS + SerialOld】\n* -XX:+UseParallelOldGC = Parallel Scavenge + Parallel Old\n* -XX:+UseG1GC = G1\n* Linux中没找到默认GC的查看方法，而windows中会打印UseParallelGC \n  * java +XX:+PrintCommandLineFlags -version\n  * 通过GC的日志来分辨\n\n* Linux下1.8版本默认的垃圾回收器到底是什么？\n\n  * 1.8.0_181 默认（看不出来）Copy MarkCompact\n  * 1.8.0_222 默认 PS + PO\n\n## JVM调优第一步，了解JVM常用命令行参数\n\n* JVM的命令行参数参考：https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html\n\n* HotSpot参数分类\n\n  > 标准： - 开头，所有的HotSpot都支持\n  > 非标准：-X 开头，特定版本HotSpot支持特定命令\n  > 不稳定：-XX 开头，下个版本可能取消\n\n  java -version\n\n  java -X\n\n试验用程序：\n\n``` java\n import java.util.List;\n  import java.util.LinkedList;\n  \n  public class HelloGC {\n    public static void main(String[] args) {\n      System.out.println(\"HelloGC!\");\n      List list = new LinkedList();\n      for(;;) {\n        byte[] b = new byte[1024*1024];\n        list.add(b);\n      }\n    }\n  }\n```\n\n  1. 区分概念：内存泄漏memory leak，内存溢出out of memory\n\n  2. java -XX:+PrintCommandLineFlags HelloGC\n\n     ![43b58700144c5f2022a5e21b30703d23.png](https://pic.downk.cc/item/5f698ba3160a154a671fc860.png)\n\n\n    \t* InitialHeapSize 起始堆大小，根据内存算出来\n        * MaxHeapSize 最大堆大小\n        * UseCompressedClassPointers 默认\n        * UseCompressedOops 普通指针压缩\n\n  3. java -Xmn10M -Xms40M -Xmx60M -XX:+PrintCommandLineFlags -XX:+PrintGC  HelloGC\n      PrintGCDetails PrintGCTimeStamps PrintGCCauses\n      * Xms最小堆大小、Xmx最大堆大小，一般情况下设置成一样的，不要让他产生弹性压缩浪费系统资源\n      * -XX:+PrintGC 打印GC回收的信息\n      * PrintGCDetails 打印更详细的GC信息\n      * PrintGCTimeStamps 打印GC产生是系统的详细时间\n      * PrintGCCauses 打印GC产生的原因\n      ![0e63ffb24d2f6aa3f2fa6caf06ef784d.png](https://pic.downk.cc/item/5f698be3160a154a671ff161.png)\n      \n  4. java -XX:+UseConcMarkSweepGC -XX:+PrintCommandLineFlags HelloGC\n      * 设置CMS GC，-XX:+PrintGC打印CMS的GC跟上面差不多，会多一些CMS的详细的阶段过程\n  5. java -XX:+PrintFlagsInitial 默认参数值\n  6. java -XX:+PrintFlagsFinal 最终参数值\n  7. java -XX:+PrintFlagsFinal | grep xxx 找到对应的参数\n  8. java -XX:+PrintFlagsFinal -version |grep GC\n\n## PS GC日志详解\n\n每种垃圾回收器的日志格式是不同的！\n\nPS日志格式\n\n![c8ecb28583f3c664174e204aded82a78.png](https://pic.downk.cc/item/5f698c07160a154a672007e8.png)\n\nheap dump部分（内存溢出，会打印堆的信息）：\n\n```java\neden space 5632K, 94% used [0x00000000ff980000,0x00000000ffeb3e28,0x00000000fff00000)\n//三个地址分别是：内存起始地址、使用空间结束地址、整体空间结束地址\n//eden区整体大小5632k，使用了94%，eden区地址是从 第1个地址 开始到 第3个地址 结束，其中从第1个地址到了第2个地址是已经使用的，占94%\n```\n\n![62119ba3f0733d7ffd4d5b15ef40035b.png](https://pic.downk.cc/item/5f698c07160a154a672007e2.png)\n\ntotal = eden + 1个survivor\n\n## 调优\n### 调优前的基础概念：\n\n1. 吞吐量：用户代码时间 /（用户代码执行时间 + 垃圾回收时间）\n2. 响应时间：STW越短，响应时间越好\n\n所谓调优，首先确定，追求啥？吞吐量优先，还是响应时间优先？还是在满足一定的响应时间的情况下，要求达到多大的吞吐量...\n\n问题：\n\n科学计算，吞吐量。数据挖掘，吞吐量。吞吐量优先的一般：（PS + PO）\n\n响应时间：网站 GUI API （1.8 G1）\n\n### 什么是调优？\n\n1. 根据需求进行JVM规划和预调优\n2. 优化运行JVM运行环境（慢，卡顿）\n3. 解决JVM运行过程中出现的各种问题(OOM)\n\n### 解决JVM运行中的问题\n\n#### 一个案例理解常用工具\n\n1. 测试代码：\n\n```java\npackage com.mashibing.jvm.gc;\n   \n   import java.math.BigDecimal;\n   import java.util.ArrayList;\n   import java.util.Date;\n   import java.util.List;\n   import java.util.concurrent.ScheduledThreadPoolExecutor;\n   import java.util.concurrent.ThreadPoolExecutor;\n   import java.util.concurrent.TimeUnit;\n   \n   /**\n    * 从数据库中读取信用数据，套用模型，并把结果进行记录和传输\n    */\n   \n   public class T15_FullGC_Problem01 {\n   \n       private static class CardInfo {\n           BigDecimal price = new BigDecimal(0.0);\n           String name = \"张三\";\n           int age = 5;\n           Date birthdate = new Date();\n   \n           public void m() {}\n       }\n   \n       private static ScheduledThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(50,\n               new ThreadPoolExecutor.DiscardOldestPolicy());\n   \n       public static void main(String[] args) throws Exception {\n           executor.setMaximumPoolSize(50);\n   \n           for (;;){\n               modelFit();\n               Thread.sleep(100);\n           }\n       }\n   \n       private static void modelFit(){\n           List<CardInfo> taskList = getAllCardInfo();\n           taskList.forEach(info -> {\n               // do something\n               executor.scheduleWithFixedDelay(() -> {\n                   //do sth with info\n                   info.m();\n   \n               }, 2, 3, TimeUnit.SECONDS);\n           });\n       }\n   \n       private static List<CardInfo> getAllCardInfo(){\n           List<CardInfo> taskList = new ArrayList<>();\n   \n           for (int i = 0; i < 100; i++) {\n               CardInfo ci = new CardInfo();\n               taskList.add(ci);\n           }\n   \n           return taskList;\n       }\n   }\n```\n\n使用命令运行 java -Xms200M -Xmx200M -XX:+PrintGC com.mashibing.jvm.gc.T15_FullGC_Problem01\n\n* 一般是运维团队首先受到报警信息（CPU Memory），如何定位问题\n\n1. 传统命令行，**top**命令观察到问题：内存不断增长 CPU占用率居高不下\n\n5. top -Hp 观察进程中的线程，哪个线程CPU和内存占比高\n\n6. **jps**定位具体java进程； **jstack** 定位线程状况，重点关注：WAITING BLOCKED\n   例如：\n   waiting on <0x0000000088ca3310> (a java.lang.Object)\n   假如有一个进程中100个线程，很多线程都在waiting on <xx> ，一定要找到是哪个线程持有这把锁\n   怎么找？搜索jstack dump的信息，找<xx> ，看哪个线程持有这把锁，这个线程状态可能是RUNNABLE\n\n7. 为什么阿里规范里规定，线程的名称（尤其是线程池）都要写有意义的名称\n   怎么样自定义线程池里的线程名称？（自定义ThreadFactory）\n\n8. **jinfo** pid \n\n9. **jstat** -gc 动态观察gc情况 / 阅读GC日志发现频繁GC / arthas观察 / jconsole/jvisualVM/ Jprofiler（最好用）\n   jstat -gc 4655 500 : 每个500个毫秒打印GC的情况\n   如果面试官问你是怎么定位OOM问题的？如果你回答用图形界面（错误）\n   1：已经上线的系统不用图形界面用什么？（cmd line(命令行)、arthas）\n   2：图形界面到底用在什么地方？测试！测试的时候进行监控！（压测观察）\n\n10. **jmap** - histo 4655 | head -20，查找有多少对象产生，线上环境定位可以用\n\n11. jmap -dump:format=b,file=xxx pid ：\n    线上系统，内存特别大，jmap执行堆转储期间会对进程产生很大影响，甚至卡顿（电商不适合），这时候怎么办？\n    1：设定了参数HeapDump，OOM的时候会自动产生堆转储文件\n    2：很多服务器备份（高可用），停掉这台服务器对其他服务器不影响（首选说法）\n    3：在线定位(一般小点儿公司用不到)\n    \n    * 我了解jmap一旦执行了堆转储对线上系统影响比较大，所以我们做了隔离，先把那台机器隔离开然后再做这件事\n\n12. java -Xms20M -Xmx20M -XX:+UseParallelGC -XX:+HeapDumpOnOutOfMemoryError com.mashibing.jvm.gc.T15_FullGC_Problem01\n\n13. 使用MAT / jhat /jvisualvm 进行dump文件分析\n     https://www.cnblogs.com/baihuitestsoftware/articles/6406271.html \n    * jhat -J-mx512M xxx.dump\n    -J-mx512M设定最大使用内存\n    http://192.168.17.11:7000\n    拉到最后：找到对应链接\n    可以使用OQL查找特定问题对象\n1. 系统已经oom了怎么到处dump文件？\n    1. 指定XX:+HeapDumpOnOutOfMemoryError参数会自动生成，不过如果是大内存，会很慢\n    2. oom后不要重启，使用jmap命令\n    \n14. 找到代码的问题\n    * cpu/内存飚高->top/jps命令查->cpu高可能是死循环死锁，用jstat看哪个县城有问题 -频繁GC有对象回收不了用jmap导出来分析\n\n##### jconsole远程连接\n\n1. 程序启动加入参数：\n\n```shell\n    java -Djava.rmi.server.hostname=192.168.17.11 -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=11111 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false XXX\n```\n\n2. 如果遭遇 Local host name unknown：XXX的错误，修改/etc/hosts文件，把XXX加入进去\n\n```java\n    192.168.17.11 basic localhost localhost.localdomain localhost4 localhost4.localdomain4\n    ::1         localhost localhost.localdomain localhost6 localhost6.localdomain6\n```\n\n3. 关闭linux防火墙（实战中应该打开对应端口）\n\n```shell\n    service iptables stop\n    chkconfig iptables off #永久关闭\n```\n4. windows上打开 jconsole远程连接 192.168.17.11:11111\n\n\n##### jvisualvm远程连接\n\n https://www.cnblogs.com/liugh/p/7620336.html （简单做法）\n\n##### jprofiler (收费)\n\n##### arthas在线排查工具\n\n* 为什么需要在线排查？\n   在生产上我们经常会碰到一些不好排查的问题，例如线程安全问题，用最简单的threaddump或者heapdump不好查到问题原因。为了排查这些问题，有时我们会临时加一些日志，比如在一些关键的函数里打印出入参，然后重新打包发布，如果打了日志还是没找到问题，继续加日志，重新打包发布。对于上线流程复杂而且审核比较严的公司，从改代码到上线需要层层的流转，会大大影响问题排查的进度。 \n* jvm观察jvm信息\n* thread观察定位线程问题\n* dashboard 观察系统情况\n* heapdump + jhat分析\n* jad反编译\n   动态代理生成类的问题定位\n   第三方的类（观察代码）\n   版本问题（确定自己最新提交的版本是不是被使用）\n* redefine 热替换\n   目前有些限制条件：只能改方法实现（方法已经运行完成），不能改方法名， 不能改属性\n* sc  - search class\n* watch  - watch method\n* 没有包含的功能：jmap（查找有多少对象产生未包含）\n\n### GC算法的基础概念\n\n* Card Table\n  由于做YGC时，需要扫描整个OLD区，效率非常低，所以JVM设计了CardTable， 如果一个OLD区CardTable中有对象指向Y区，就将它设为Dirty（脏的），下次扫描时，只需要扫描Dirty Card\n  在结构上，Card Table用BitMap来实现\n  \n### 三色标记算法\n* 白色：未被标记的对象\n* 灰色：自身被标记，成员变量（它引用的对象）未被标记\n* 黑色：自身和成员变量都被标记\n\n#### 漏标问题及解决方案\n漏标是指，当黑色指向白色，指向白色的其他引用没了，此时白色是存活对象但是没有被标记，就会被当成垃圾回收掉。\n解决：\n* incremental update -- 增量更新，跟踪引用的增加，把黑色重新标记为灰色（CMS使用这种方式）\n* SATB -- 关注引用的删除，当引用消失时，把这个引用放到GC的堆栈，保证消失的引用还能被GC扫描到（G1使用）\n* 为什么G1使用SATB？\n    1. 因为第一种方式标记为灰色之后，还要重新扫描，效率低\n    2. 灰色指向白色的引用消失时，如果没有黑色指向白色，引用会被push到堆栈，下次扫描时拿到这个引用，由于有RSet，不需要扫描整个堆去查找指向白色的引用，SATB配合RSet效率高\n\n### CMS\n\n#### CMS的问题\n\n1. Memory Fragmentation 内存碎片化\n\n   > -XX:+UseCMSCompactAtFullCollection\n   > -XX:CMSFullGCsBeforeCompaction 默认为0 指的是经过多少次FGC才进行压缩\n\n2. Floating Garbage 浮动垃圾\n\n   > Concurrent Mode Failure\n   > 产生：if the concurrent collector is unable to finish reclaiming the unreachable objects before the tenured generation fills up, or if an allocation cannot be satisfiedwith the available free space blocks in the tenured generation, then theapplication is paused and the collection is completed with all the applicationthreads stopped\n   >\n   > 解决方案：**降低触发CMS的阈值**\n   >\n   > PromotionFailed\n   >\n   > 解决方案类似，保持老年代有足够的空间\n   >\n   > –XX:CMSInitiatingOccupancyFraction 92% 可以降低这个值，让CMS保持老年代足够的空间\n\n#### CMS日志分析\n\n执行命令：java -Xms20M -Xmx20M -XX:+PrintGCDetails -XX:+UseConcMarkSweepGC com.mashibing.jvm.gc.T15_FullGC_Problem01\n\n[GC (Allocation Failure) [ParNew: 6144K->640K(6144K), 0.0265885 secs] 6585K->2770K(19840K), 0.0268035 secs] [Times: user=0.02 sys=0.00, real=0.02 secs] \n\n> ParNew：年轻代收集器\n>\n> 6144->640：收集前后的对比\n>\n> （6144）：整个年轻代容量\n>\n> 6585 -> 2770：整个堆的情况\n>\n> （19840）：整个堆大小\n\n\n\n```java\n[GC (CMS Initial Mark) [1 CMS-initial-mark: 8511K(13696K)] 9866K(19840K), 0.0040321 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] \n\t//8511 (13696) : 老年代使用（最大）\n\t//9866 (19840) : 整个堆使用（最大）\n[CMS-concurrent-mark-start]\n[CMS-concurrent-mark: 0.018/0.018 secs] [Times: user=0.01 sys=0.00, real=0.02 secs] \n\t//这里的时间意义不大，因为是并发执行\n[CMS-concurrent-preclean-start]\n[CMS-concurrent-preclean: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] \n\t//标记Card为Dirty，也称为Card Marking\n[GC (CMS Final Remark) [YG occupancy: 1597 K (6144 K)][Rescan (parallel) , 0.0008396 secs][weak refs processing, 0.0000138 secs][class unloading, 0.0005404 secs][scrub symbol table, 0.0006169 secs][scrub string table, 0.0004903 secs][1 CMS-remark: 8511K(13696K)] 10108K(19840K), 0.0039567 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] \n\t//STW阶段，YG occupancy:年轻代占用及容量\n\t//[Rescan (parallel)：STW下的存活对象标记\n\t//weak refs processing: 弱引用处理\n\t//class unloading: 卸载用不到的class\n\t//scrub symbol(string) table: \n\t\t//cleaning up symbol and string tables which hold class-level metadata and \n\t\t//internalized string respectively\n\t//CMS-remark: 8511K(13696K): 阶段过后的老年代占用及容量\n\t//10108K(19840K): 阶段过后的堆占用及容量\n\n[CMS-concurrent-sweep-start]\n[CMS-concurrent-sweep: 0.005/0.005 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] \n\t//标记已经完成，进行并发清理\n[CMS-concurrent-reset-start]\n[CMS-concurrent-reset: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]\n\t//重置内部结构，为下次GC做准备\n```\n\n\n\n### G1\n\n1. ▪https://www.oracle.com/technical-resources/articles/java/g1gc.html\n\n#### G1逻辑分层，物理不分层\nG1吧内存分为一小块一小块的区域，old区存放老年对象；Survivor区存放存活对象；Eden区存放新生对象；Humongous存放大对象。某一个区域可能是年轻代也可能是老年代，但是在同一时刻只能属于某个时代\n\n#### G1特点\n* 并发收集\n* 压缩空闲空间不会延长GC的暂停时间\n* 更容易的预测GC暂停时间\n* 适用于不需要很高吞吐量的场景\n* G1的内存区域不是固定的E或O，可能是年轻代也可能是老年代，但是在同一时刻只能属于某个时代\n* 新老年代比例是动态的，最好不要手工指定，因为这是G1预测停顿时间的基准\n\n#### CSet\n有哪些需要被回收，会收集到表格里\n#### RSet\n每一个Region（区域）里面都会有一个hash表，记录了其他Region中的对象到本Region的引用\n作用：使得垃圾回收器不需要扫描整个堆找到谁引用了当前分区中的对象，只需要扫描RSet即可\n\n#### G1日志详解\n\n```java\n[GC pause (G1 Evacuation Pause) (young) (initial-mark), 0.0015790 secs]\n//young -> 年轻代 Evacuation-> 复制存活对象 \n//initial-mark 混合回收的阶段，这里是YGC混合老年代回收\n   [Parallel Time: 1.5 ms, GC Workers: 1] //一个GC线程\n      [GC Worker Start (ms):  92635.7]\n      [Ext Root Scanning (ms):  1.1]\n      [Update RS (ms):  0.0]\n         [Processed Buffers:  1]\n      [Scan RS (ms):  0.0]\n      [Code Root Scanning (ms):  0.0]\n      [Object Copy (ms):  0.1]\n      [Termination (ms):  0.0]\n         [Termination Attempts:  1]\n      [GC Worker Other (ms):  0.0]\n      [GC Worker Total (ms):  1.2]\n      [GC Worker End (ms):  92636.9]\n   [Code Root Fixup: 0.0 ms]\n   [Code Root Purge: 0.0 ms]\n   [Clear CT: 0.0 ms]\n   [Other: 0.1 ms]\n      [Choose CSet: 0.0 ms]\n      [Ref Proc: 0.0 ms]\n      [Ref Enq: 0.0 ms]\n      [Redirty Cards: 0.0 ms]\n      [Humongous Register: 0.0 ms]\n      [Humongous Reclaim: 0.0 ms]\n      [Free CSet: 0.0 ms]\n   [Eden: 0.0B(1024.0K)->0.0B(1024.0K) Survivors: 0.0B->0.0B Heap: 18.8M(20.0M)->18.8M(20.0M)]\n [Times: user=0.00 sys=0.00, real=0.00 secs] \n//以下是混合回收其他阶段\n[GC concurrent-root-region-scan-start]\n[GC concurrent-root-region-scan-end, 0.0000078 secs]\n[GC concurrent-mark-start]\n//无法evacuation，进行FGC\n[Full GC (Allocation Failure)  18M->18M(20M), 0.0719656 secs]\n   [Eden: 0.0B(1024.0K)->0.0B(1024.0K) Survivors: 0.0B->0.0B Heap: 18.8M(20.0M)->18.8M(20.0M)], [Metaspace: 38\n76K->3876K(1056768K)] [Times: user=0.07 sys=0.00, real=0.07 secs]\n\n```\n\n\n\n\n### GC常用参数\n\n* -Xmn -Xms -Xmx -Xss\n  年轻代 最小堆 最大堆 栈空间\n* -XX:+UseTLAB\n  使用TLAB，默认打开\n* -XX:+PrintTLAB\n  打印TLAB的使用情况\n* -XX:TLABSize\n  设置TLAB大小\n        这三个一般不用动\n* -XX:+DisableExplictGC\n  System.gc()不管用 ，FGC。线上系统一般都要设置\n* -XX:+PrintGC\n打印GC信息\n* -XX:+PrintGCDetails\n打印GC的详细信息\n* -XX:+PrintHeapAtGC\nGC打印堆栈情况\n* -XX:+PrintGCTimeStamps\n发生GC的系统时间\n* -XX:+PrintGCApplicationConcurrentTime (重要性低)\n  打印应用程序时间\n* -XX:+PrintGCApplicationStoppedTime （重要性低）\n  打印暂停时长\n* -XX:+PrintReferenceGC （重要性低）\n  记录回收了多少种不同引用类型的引用\n* -verbose:class\n  类加载详细过程\n* -XX:+PrintVMOptions\n打印JVM的参数\n* -XX:+**PrintFlagsFinal**  -XX:+PrintFlagsInitial \n    分别是最终的初始化/默认参数\n  必须会用\n* -Xloggc:opt/log/gc.log\n记录GC日志\n* -XX:MaxTenuringThreshold\nGC升代年龄，最大值15\n* -XX:PreBlockSpin 锁自旋次数 -XX:CompileThreshold 热点代码检测参数 逃逸分析 标量替换 ... \n  这些不建议设置\n\n### Parallel常用参数\n\n* -XX:SurvivorRatio\nSurvivor区比例，默认8:1:1，可以调，很少动\n* -XX:PreTenureSizeThreshold  \n大对象到底多大，通过这个指定\n* -XX:MaxTenuringThreshold \nGC升代年龄，最大值15\n* -XX:+ParallelGCThreads\n  并行收集器的线程数，同样适用于CMS，一般设为和CPU核数相同。一般不会调，会自动检测设置\n* -XX:+UseAdaptiveSizePolicy\n  自动选择各区大小比例\n\n### CMS常用参数\n\n* -XX:+UseConcMarkSweepGC \nCMS启动\n* -XX:ParallelCMSThreads \nCMS线程数量，默认是核数的一半\n* -XX:CMSInitiatingOccupancyFraction\n  使用多少比例的老年代后开始CMS收集，默认是68%(近似值)，如果频繁发生SerialOld卡顿，应该调小，（频繁CMS回收）\n* -XX:+UseCMSCompactAtFullCollection\n  在FGC时进行压缩\n* -XX:CMSFullGCsBeforeCompaction\n  多少次FGC之后进行压缩\n* -XX:+CMSClassUnloadingEnabled \n   回收永久代（1.8之前的）\n* -XX:CMSInitiatingPermOccupancyFraction\n  达到什么比例时进行Perm回收（1.8之前的）\n* GCTimeRatio\n  设置GC时间占用程序运行时间的百分比，是一个建议时间，GC会尝试用各种手段达到这个时间\n* -XX:MaxGCPauseMillis\n  停顿时间，是一个建议时间，GC会尝试用各种手段达到这个时间，比如减小年轻代\n\n### G1常用参数\n\n* -XX:+UseG1GC\n    使用G1 GC\n* -XX:MaxGCPauseMillis\n  停顿时间，是一个建议时间，G1会尝试调整Young区的块数来达到这个值\n* -XX:GCPauseIntervalMillis\n  ？GC的间隔时间，再查一下\n* -XX:+G1HeapRegionSize\n  分区大小，建议逐渐增大该值，1 2 4 8 16 32。\n  随着size增加，垃圾的存活时间更长，GC间隔更长，但每次GC的时间也会更长\n  ZGC做了改进（动态区块大小）\n* G1NewSizePercent\n  新生代最小比例，默认为5%\n* G1MaxNewSizePercent\n  新生代最大比例，默认为60%\n* GCTimeRatio\n  GC时间建议比例，G1会根据这个值调整堆空间\n* ConcGCThreads\n  线程数量\n* InitiatingHeapOccupancyPercent\n  启动G1的堆空间占用比例\n\n\n\n### 参考资料\n\n1. [https://blogs.oracle.com/](https://blogs.oracle.com/jonthecollector/our-collectors)[jonthecollector](https://blogs.oracle.com/jonthecollector/our-collectors)[/our-collectors](https://blogs.oracle.com/jonthecollector/our-collectors)\n2. https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html\n3. http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp\n4. JVM调优参考文档：https://docs.oracle.com/en/java/javase/13/gctuning/introduction-garbage-collection-tuning.html#GUID-8A443184-7E07-4B71-9777-4F12947C8184 \n5. https://www.cnblogs.com/nxlhero/p/11660854.html 在线排查工具\n6. https://www.jianshu.com/p/507f7e0cc3a3 arthas常用命令\n7. Arthas手册：\n   1. 启动arthas java -jar arthas-boot.jar\n   2. 绑定java进程\n   3. dashboard命令观察系统整体情况\n   4. help 查看帮助\n   5. help xx 查看具体命令帮助\n8. jmap命令参考： https://www.jianshu.com/p/507f7e0cc3a3 \n   1. jmap -heap pid\n   2. jmap -histo pid\n   3. jmap -clstats pid\n","tags":["JVM"],"categories":["JVM"]},{"title":"java运行时数据区和常用指令","url":"/2020/09/22/java运行时数据区和常用指令/","content":"\n\n\n# Runtime Data Area and Instruction Set\n\njvms 2.4 2.5\n\n## 指令集分类（了解）\n\n1. 基于寄存器的指令集\n2. 基于栈的指令集\n   Hotspot中的Local Variable Table = JVM中的寄存器\n\n<!-- more -->\n\n## Runtime Data Area\nPC program Counter\nJVM Stacks\nHeap\nMethod Area\nRun - Time Constant Pool\nNative Method Stack\nDirect Memory\n\n### PC 程序计数器\n\n> 存放指令位置\n>\n> 虚拟机的运行，类似于这样的循环：\n>\n> while( not end ) {\n>\n> 取PC中的位置，找到对应位置的指令；\n>\n> 执行该指令；\n>\n> PC ++;\n>\n> }\n\n### JVM Stack\n\n Frame（栈帧） - 一个方法对应一个栈帧，栈帧内包含\n   1. Local Variable Table （局部变量表）\n   2. Operand Stack （操作数据栈）\n      对于long的处理（store and load），多数虚拟机的实现都是原子的\n      jls 17.7，没必要加volatile\n   3. Dynamic Linking（动态链接）\n       https://blog.csdn.net/qq_41813060/article/details/88379473 \n      jvms 2.6.3\n   4. return address\n      a() -> b()，方法a调用了方法b, b方法执行结束后要换回到a的什么地方继续执行\n\n\n### Method Area\n\n1. Perm Space (<1.8)\n   * 字符串常量位于PermSpace\n   * FGC不会清理\n   * 大小启动的时候指定，不能变\n2. Meta Space (>=1.8)\n   * 字符串常量位于堆\n   * 会触发FGC清理\n   * 不设定的话，最大就是物理内存\n   \n* Perm Space与Meta Space是不同版本的Method Area的实现\n* 方法区是不被所有线程共享的，方法区内装的是每一class的结构\n\n### Run - Time Constant Pool\n常量池的内容在运行的时候就扔在Run - Time Constant Pool中\n\n\n* * *\n\n![f7371bcaf97d345ec46b864c316ed0d5.png](https://pic.downk.cc/item/5f698a56160a154a671f0967.png)\n\n## 常用java字节码指令\n\nstore  将一个数值从操作数栈存储到局部变量表的指令\n\npush 将一个常量加载到操作数栈的指令\n\nload  将一个局部变量加载到操作栈的指令\n\npop 弹出\n\nmul 乘法\n\nsub 减法\n\nadd 加法\n\ninvoke\n\n1. InvokeStatic  \n    * 调用静态方法 \n2. InvokeVirtual \n    * 自带多态，new一个对象调用m方法，在里面压栈，压的是谁调用的就是那个对象的方法\n3. InvokeInterface \n    *  比如List是interface然后new了一个对象，再调用add方法，就是InvokeInterface\n    *  List<String> = new ArrayList<String>();\n    *  但是如果是ArrayList<String> = new ArrayList<String>();再调用add方法，就是InvokeVirtual\n4. InovkeSpecial\n   * 可以直接定位，不需要多态的方法\n   * private 方法 ， 构造方法\n5. InvokeDynamic\n   * JVM最难的指令\n   * lambda表达式或者反射或者其他动态语言（scala kotlin），或者CGLib ASM，动态产生的class，会用到的指令\n   * 内部类的内部类\n\n## 分析一个递归程序的运行过程\n![261c73238d2ec44b6bbbeaeb2c0dfc8c.png](https://pic.downk.cc/item/5f698a56160a154a671f0964.png)\n\n* 注意在m方法的栈帧中的局部变量表中，因为不是静态方法，所以第0个是this，第1个是n；\n* main方法的栈帧中的局部变量表中，是静态的没有this，第一个是args，第1个是h，第2个是i\n\nmain方法过程\n1. new出Hello_04对象，之后对象地址压栈，这个时候这里的值是默认值\n2. 此时会有dup指令把这个对象地址在栈顶上再复制一个\n3. 执行InovkeSpecial指令来执行构造方法，此时会把上面复制的对象地址弹出栈。初始化完成\n4. 执行astore_1，赋值给h\n5. aload_1压栈->InvokeVirtual调用m方法\n6. m方法结束后返回一个值放到栈顶->执行astore_2赋值给i\n7. 结束\n\nm方法过程\n* 一个方法对应一个栈帧\n\n1. iload_1把3压栈\n2. iconst_1把这个常量值1压栈，后面作比较使用\n3. if_icmpne 把两个值进行比较，ne是not equal，不等就跳到第七条指令\n4. iload_1把3压栈 ->iload_0 this压栈 -> iload_1把3压栈->iconst_1常量值1压栈\n5. isub做减法，吧3和1相减放到这\n6. InvokeVirtual调用m方法（此时是m(2)）\n.\n.\n.\n7. InvokeVirtual调用m方法（此时是m(1)）\n8. m(1)方法执行到if_icmpne指令时相等了，此时继续执行5、6指令返回到m(2)方法\n9. m(2)方法继续向下执行imul指令做乘法（2 * 1），计算完成后返回m(3)\n10.  m(3)方法继续向下执行imul指令做乘法（3 * 2 * 1），计算完成后返回给main方法的i赋值","tags":["JVM"],"categories":["JVM"]},{"title":"JMM","url":"/2020/09/22/JMM/","content":"\n\n\n# JMM\n\n## 硬件层数据一致性\n\n一致性协议很多,intel 用的是MESI\n\n现代CPU的数据一致性实现 = 缓存锁(MESI ...) + 总线锁\n\n问题：有了缓存锁还需要总线锁吗？需要，如果需要的数据缓存装不下，此时还是需要锁总线\n\n<!-- more -->\n\n>https://www.cnblogs.com/z00377750/p/9180644.html\n\n读取缓存以cache line（缓存行）为基本单位，目前64bytes，位于同一缓存行的两个不同数据，被两个不同CPU锁定，产生互相影响的伪共享问题\n\n### 伪共享问题\n伪共享问题：有两个无关变量x、y位于同一个缓存行，这时CPU1要使用x，就会把这个缓存行加载进来，CPU2要使用y，也会把这个缓存行加载进来，当CPU1对x的值进行改变，此时在CPU2中的这个缓存行状态变为I（Invalid）。CPU2要使用y就需要去重新加载，其实变量y并无改变，此时效率会变低，反之亦然。\n\n解决方案：**使用缓存行的对齐能够提高效率**\n\n## 乱序问题\n\nCPU为了提高指令执行效率，会在一条指令执行过程中（比如去内存读数据，这时速度相对很慢），去同时执行另一条指令，前提是，两条指令没有依赖关系。这样指令就不会按顺序执行，造成乱序问题\n\n问题：下图中的Mgr06需不需要加volatile？\n![cc936e0a540cc9b8ee5affe000d337af.png](https://pic.downk.cc/item/5f6989c5160a154a671eb2d0.png)\n![3fdf5fb1005fb8ce8e9f5408a13ba73d.png](https://pic.downk.cc/item/5f6989c5160a154a671eb2ce.png)\n\n回答：需要加volatile，可能会因为指令重排造成乱序。在多线程情况下，第一个线程进来进行双重检查通过后，对INSTANCE进行初始化，当初始化到一半的时候，此时内存空间已经分配，INSTANCE赋了默认值。这时候第二个线程进来，检查INSTANCE发现不为null就拿走使用了，但此时INSTANCE并未初始化结束，线程二拿走使用的数据是不正确的。所以需要加volatile\n\n\n## 如何保证特定情况下不乱序\n\n### 硬件方面\n\n1. 硬件内存屏障 X86 有三条指令\n\n    1.  sfence:  store| 在sfence指令前的写操作当必须在sfence指令后的写操作前完成。\n    2.  lfence：load | 在lfence指令前的读操作当必须在lfence指令后的读操作前完成。\n    3.  mfence：modify/mix | 在mfence指令前的读写操作当必须在mfence指令后的读写操作前完成。\n\n2. 原子指令，如x86上的”lock …” 指令是一个Full Barrier，执行时会锁住内存子系统来确保执行顺序，甚至跨多个CPU。Software Locks通常使用了内存屏障或原子指令来实现变量可见性和保持程序顺序\n\n### JVM方面\nJVM级别如何规范（JSR133），这只是规范，具体实现看jvm\n\n1. LoadLoad屏障：\n    对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。\n2. StoreStore屏障：\n\t对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。\n3. LoadStore屏障：\n    对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。\n4. StoreLoad屏障：\n \t对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。\n\n### volatile的实现细节\n\n1. 字节码层面\n    说白了就是在字节码层面加了一volatile，只是加了一个访问符**ACC_VOLATILE** \n2. JVM层面\n    volatile内存区的读写 都加屏障\n    \n    1. 写操作前面加StoreStore屏障，后面加StoreLoad屏障\n    2. 读操作前面加LoadLoad屏障，后面加LoadStore屏障\n    \n   > StoreStoreBarrier\n   > volatile 写操作\n   > StoreLoadBarrier\n  \n   > LoadLoadBarrier\n   > volatile 读操作\n   > LoadStoreBarrier\n\n3. OS和硬件层面\n   在windows上，lock 指令实现 | MESI实现\n\n### synchronized实现细节\n\n1. 字节码层面\n    实际上字节码层面\n    如果同步语句块，就是**monitorenter monitorexit**指令\n    如果同步方法，就是加了一个**ACC_SYNCHRONIZED**修饰符\n2. JVM层面\n   C和C++ 调用了操作系统提供的同步机制\n3. OS和硬件层面\n   X86 : lock指令","tags":["JVM"],"categories":["JVM"]},{"title":"Class加载过程","url":"/2020/09/22/Class加载过程/","content":"\n\n\n# class加载过程\n有一个class文件在硬盘，需要怎样的过程才能加载到内存中？\n1. Loading\n2. Linking\n3. Initializing\n\n<!-- more -->\n\n* * *\n1. Loading是把class文件装载到内存中\n2. Linking分为三步\n    1. Verification 验证文件是否符合JVM规定\n    2. Preparation  静态成员变量赋**默认值**\n    3. Resolution  将类、方法、属性等符号引用解析为直接引用；常量池中的各种符号引用解析为指针、偏移量等内存地址的直接引用\n3. Initializing 调用类初始化代码 <clinit>，给静态成员变量赋初始值\n\n![2f421b5c7a9aeb1f217a248523422f57.png](https://pic.downk.cc/item/5f698927160a154a671e4aed.png)\n\n## Loading\n\n![b05863bf80d05571f5e4fe0fba85b3c9.png](https://pic.downk.cc/item/5f698927160a154a671e4acc.png)\n\n不同的加载器负责加载不同的class\n1. BootStrap 加载lib里jdk最核心的内容，比如rt.jar charset.jar。当调用getClassLoader()为null的时候，代表到达了最顶层的加载器\n2. Extension 加载器拓展类，加载jre/lib/ext目录下拓展包的内容\n3. Application 加载classpath指定内容\n4. 自定义加载器ClassLoader（Custom ClassLoader），加载自定义的加载器\n\n<u>**注意：父加载器不是“类加载器的加载器”，也不是“类加载器的父类加载器”**</u>\n\n### 双亲委派\n\n一个class文件需要被load内存时候是这样的\n任何一个class，假如自定义了ClassLoader，就先尝试去自定义的内部缓存里面找，如果加载进来就返回，不需要加载第二遍。如果没找到，也并不是直接去加载，而是去他的父亲application父加载器，说爸爸你有没有把这个类加载进来，这时候application就会去他的缓存里面找有没有这个类，如果有返回，如果没有委托给他的父亲 Extension，如果有返回，如果没有委托给他的父亲 Bootstrap有就返回，如果都没有就往回再委托。说Extension我这没有你去加载， Extension说我只负责我扩展jar包部分，你的类我找不到，application去加载，application说我只负责加载classpath指定内容，其他的找不到，然后委托ClassLoader去找，整个过程是转了一圈，才真正把这个类加载进来，当我们能够把这个类加载进来的时候成功返回，如果加载不进来，抛ClassNotfound异常。这就叫做双亲委派。\n\n#### 为什么要使用双亲委派？\n1. 安全问题\n2. 减少资源浪费，加载过得不需要再加载一遍\n\n解释：\n如果任何一个class都可以load进内存，那我可以自定义一个java.lang.String交给自定义的类加载器加载到内存，打包给客户，然后客户只要使用String存储敏感信息，都可以暗中发送给我。因为自定义的，想干什么都可以，不安全。\n使用双亲委派就可以避免这个问题，当自定义加载器加载java.lang.String的时候，会向上面查又没有加载过，加载过直接返回，不会再次加载。\n\n#### 打破双亲委派机制\n 1. 重写loadClass（）方法\n 2. 何时打破过？\n     1. JDK1.2之前，自定义ClassLoader都必须重写loadClass()\n     2. ThreadContextClassLoader可以实现基础类调用实现类代码，通过thread.setContextClassLoader指定\n     3. 热启动，热部署\n         *  osgi tomcat 都有自己的模块指定classloader（可以加载同一类库的不同版本）\n\n### 自定义类加载器\n1. 继承ClassLoader\n2. 重写模板方法findClass\n    * 调用defindClass （将二进制流转换为class对象并返回）\n3. 自定义类加载器加载自加密的class（可有可无）\n    * 防止反编译 防止篡改\n\n### Classloader源码解析\n\n![dde4c5b14067b17e281dd1fa322c37a7.png](https://pic.downk.cc/item/5f698927160a154a671e4ad9.png)\n\n* 每一个ClassLoader内部的parent都是一个final值，无法改变。\n* findclass的权限是protected受保护的，只能在子类中访问\n* \n### 如何加载一个类\n\n```java\npublic class T005_LoadClassByHand {\n    public static void main(String[] args) throws ClassNotFoundException {\n\t\t//首先拿到app这个类加载器，之后调用他的loadClass方法，只需要把类的全名传进去，就可以加载到内存\n        Class clazz = T005_LoadClassByHand.class.getClassLoader().loadClass(\"com.learn.jvm.c2_classloader.T002_ClassLoaderLevel\");\n        System.out.println(clazz.getName());\n    }\n}\n```\n* 要加载一个类，只需要调用classLoad的loadclass()方法，加载到内存后会返回一个class对象\n\n### 自定义类加载器代码实现\n自定义ClassLoader只需要重写findClass，使用了**模板方法**的设计模式\n```java\npackage com.mashibing.jvm.c2_classloader;\n\nimport com.mashibing.jvm.Hello;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\n//继承ClassLoader\npublic class T006_MSBClassLoader extends ClassLoader {\n\t//重写findClass方法，然后找到要load进来的二进制内容，load之后再转换为对象\n    @Override\n    protected Class<?> findClass(String name) throws ClassNotFoundException {\n        File f = new File(\"c:/test/\", name.replace(\".\", \"/\").concat(\".class\"));\n        try {\n            FileInputStream fis = new FileInputStream(f);\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            int b = 0;\n\n            while ((b=fis.read()) !=0) {\n                baos.write(b);\n            }\n\n            byte[] bytes = baos.toByteArray();\n            baos.close();\n            fis.close();//可以写的更加严谨\n\t\t\t//defineClass方法将二进制流转换为class对象\n            return defineClass(name, bytes, 0, bytes.length);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return super.findClass(name); //throws ClassNotFoundException\n    }\n\n    public static void main(String[] args) throws Exception {\n        ClassLoader l = new T006_MSBClassLoader();\n        Class clazz = l.loadClass(\"com.mashibing.jvm.Hello\");\n        Class clazz1 = l.loadClass(\"com.mashibing.jvm.Hello\");\n\n        System.out.println(clazz == clazz1);//true\n\n        Hello h = (Hello)clazz.newInstance();\n        h.m();\n\n        System.out.println(l.getClass().getClassLoader());//AppClassLoader\n        System.out.println(l.getParent());//AppClassLoader\n\n        System.out.println(getSystemClassLoader());\n    }\n}\n\n```\n简单加密的\n```java\npackage com.mashibing.jvm.c2_classloader;\n\nimport com.mashibing.jvm.Hello;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\n\npublic class T007_MSBClassLoaderWithEncription extends ClassLoader {\n\t//异或种子值\n    public static int seed = 0B10110110;\n\n    @Override\n    protected Class<?> findClass(String name) throws ClassNotFoundException {\n        File f = new File(\"c:/test/\", name.replace('.', '/').concat(\".msbclass\"));\n\n        try {\n            FileInputStream fis = new FileInputStream(f);\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            int b = 0;\n\n            while ((b=fis.read()) !=0) {\n                baos.write(b ^ seed);//异或解密\n            }\n\n            byte[] bytes = baos.toByteArray();\n            baos.close();\n            fis.close();//可以写的更加严谨\n\n            return defineClass(name, bytes, 0, bytes.length);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return super.findClass(name); //throws ClassNotFoundException\n    }\n\n    public static void main(String[] args) throws Exception {\n\n        encFile(\"com.mashibing.jvm.hello\");\n\n        ClassLoader l = new T007_MSBClassLoaderWithEncription();\n        Class clazz = l.loadClass(\"com.mashibing.jvm.Hello\");\n        Hello h = (Hello)clazz.newInstance();\n        h.m();\n\n        System.out.println(l.getClass().getClassLoader());\n        System.out.println(l.getParent());\n    }\n\n\t//简单加密方法，一般class就是一个二进制流，采用异或方式加密（再异或一次就是原值，两次异或值不变）\n    private static void encFile(String name) throws Exception {\n        File f = new File(\"c:/test/\", name.replace('.', '/').concat(\".class\"));\n        FileInputStream fis = new FileInputStream(f);\n        FileOutputStream fos = new FileOutputStream(new File(\"c:/test/\", name.replaceAll(\".\", \"/\").concat(\".msbclass\")));\n        int b = 0;\n\n        while((b = fis.read()) != -1) {\n            fos.write(b ^ seed);\n        }\n\n        fis.close();\n        fos.close();\n    }\n}\n\n```\n### lazyloading 懒加载 懒初始化\n\njvm虚拟机的实现都是使用了懒加载，什么时候用什么时候加载。\n\n**注意：jvm规范没有规定何时加载，但是以下五种情况必须初始化**\n1.  –new getstatic putstatic invokestatic指令，访问final变量除外\n2. java.lang.reflect对类进行反射调用时\n3. 初始化子类的时候，父类首先初始化\n4. 虚拟机启动时，被执行的主类必须初始化\n5. 动态语言支持java.lang.invoke.MethodHandle解析的结果为REF_getstatic REF_putstatic REF_invokestatic的方法句柄时，该类必须初始化\n\n## java执行模式\n默认是混合模式，可修改配置为纯解释模式或者纯编译模式\n\n![bb52a64035ef08c3b1931ff23e504414.png](https://pic.downk.cc/item/5f698927160a154a671e4adc.png)\n\n![346cb0ae6b06099ae8105b078335ced2.png](https://pic.downk.cc/item/5f698927160a154a671e4ae4.png)\n\n\n## Linking\n1. Verification\n    1. 验证文件是否符合JVM规定\n2. Preparation\n    1. 静态成员变量赋默认值（0，null ）\n3. Resolution\n    * 将类、方法、属性等符号引用解析为直接引用；常量池中的各种符号引用解析为指针、偏移量等内存地址的直接引用\n\n\n## Initializing\n* 调用类初始化代码 <clinit>，给静态成员变量赋初始值\n\n## 注意\n1. load - 默认值 - 初始值\n2. new - 申请内存 - 默认值 - 初始值\n\n\n","tags":["JVM"],"categories":["JVM"]},{"title":"Class文件简介","url":"/2020/09/22/Class文件简介/","content":"\n\n\n# Class文件\n\n## classFile\n整个class文件的格式就是个二进制字节流，由JVM来解释\n\n<!-- more -->\n\n## ClassFileFormat\n[java1.8类文件格式](https://app.yinxiang.com/shard/s22/nl/23898398/a1e81fa6-a639-4c35-94a8-f770a3500ffd)\n\n1. Magic Number 文件头\n2. Minor Version\n3. Major Version 2.3组成了class文件的版本号，1.7默认51,1.8默认52\n4. constant_pool_count 有多少个常量池\n5. constant_pool  常量池-1具体内容有多种类型，常量池是从1开始的，0号做了预留\n6. access_flags class文件的修饰符（public、privote等）\n7. this_class 当前的类是谁\n8. super_class 父类是谁\n9. interfaces_count 实现接口数量\n10. interfaces 具体实现了哪些\n11. fields_count 有哪些属性\n12. fields 具体有哪些属性\n13. methods_count 有哪些方法\n14. methods 具体有哪些方法\n15. attributes_count 有哪些其他的附加属性\n16. attributes 具体有哪些其他的附加属性\n\n\n|                     | 解释                                                       |\n| ------------------- | ---------------------------------------------------------- |\n| Magic Number        | 文件头                                                     |\n| Minor Version       |                                                            |\n| Major Version       | 与上一个组成了class文件的版本号，1.7默认51,1.8默认52       |\n| constant_pool_count | 有多少个常量池                                             |\n| constant_pool       | 常量池-1具体内容有多种类型，常量池是从1开始的，0号做了预留 |\n| access_flags        | class文件的修饰符（public、privote等）                     |\n| this_class          | 当前的类是谁                                               |\n| super_class         | 父类是谁                                                   |\n| interfaces_count    | 实现接口数量                                               |\n| interfaces          | 具体实现了哪些                                             |\n| fields_count        | 有哪些属性                                                 |\n| fields              | 具体有哪些属性                                             |\n| methods_count       | 有哪些方法                                                 |\n| methods             | 具体有哪些方法                                             |\n| attributes_count    | 有哪些其他的附加属性                                       |\n| attributes          | 具体有哪些其他的附加属性                                   |\n\n### constant_pool\n![constant_pool](https://wx2.sbimg.cn/2020/09/22/GL7ko.png)\n\n### access_flags\n![access_flags](https://wx2.sbimg.cn/2020/09/22/GLaHJ.png)\n\n### fields\n![fields](https://pic.downk.cc/item/5f69886f160a154a671dd22a.png)\n\n### methods\n![methods](https://pic.downk.cc/item/5f69887e160a154a671ddcd7.png)\n\n### attributes\n![attributes](https://pic.downk.cc/item/5f698887160a154a671de44f.png)\n\n## JVM只有8个指令是原子性\n1.lock（锁定） 2.unlock（解锁） 3.write（写入） 4.read（读取） \n这四个作用与**主内存**\n5.load（载入） 6.use（使用） 7.assign（赋值） 8.store（存储）\n这四个作用与**工作内存**","tags":["JVM"],"categories":["JVM"]},{"title":"MYSQL performance schema详解","url":"/2020/09/22/MYSQL-performance-schema详解/","content":"\n\n\n# MYSQL performance schema详解\n\n## performance_schema的介绍\n\n**MySQL的performance schema 用于监控MySQL server在一个较低级别的运行过程中的资源消耗、资源等待等情况**。\n\n特点如下：\n\n<!-- more -->\n\n1. 提供了一种在数据库运行时实时检查server的内部执行情况的方法。performance_schema 数据库中的表使用performance_schema存储引擎。该数据库主要关注数据库运行过程中的性能相关的数据，与information_schema不同，information_schema主要关注server运行过程中的元数据信息\n2. performance_schema通过监视server的事件来实现监视server内部运行情况， “事件”就是server内部活动中所做的任何事情以及对应的时间消耗，利用这些信息来判断server中的相关资源消耗在了哪里？一般来说，事件可以是函数调用、操作系统的等待、SQL语句执行的阶段（如sql语句执行过程中的parsing 或 sorting阶段）或者整个SQL语句与SQL语句集合。事件的采集可以方便的提供server中的相关存储引擎对磁盘文件、表I/O、表锁等资源的同步调用信息。\n3. performance_schema中的事件与写入二进制日志中的事件（描述数据修改的events）、事件计划调度程序（这是一种存储程序）的事件不同。performance_schema中的事件记录的是server执行某些活动对某些资源的消耗、耗时、这些活动执行的次数等情况。\n4. performance_schema中的事件只记录在本地server的performance_schema中，其下的这些表中数据发生变化时不会被写入binlog中，也不会通过复制机制被复制到其他server中。\n5. 当前活跃事件、历史事件和事件摘要相关的表中记录的信息。能提供某个事件的执行次数、使用时长。进而可用于分析某个特定线程、特定对象（如mutex或file）相关联的活动。\n6. PERFORMANCE_SCHEMA存储引擎使用server源代码中的“检测点”来实现事件数据的收集。对于performance_schema实现机制本身的代码没有相关的单独线程来检测，这与其他功能（如复制或事件计划程序）不同\n7. 收集的事件数据存储在performance_schema数据库的表中。这些表可以使用SELECT语句查询，也可以使用SQL语句更新performance_schema数据库中的表记录（如动态修改performance_schema的setup_* 开头的几个配置表，但要注意：配置表的更改会立即生效，这会影响数据收集）\n8. performance_schema的表中的数据不会持久化存储在磁盘中，而是保存在内存中，一旦服务器重启，这些数据会丢失（包括配置表在内的整个performance_schema下的所有数据）\n9. MySQL支持的所有平台中事件监控功能都可用，但不同平台中用于统计事件时间开销的计时器类型可能会有所差异。\n\n## performance schema入门\n\n在mysql的5.7版本中，性能模式是默认开启的，如果想要显式的关闭的话需要修改配置文件，不能直接进行修改，会报错Variable 'performance_schema' is a read only variable。\n\n```sql\n--查看performance_schema的属性\nmysql> SHOW VARIABLES LIKE 'performance_schema';\n+--------------------+-------+\n| Variable_name      | Value |\n+--------------------+-------+\n| performance_schema | ON    |\n+--------------------+-------+\n1 row in set (0.01 sec)\n\n--在配置文件中修改performance_schema的属性值，on表示开启，off表示关闭\n[mysqld]\nperformance_schema=ON\n\n--切换数据库\nuse performance_schema;\n\n--查看当前数据库下的所有表,会看到有很多表存储着相关的信息\nshow tables;\n\n--可以通过show create table tablename来查看创建表的时候的表结构\nmysql> show create table setup_consumers;\n+-----------------+---------------------------------\n| Table           | Create Table                    \n+-----------------+---------------------------------\n| setup_consumers | CREATE TABLE `setup_consumers` (\n  `NAME` varchar(64) NOT NULL,                      \n  `ENABLED` enum('YES','NO') NOT NULL               \n) ENGINE=PERFORMANCE_SCHEMA DEFAULT CHARSET=utf8 |  \n+-----------------+---------------------------------\n1 row in set (0.00 sec)                             \n```\n\n想要搞明白后续的内容，需要理解两个基本概念：\n\ninstruments: 生产者，用于采集mysql中各种各样的操作产生的事件信息，对应配置表中的配置项我们可以称为监控采集配置项。\n\nconsumers:消费者，对应的消费者表用于存储来自instruments采集的数据，对应配置表中的配置项我们可以称为消费存储配置项。\n\n## performance_schema表的分类\n\nperformance_schema库下的表可以按照监视不同的纬度就行分组。\n\n```sql\n--语句事件记录表，这些表记录了语句事件信息，当前语句事件表events_statements_current、历史语句事件表events_statements_history和长语句历史事件表events_statements_history_long、以及聚合后的摘要表summary，其中，summary表还可以根据帐号(account)，主机(host)，程序(program)，线程(thread)，用户(user)和全局(global)再进行细分)\nshow tables like '%statement%';\n\n--等待事件记录表，与语句事件类型的相关记录表类似：\nshow tables like '%wait%';\n\n--阶段事件记录表，记录语句执行的阶段事件的表\nshow tables like '%stage%';\n\n--事务事件记录表，记录事务相关的事件的表\nshow tables like '%transaction%';\n\n--监控文件系统层调用的表\nshow tables like '%file%';\n\n--监视内存使用的表\nshow tables like '%memory%';\n\n--动态对performance_schema进行配置的配置表\nshow tables like '%setup%';\n```\n\n## performance_schema的简单配置与使用\n\n数据库刚刚初始化并启动时，并非所有instruments(事件采集项，在采集项的配置表中每一项都有一个开关字段，或为YES，或为NO)和consumers(与采集项类似，也有一个对应的事件类型保存表配置项，为YES就表示对应的表保存性能数据，为NO就表示对应的表不保存性能数据)都启用了，所以默认不会收集所有的事件，可能你需要检测的事件并没有打开，需要进行设置，可以使用如下两个语句打开对应的instruments和consumers（行计数可能会因MySQL版本而异)。\n\n```sql\n--打开等待事件的采集器配置项开关，需要修改setup_instruments配置表中对应的采集器配置项\nUPDATE setup_instruments SET ENABLED = 'YES', TIMED = 'YES'where name like 'wait%';\n\n--打开等待事件的保存表配置开关，修改setup_consumers配置表中对应的配置项\nUPDATE setup_consumers SET ENABLED = 'YES'where name like '%wait%';\n\n--当配置完成之后可以查看当前server正在做什么，可以通过查询events_waits_current表来得知，该表中每个线程只包含一行数据，用于显示每个线程的最新监视事件\nselect * from events_waits_current\\G\n*************************** 1. row ***************************\n            THREAD_ID: 11\n             EVENT_ID: 570\n         END_EVENT_ID: 570\n           EVENT_NAME: wait/synch/mutex/innodb/buf_dblwr_mutex\n               SOURCE: \n          TIMER_START: 4508505105239280\n            TIMER_END: 4508505105270160\n           TIMER_WAIT: 30880\n                SPINS: NULL\n        OBJECT_SCHEMA: NULL\n          OBJECT_NAME: NULL\n           INDEX_NAME: NULL\n          OBJECT_TYPE: NULL\nOBJECT_INSTANCE_BEGIN: 67918392\n     NESTING_EVENT_ID: NULL\n   NESTING_EVENT_TYPE: NULL\n            OPERATION: lock\n      NUMBER_OF_BYTES: NULL\n                FLAGS: NULL\n/*该信息表示线程id为11的线程正在等待buf_dblwr_mutex锁，等待事件为30880\n属性说明：\n\tid:事件来自哪个线程，事件编号是多少\n\tevent_name:表示检测到的具体的内容\n\tsource:表示这个检测代码在哪个源文件中以及行号\n\ttimer_start:表示该事件的开始时间\n\ttimer_end:表示该事件的结束时间\n\ttimer_wait:表示该事件总的花费时间\n注意：_current表中每个线程只保留一条记录，一旦线程完成工作，该表中不会再记录该线程的事件信息\n*/\n\n/*\n_history表中记录每个线程应该执行完成的事件信息，但每个线程的事件信息只会记录10条，再多就会被覆盖，*_history_long表中记录所有线程的事件信息，但总记录数量是10000，超过就会被覆盖掉\n*/\nselect thread_id,event_id,event_name,timer_wait from events_waits_history order by thread_id limit 21;\n\n/*\nsummary表提供所有事件的汇总信息，该组中的表以不同的方式汇总事件数据（如：按用户，按主机，按线程等等）。例如：要查看哪些instruments占用最多的时间，可以通过对events_waits_summary_global_by_event_name表的COUNT_STAR或SUM_TIMER_WAIT列进行查询（这两列是对事件的记录数执行COUNT（*）、事件记录的TIMER_WAIT列执行SUM（TIMER_WAIT）统计而来）\n*/\nSELECT EVENT_NAME,COUNT_STAR FROM events_waits_summary_global_by_event_name  ORDER BY COUNT_STAR DESC LIMIT 10;\n\n/*\ninstance表记录了哪些类型的对象会被检测。这些对象在被server使用时，在该表中将会产生一条事件记录，例如，file_instances表列出了文件I/O操作及其关联文件名\n*/\nselect * from file_instances limit 20; \n```\n\n## 常用配置项的参数说明\n\n1. 启动选项\n\n```sql\nperformance_schema_consumer_events_statements_current=TRUE\n是否在mysql server启动时就开启events_statements_current表的记录功能(该表记录当前的语句事件信息)，启动之后也可以在setup_consumers表中使用UPDATE语句进行动态更新setup_consumers配置表中的events_statements_current配置项，默认值为TRUE\n\nperformance_schema_consumer_events_statements_history=TRUE\n与performance_schema_consumer_events_statements_current选项类似，但该选项是用于配置是否记录语句事件短历史信息，默认为TRUE\n\nperformance_schema_consumer_events_stages_history_long=FALSE\n与performance_schema_consumer_events_statements_current选项类似，但该选项是用于配置是否记录语句事件长历史信息，默认为FALSE\n\n除了statement(语句)事件之外，还支持：wait(等待)事件、state(阶段)事件、transaction(事务)事件，他们与statement事件一样都有三个启动项分别进行配置，但这些等待事件默认未启用，如果需要在MySQL Server启动时一同启动，则通常需要写进my.cnf配置文件中\nperformance_schema_consumer_global_instrumentation=TRUE\n是否在MySQL Server启动时就开启全局表（如：mutex_instances、rwlock_instances、cond_instances、file_instances、users、hostsaccounts、socket_summary_by_event_name、file_summary_by_instance等大部分的全局对象计数统计和事件汇总统计信息表 ）的记录功能，启动之后也可以在setup_consumers表中使用UPDATE语句进行动态更新全局配置项\n默认值为TRUE\n\nperformance_schema_consumer_statements_digest=TRUE\n是否在MySQL Server启动时就开启events_statements_summary_by_digest 表的记录功能，启动之后也可以在setup_consumers表中使用UPDATE语句进行动态更新digest配置项\n默认值为TRUE\n\nperformance_schema_consumer_thread_instrumentation=TRUE\n是否在MySQL Server启动时就开启\n\nevents_xxx_summary_by_yyy_by_event_name表的记录功能，启动之后也可以在setup_consumers表中使用UPDATE语句进行动态更新线程配置项\n默认值为TRUE\n\nperformance_schema_instrument[=name]\n是否在MySQL Server启动时就启用某些采集器，由于instruments配置项多达数千个，所以该配置项支持key-value模式，还支持%号进行通配等，如下:\n\n# [=name]可以指定为具体的Instruments名称（但是这样如果有多个需要指定的时候，就需要使用该选项多次），也可以使用通配符，可以指定instruments相同的前缀+通配符，也可以使用%代表所有的instruments\n\n## 指定开启单个instruments\n\n--performance-schema-instrument= 'instrument_name=value'\n\n## 使用通配符指定开启多个instruments\n\n--performance-schema-instrument= 'wait/synch/cond/%=COUNTED'\n\n## 开关所有的instruments\n\n--performance-schema-instrument= '%=ON'\n\n--performance-schema-instrument= '%=OFF'\n\n注意，这些启动选项要生效的前提是，需要设置performance_schema=ON。另外，这些启动选项虽然无法使用show variables语句查看，但我们可以通过setup_instruments和setup_consumers表查询这些选项指定的值。\n```\n\n2. 系统变量\n\n```sql\nshow variables like '%performance_schema%';\n--重要的属性解释\nperformance_schema=ON\n/*\n控制performance_schema功能的开关，要使用MySQL的performance_schema，需要在mysqld启动时启用，以启用事件收集功能\n该参数在5.7.x之前支持performance_schema的版本中默认关闭，5.7.x版本开始默认开启\n注意：如果mysqld在初始化performance_schema时发现无法分配任何相关的内部缓冲区，则performance_schema将自动禁用，并将performance_schema设置为OFF\n*/\n\nperformance_schema_digests_size=10000\n/*\n控制events_statements_summary_by_digest表中的最大行数。如果产生的语句摘要信息超过此最大值，便无法继续存入该表，此时performance_schema会增加状态变量\n*/\nperformance_schema_events_statements_history_long_size=10000\n/*\n控制events_statements_history_long表中的最大行数，该参数控制所有会话在events_statements_history_long表中能够存放的总事件记录数，超过这个限制之后，最早的记录将被覆盖\n全局变量，只读变量，整型值，5.6.3版本引入 * 5.6.x版本中，5.6.5及其之前的版本默认为10000，5.6.6及其之后的版本默认值为-1，通常情况下，自动计算的值都是10000 * 5.7.x版本中，默认值为-1，通常情况下，自动计算的值都是10000\n*/\nperformance_schema_events_statements_history_size=10\n/*\n控制events_statements_history表中单个线程（会话）的最大行数，该参数控制单个会话在events_statements_history表中能够存放的事件记录数，超过这个限制之后，单个会话最早的记录将被覆盖\n全局变量，只读变量，整型值，5.6.3版本引入 * 5.6.x版本中，5.6.5及其之前的版本默认为10，5.6.6及其之后的版本默认值为-1，通常情况下，自动计算的值都是10 * 5.7.x版本中，默认值为-1，通常情况下，自动计算的值都是10\n除了statement(语句)事件之外，wait(等待)事件、state(阶段)事件、transaction(事务)事件，他们与statement事件一样都有三个参数分别进行存储限制配置，有兴趣的自行研究，这里不再赘述\n*/\nperformance_schema_max_digest_length=1024\n/*\n用于控制标准化形式的SQL语句文本在存入performance_schema时的限制长度，该变量与max_digest_length变量相关(max_digest_length变量含义请自行查阅相关资料)\n全局变量，只读变量，默认值1024字节，整型值，取值范围0~1048576\n*/\nperformance_schema_max_sql_text_length=1024\n/*\n控制存入events_statements_current，events_statements_history和events_statements_history_long语句事件表中的SQL_TEXT列的最大SQL长度字节数。 超出系统变量performance_schema_max_sql_text_length的部分将被丢弃，不会记录，一般情况下不需要调整该参数，除非被截断的部分与其他SQL比起来有很大差异\n全局变量，只读变量，整型值，默认值为1024字节，取值范围为0~1048576，5.7.6版本引入\n降低系统变量performance_schema_max_sql_text_length值可以减少内存使用，但如果汇总的SQL中，被截断部分有较大差异，会导致没有办法再对这些有较大差异的SQL进行区分。 增加该系统变量值会增加内存使用，但对于汇总SQL来讲可以更精准地区分不同的部分。\n*/\n```\n\n## 重要配置表的相关说明\n\n配置表之间存在相互关联关系，按照配置影响的先后顺序，可添加为\n\n![a](https://wx2.sbimg.cn/2020/09/22/GJvuk.png)\n\n```sql\n/*\nperformance_timers表中记录了server中有哪些可用的事件计时器\n字段解释：\n\ttimer_name:表示可用计时器名称，CYCLE是基于CPU周期计数器的定时器\n\ttimer_frequency:表示每秒钟对应的计时器单位的数量,CYCLE计时器的换算值与CPU的频率相关、\n\ttimer_resolution:计时器精度值，表示在每个计时器被调用时额外增加的值\n\ttimer_overhead:表示在使用定时器获取事件时开销的最小周期值\n*/\nselect * from performance_timers;\n\n/*\nsetup_timers表中记录当前使用的事件计时器信息\n字段解释：\n\tname:计时器类型，对应某个事件类别\n\ttimer_name:计时器类型名称\n*/\nselect * from setup_timers;\n\n/*\nsetup_consumers表中列出了consumers可配置列表项\n字段解释：\n\tNAME：consumers配置名称\n\tENABLED：consumers是否启用，有效值为YES或NO，此列可以使用UPDATE语句修改。\n*/\nselect * from setup_consumers;\n\n/*\nsetup_instruments 表列出了instruments 列表配置项，即代表了哪些事件支持被收集：\n字段解释：\n\tNAME：instruments名称，instruments名称可能具有多个部分并形成层次结构\n\tENABLED：instrumetns是否启用，有效值为YES或NO，此列可以使用UPDATE语句修改。如果设置为NO，则这个instruments不会被执行，不会产生任何的事件信息\n\tTIMED：instruments是否收集时间信息，有效值为YES或NO，此列可以使用UPDATE语句修改，如果设置为NO，则这个instruments不会收集时间信息\n*/\nSELECT * FROM setup_instruments;\n\n/*\nsetup_actors表的初始内容是匹配任何用户和主机，因此对于所有前台线程，默认情况下启用监视和历史事件收集功能\n字段解释：\n\tHOST：与grant语句类似的主机名，一个具体的字符串名字，或使用“％”表示“任何主机”\n\tUSER：一个具体的字符串名称，或使用“％”表示“任何用户”\n\tROLE：当前未使用，MySQL 8.0中才启用角色功能\n\tENABLED：是否启用与HOST，USER，ROLE匹配的前台线程的监控功能，有效值为：YES或NO\n\tHISTORY：是否启用与HOST， USER，ROLE匹配的前台线程的历史事件记录功能，有效值为：YES或NO\n*/\nSELECT * FROM setup_actors;\n\n/*\nsetup_objects表控制performance_schema是否监视特定对象。默认情况下，此表的最大行数为100行。\n字段解释：\n\tOBJECT_TYPE：instruments类型，有效值为：“EVENT”（事件调度器事件）、“FUNCTION”（存储函数）、“PROCEDURE”（存储过程）、“TABLE”（基表）、“TRIGGER”（触发器），TABLE对象类型的配置会影响表I/O事件（wait/io/table/sql/handler instrument）和表锁事件（wait/lock/table/sql/handler instrument）的收集\n\tOBJECT_SCHEMA：某个监视类型对象涵盖的数据库名称，一个字符串名称，或“％”(表示“任何数据库”)\n\tOBJECT_NAME：某个监视类型对象涵盖的表名，一个字符串名称，或“％”(表示“任何数据库内的对象”)\n\tENABLED：是否开启对某个类型对象的监视功能，有效值为：YES或NO。此列可以修改\n\tTIMED：是否开启对某个类型对象的时间收集功能，有效值为：YES或NO，此列可以修改\n*/\nSELECT * FROM setup_objects;\n\n/*\nthreads表对于每个server线程生成一行包含线程相关的信息，\n字段解释：\n\tTHREAD_ID：线程的唯一标识符（ID）\n\tNAME：与server中的线程检测代码相关联的名称(注意，这里不是instruments名称)\n\tTYPE：线程类型，有效值为：FOREGROUND、BACKGROUND。分别表示前台线程和后台线程\n\tPROCESSLIST_ID：对应INFORMATION_SCHEMA.PROCESSLIST表中的ID列。\n\tPROCESSLIST_USER：与前台线程相关联的用户名，对于后台线程为NULL。\n\tPROCESSLIST_HOST：与前台线程关联的客户端的主机名，对于后台线程为NULL。\n\tPROCESSLIST_DB：线程的默认数据库，如果没有，则为NULL。\n\tPROCESSLIST_COMMAND：对于前台线程，该值代表着当前客户端正在执行的command类型，如果是sleep则表示当前会话处于空闲状态\n\tPROCESSLIST_TIME：当前线程已处于当前线程状态的持续时间（秒）\n\tPROCESSLIST_STATE：表示线程正在做什么事情。\n\tPROCESSLIST_INFO：线程正在执行的语句，如果没有执行任何语句，则为NULL。\n\tPARENT_THREAD_ID：如果这个线程是一个子线程（由另一个线程生成），那么该字段显示其父线程ID\n\tROLE：暂未使用\n\tINSTRUMENTED：线程执行的事件是否被检测。有效值：YES、NO \n\tHISTORY：是否记录线程的历史事件。有效值：YES、NO * \n\tTHREAD_OS_ID：由操作系统层定义的线程或任务标识符（ID）：\n*/\nselect * from threads\n```\n\n注意：在performance_schema库中还包含了很多其他的库和表，能对数据库的性能做完整的监控，大家需要参考官网详细了解。\n\n## performance_schema实践操作\n\n基本了解了表的相关信息之后，可以通过这些表进行实际的查询操作来进行实际的分析。\n\n```sql\n--1、哪类的SQL执行最多？\nSELECT DIGEST_TEXT,COUNT_STAR,FIRST_SEEN,LAST_SEEN FROM events_statements_summary_by_digest ORDER BY COUNT_STAR DESC\n--2、哪类SQL的平均响应时间最多？\nSELECT DIGEST_TEXT,AVG_TIMER_WAIT FROM events_statements_summary_by_digest ORDER BY COUNT_STAR DESC\n--3、哪类SQL排序记录数最多？\nSELECT DIGEST_TEXT,SUM_SORT_ROWS FROM events_statements_summary_by_digest ORDER BY COUNT_STAR DESC\n--4、哪类SQL扫描记录数最多？\nSELECT DIGEST_TEXT,SUM_ROWS_EXAMINED FROM events_statements_summary_by_digest ORDER BY COUNT_STAR DESC\n--5、哪类SQL使用临时表最多？\nSELECT DIGEST_TEXT,SUM_CREATED_TMP_TABLES,SUM_CREATED_TMP_DISK_TABLES FROM events_statements_summary_by_digest ORDER BY COUNT_STAR DESC\n--6、哪类SQL返回结果集最多？\nSELECT DIGEST_TEXT,SUM_ROWS_SENT FROM events_statements_summary_by_digest ORDER BY COUNT_STAR DESC\n--7、哪个表物理IO最多？\nSELECT file_name,event_name,SUM_NUMBER_OF_BYTES_READ,SUM_NUMBER_OF_BYTES_WRITE FROM file_summary_by_instance ORDER BY SUM_NUMBER_OF_BYTES_READ + SUM_NUMBER_OF_BYTES_WRITE DESC\n--8、哪个表逻辑IO最多？\nSELECT object_name,COUNT_READ,COUNT_WRITE,COUNT_FETCH,SUM_TIMER_WAIT FROM table_io_waits_summary_by_table ORDER BY sum_timer_wait DESC\n--9、哪个索引访问最多？\nSELECT OBJECT_NAME,INDEX_NAME,COUNT_FETCH,COUNT_INSERT,COUNT_UPDATE,COUNT_DELETE FROM table_io_waits_summary_by_index_usage ORDER BY SUM_TIMER_WAIT DESC\n--10、哪个索引从来没有用过？\nSELECT OBJECT_SCHEMA,OBJECT_NAME,INDEX_NAME FROM table_io_waits_summary_by_index_usage WHERE INDEX_NAME IS NOT NULL AND COUNT_STAR = 0 AND OBJECT_SCHEMA <> 'mysql' ORDER BY OBJECT_SCHEMA,OBJECT_NAME;\n--11、哪个等待事件消耗时间最多？\nSELECT EVENT_NAME,COUNT_STAR,SUM_TIMER_WAIT,AVG_TIMER_WAIT FROM events_waits_summary_global_by_event_name WHERE event_name != 'idle' ORDER BY SUM_TIMER_WAIT DESC\n--12-1、剖析某条SQL的执行情况，包括statement信息，stege信息，wait信息\nSELECT EVENT_ID,sql_text FROM events_statements_history WHERE sql_text LIKE '%count(*)%';\n--12-2、查看每个阶段的时间消耗\nSELECT event_id,EVENT_NAME,SOURCE,TIMER_END - TIMER_START FROM events_stages_history_long WHERE NESTING_EVENT_ID = 1553;\n--12-3、查看每个阶段的锁等待情况\nSELECT event_id,event_name,source,timer_wait,object_name,index_name,operation,nesting_event_id FROM events_waits_history_longWHERE nesting_event_id = 1553;\n```","tags":["MySQL调优","MySQL"],"categories":["MySQL"]},{"title":"Hello World","url":"/2020/09/22/hello-world/","content":"之后的学习笔记将记录于此，以前的笔记也会逐步迁移过来。\n\n"}]