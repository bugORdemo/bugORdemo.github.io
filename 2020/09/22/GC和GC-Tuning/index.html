<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/assets/bilibili.jpg?v=2.1.1" type="image/png" sizes="32x32"><meta name="description" content="GC和GC Tuning                           GC的基础知识                           1.什么是垃圾       没有任何引用指向的一个对象或者多个对象（循环引用）                     2.如何定位垃圾        引用计数算法  对象有一个引用指向就是1，两个就是2，没有就是">
<meta property="og:type" content="article">
<meta property="og:title" content="GC和GC Tuning">
<meta property="og:url" content="https://bugordemo.github.io/2020/09/22/GC%E5%92%8CGC-Tuning/index.html">
<meta property="og:site_name" content="DemoOrBug">
<meta property="og:description" content="GC和GC Tuning                           GC的基础知识                           1.什么是垃圾       没有任何引用指向的一个对象或者多个对象（循环引用）                     2.如何定位垃圾        引用计数算法  对象有一个引用指向就是1，两个就是2，没有就是">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic.downk.cc/item/5f698ab9160a154a671f4635.png">
<meta property="og:image" content="https://pic.downk.cc/item/5f698ab9160a154a671f462e.png">
<meta property="og:image" content="https://pic.downk.cc/item/5f698b5b160a154a671f9efa.png">
<meta property="og:image" content="https://pic.downk.cc/item/5f698b69160a154a671fa803.png">
<meta property="og:image" content="https://pic.downk.cc/item/5f698b74160a154a671fae5c.png">
<meta property="og:image" content="https://pic.downk.cc/item/5f698b8b160a154a671fbad9.png">
<meta property="og:image" content="https://pic.downk.cc/item/5f698ba3160a154a671fc860.png">
<meta property="og:image" content="https://pic.downk.cc/item/5f698be3160a154a671ff161.png">
<meta property="og:image" content="https://pic.downk.cc/item/5f698c07160a154a672007e8.png">
<meta property="og:image" content="https://pic.downk.cc/item/5f698c07160a154a672007e2.png">
<meta property="article:published_time" content="2020-09-22T05:03:41.000Z">
<meta property="article:modified_time" content="2020-09-22T05:39:05.758Z">
<meta property="article:author" content="hyf">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic.downk.cc/item/5f698ab9160a154a671f4635.png"><title>GC和GC Tuning | DemoOrBug</title><link ref="canonical" href="https://bugordemo.github.io/2020/09/22/GC%E5%92%8CGC-Tuning/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.1.1"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":5},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: true,
  fancybox: true,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: {"colWidth":"220px","gapX":"10px"},
  lazyload: true,
  pjax: {"avoidBanner":true},
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: {"switchPost":true},
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.2.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">DemoOrBug</div><div class="header-banner-info__subtitle">懒惰、急躁、傲慢 ———— 当代程序员美德</div></div><div class="header-banner-arrow"><div class="header-banner-arrow__icon"><i class="fas fa-angle-down"></i></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">GC和GC Tuning</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-09-22</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-09-22</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">6.1k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">43分</span></span><span class="post-meta-item post-meta-item--visitors"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body">
        <h1 id="GC和GC-Tuning"   >
          <a href="#GC和GC-Tuning" class="heading-link"><i class="fas fa-link"></i></a>GC和GC Tuning</h1>
      
        <h2 id="GC的基础知识"   >
          <a href="#GC的基础知识" class="heading-link"><i class="fas fa-link"></i></a>GC的基础知识</h2>
      
        <h3 id="1-什么是垃圾"   >
          <a href="#1-什么是垃圾" class="heading-link"><i class="fas fa-link"></i></a>1.什么是垃圾</h3>
      <p>没有任何<strong>引用指向</strong>的一个对象或者多个对象（循环引用）</p>

        <h3 id="2-如何定位垃圾"   >
          <a href="#2-如何定位垃圾" class="heading-link"><i class="fas fa-link"></i></a>2.如何定位垃圾</h3>
      <ol>
<li><p>引用计数算法</p>
<p> 对象有一个引用指向就是1，两个就是2，没有就是0，这时就是垃圾<br> 问题：循环引用无法解决，比如下图是一堆垃圾相互引用，<strong>会导致内存泄漏</strong><br> 
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://pic.downk.cc/item/5f698ab9160a154a671f4635.png"  alt="927f4bafb08942bf8727477973d2456b.png">
      </p>
</li>
<li><p>根可达（根搜索、Root Searching）算法</p>
<p> 通过根对象能够找到的就不是垃圾，反之就是垃圾</p>
<p> 根有哪些：</p>
<ol>
<li>线程栈变量 <ul>
<li>一个main方法开始运行，main线程栈中的变量调用了其他方法，main线程栈中的方法访问到的对象是根对象 </li>
</ul>
</li>
<li>静态变量<ul>
<li>T.class对静态变量初始化能够访问到的对象是根对象 </li>
</ul>
</li>
<li>常量池 <ul>
<li>如果一个class能够用到其他的class对象叫根对象</li>
</ul>
</li>
<li>JNI指针<ul>
<li>如果调用了本地方法运用到本地的对象叫根对象</li>
</ul>
</li>
</ol>
<ul>
<li><p>根对象：当一个程序启动时就需要用到的对象叫做根对象</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://pic.downk.cc/item/5f698ab9160a154a671f462e.png"  alt="efccd4a1d60db196fe6595fcc097d7ee.png">
      </p>
</li>
</ul>
</li>
</ol>

        <h3 id="3-常见的垃圾回收算法"   >
          <a href="#3-常见的垃圾回收算法" class="heading-link"><i class="fas fa-link"></i></a>3.常见的垃圾回收算法</h3>
      <ol>
<li>标记清除(mark sweep) <ul>
<li>算法相对简单，存货对象比较多的情况下效率比较高 </li>
<li>位置不连续，容易产生碎片，需要经过两遍扫描（第一遍标记有用的，第二遍清除无用的）</li>
</ul>
</li>
<li>拷贝算法 (copying)  - 适合Eden区<ul>
<li>适用于存活对象较少的情况，只扫描一次，效率提高，没有碎片</li>
<li>比较浪费空间，移动复制对象，需要调整对象引用</li>
</ul>
</li>
<li>标记压缩(mark compact) <ul>
<li>没有碎片，方便对象分配，不会产生内存减半</li>
<li>扫描两次，需要移动对象并调整指针，效率偏低</li>
</ul>
</li>
</ol>

        <h3 id="4-JVM内存分代模型（用于分代垃圾回收算法）"   >
          <a href="#4-JVM内存分代模型（用于分代垃圾回收算法）" class="heading-link"><i class="fas fa-link"></i></a>4.JVM内存分代模型（用于分代垃圾回收算法）</h3>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://pic.downk.cc/item/5f698b5b160a154a671f9efa.png"  alt="c62ce51447e2af5dfb9ca8000ab89e73.png">
      <br>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://pic.downk.cc/item/5f698b69160a154a671fa803.png"  alt="e35f7af17d149845bbf8a9f21dc2a7f6.png">
      </p>
<ul>
<li>-Xms -Xmx -Xmn X是分标参数，m是memory，s是最小值，x是最大值，n是new,新生代的大小</li>
</ul>
<ol>
<li><p>部分垃圾回收器使用的模型</p>
<ul>
<li>除Epsilon ZGC Shenandoah之外的GC都是使用逻辑分代模型</li>
<li>G1是逻辑分代，物理不分代</li>
<li>除此之外不仅逻辑分代，而且物理分代</li>
</ul>
</li>
<li><p>新生代 + 老年代 + 永久代（1.7）Perm Generation/ 元数据区(1.8) Metaspace</p>
<ol>
<li>永久代 元数据 - 存放Class信息、代码编译信息等</li>
<li>永久代必须指定大小限制 ，元数据可以设置，也可以不设置，不设置受限于物理内存</li>
<li>字符串常量 1.7 - 永久代，1.8 - 堆</li>
<li>MethodArea是逻辑概念 - 他的实现在1.7叫永久代、1.8叫元数据</li>
<li>新生代、老年代是堆，永久代 元数据区是堆之外的空间</li>
</ol>
</li>
<li><p>新生代 = Eden + 2个suvivor区 （三个区域比例8:1:1）</p>
<ol>
<li>YGC回收之后，大多数的对象会被回收，活着的进入s0</li>
<li>再次YGC，活着的对象eden + s0 -&gt; s1</li>
<li>再次YGC，eden + s1 -&gt; s0</li>
<li>年龄足够 -&gt; 老年代 （可以指定，默认PS 15次，CMS 6次，G1 15次。注意：文件头中存贮次数的地方是4位，最大就是15）</li>
<li>s区装不下 -&gt; 老年代</li>
</ol>
</li>
<li><p>老年代（老年代：新生代 = 3:1）</p>
<ol>
<li>顽固分子</li>
<li>老年代满了FGC （Full GC）</li>
</ol>
</li>
<li><p>GC 调优(Generation分代模型)</p>
<ol>
<li>尽量减少FGC</li>
<li>MinorGC = YGC</li>
<li>MajorGC = FGC</li>
</ol>
</li>
<li><p>动态年龄：（不重要）<br>当YGC一次后，Eden和s0中的存活对象进入s1，如果超过s1容量的50%，其中年龄最大的对象会被放入老年代<br>参考：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.jianshu.com/p/989d3b06a49d" >https://www.jianshu.com/p/989d3b06a49d</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p>分配担保：（不重要）<br>YGC期间 survivor区空间不够了 空间担保直接进入老年代<br>参考：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1082730" >https://cloud.tencent.com/developer/article/1082730</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p>对象分配过程如下图：<br>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://pic.downk.cc/item/5f698b74160a154a671fae5c.png"  alt="86795f58498f8eb819d4b430c45742a6.png">
      <br>首先在栈上分配，如果能分配就分配到栈上，分配不下就会判断大不大（用一个参数制定），如果特别大，就直接进入old区，否则进去TLAB，到Eden区，进行FGC，如果没被清除还存活进入S1，再FGC还存活进S2，当年龄足够进入old区</p>
</li>
</ol>

        <h3 id="5-常见的垃圾回收器"   >
          <a href="#5-常见的垃圾回收器" class="heading-link"><i class="fas fa-link"></i></a>5.常见的垃圾回收器</h3>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://pic.downk.cc/item/5f698b8b160a154a671fbad9.png"  alt="aff0a0be7e69d5d1f359ff9162fd0300.png">
      </p>
<ul>
<li>JDK诞生时就是Serial，为了提高效率，诞生了PS，为了配合CMS，诞生了PN。CMS是1.4版本后期引入，CMS是里程碑式的GC，它开启了并发回收的过程，但是CMS毛病较多，因此目前任何一个JDK版本默认是CMS<ul>
<li>并发垃圾回收是因为无法忍受STW</li>
</ul>
</li>
</ul>
<ol>
<li>Serial 年轻代 串行回收（满了就在安全点上STW(stop-the-world)然后<strong>单线程</strong>回收，依次循环）</li>
<li>Parallel Scavenge(PS) 年轻代 并行回收（满了就STW(stop-the-world)然后<strong>多线程</strong>回收，依次循环） java14已弃用</li>
<li>ParNew 年轻代 对PS做了一些增强，能够配合CMS的并行回收</li>
<li>SerialOld 老年代的Serial  java14已弃用</li>
<li>ParallelOld 老年代的PS</li>
<li>ConcurrentMarkSweep 老年代 并发的， 垃圾回收和应用程序同时运行，降低STW的时间(200ms)<ul>
<li>CMS问题比较多，所以现在没有一个版本默认是CMS，只能手工指定</li>
<li>CMS既然是MarkSweep，就一定会有碎片化的问题，碎片到达一定程度，CMS的老年代分配对象分配不下的时候，使用SerialOld 进行老年代回收<br>想象一下：<br>PS + PO -&gt; 加内存 换垃圾回收器 -&gt; PN + CMS + SerialOld（几个小时 - 几天的STW）<br>几十个G的内存，单线程回收 -&gt; G1 + FGC 几十个G -&gt; 上T内存的服务器 ZGC<br>算法：三色标记 + Incremental Update</li>
</ul>
</li>
<li>G1(10ms)<br>算法：三色标记 + SATB</li>
<li>ZGC (1ms) 能够PK C++<br>算法：ColoredPointers + LoadBarrier（读屏障）</li>
<li>Shenandoah<br> 算法：ColoredPointers + WriteBarrier（写屏障）</li>
<li>Eplison</li>
<li>PS 和 PN区别的延伸阅读：<br>▪<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/13/gctuning/ergonomics.html" >https://docs.oracle.com/en/java/javase/13/gctuning/ergonomics.html#GUID-3D0BB91E-9BFF-4EBB-B523-14493A860E73</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li>垃圾收集器跟内存大小的关系<ol>
<li>Serial 几十兆</li>
<li>PS 上百兆 - 几个G</li>
<li>CMS - 20G</li>
<li>G1 - 上百G</li>
<li>ZGC - 4T - 16T（JDK13）</li>
</ol>
</li>
</ol>
<p><strong>1.8默认的垃圾回收：PS + ParallelOld（PO）</strong></p>

        <h2 id="常见垃圾回收器组合参数设定：-1-8"   >
          <a href="#常见垃圾回收器组合参数设定：-1-8" class="heading-link"><i class="fas fa-link"></i></a>常见垃圾回收器组合参数设定：(1.8)</h2>
      <ul>
<li><p>-XX:+UseSerialGC = Serial New (DefNew) + Serial Old</p>
<ul>
<li>小型程序。默认情况下不会是这种选项，HotSpot会根据计算及配置和JDK版本自动选择收集器</li>
</ul>
</li>
<li><p>-XX:+UseParNewGC = ParNew + SerialOld</p>
<ul>
<li>这个组合已经很少用（在某些版本中已经废弃）</li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://stackoverflow.com/questions/34962257/why-remove-support-for-parnewserialold-anddefnewcms-in-the-future" >https://stackoverflow.com/questions/34962257/why-remove-support-for-parnewserialold-anddefnewcms-in-the-future</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ul>
</li>
<li><p>-XX:+UseConc(urrent)MarkSweepGC = ParNew + CMS + Serial Old（括号内的内容在默写版本需要加上）</p>
</li>
<li><p>-XX:+UseParallelGC = Parallel Scavenge + Parallel Old (1.8默认) 【PS + SerialOld】</p>
</li>
<li><p>-XX:+UseParallelOldGC = Parallel Scavenge + Parallel Old</p>
</li>
<li><p>-XX:+UseG1GC = G1</p>
</li>
<li><p>Linux中没找到默认GC的查看方法，而windows中会打印UseParallelGC </p>
<ul>
<li>java +XX:+PrintCommandLineFlags -version</li>
<li>通过GC的日志来分辨</li>
</ul>
</li>
<li><p>Linux下1.8版本默认的垃圾回收器到底是什么？</p>
<ul>
<li>1.8.0_181 默认（看不出来）Copy MarkCompact</li>
<li>1.8.0_222 默认 PS + PO</li>
</ul>
</li>
</ul>

        <h2 id="JVM调优第一步，了解JVM常用命令行参数"   >
          <a href="#JVM调优第一步，了解JVM常用命令行参数" class="heading-link"><i class="fas fa-link"></i></a>JVM调优第一步，了解JVM常用命令行参数</h2>
      <ul>
<li><p>JVM的命令行参数参考：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html" >https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p>HotSpot参数分类</p>
<blockquote>
<p>标准： - 开头，所有的HotSpot都支持<br>非标准：-X 开头，特定版本HotSpot支持特定命令<br>不稳定：-XX 开头，下个版本可能取消</p>
</blockquote>
<p>java -version</p>
<p>java -X</p>
</li>
</ul>
<p>试验用程序：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> <span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloGC</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;HelloGC!&quot;</span>);</span><br><span class="line">     List list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">     <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">       <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">       list.add(b);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></div></figure>

<ol>
<li><p>区分概念：内存泄漏memory leak，内存溢出out of memory</p>
</li>
<li><p>java -XX:+PrintCommandLineFlags HelloGC</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://pic.downk.cc/item/5f698ba3160a154a671fc860.png"  alt="43b58700144c5f2022a5e21b30703d23.png">
      </p>
</li>
</ol>
<pre><code>    * InitialHeapSize 起始堆大小，根据内存算出来
    * MaxHeapSize 最大堆大小
    * UseCompressedClassPointers 默认
    * UseCompressedOops 普通指针压缩</code></pre>
<ol start="3">
<li><p>java -Xmn10M -Xms40M -Xmx60M -XX:+PrintCommandLineFlags -XX:+PrintGC  HelloGC<br> PrintGCDetails PrintGCTimeStamps PrintGCCauses</p>
<ul>
<li>Xms最小堆大小、Xmx最大堆大小，一般情况下设置成一样的，不要让他产生弹性压缩浪费系统资源</li>
<li>-XX:+PrintGC 打印GC回收的信息</li>
<li>PrintGCDetails 打印更详细的GC信息</li>
<li>PrintGCTimeStamps 打印GC产生是系统的详细时间</li>
<li>PrintGCCauses 打印GC产生的原因<br>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://pic.downk.cc/item/5f698be3160a154a671ff161.png"  alt="0e63ffb24d2f6aa3f2fa6caf06ef784d.png">
      </li>
</ul>
</li>
<li><p>java -XX:+UseConcMarkSweepGC -XX:+PrintCommandLineFlags HelloGC</p>
<ul>
<li>设置CMS GC，-XX:+PrintGC打印CMS的GC跟上面差不多，会多一些CMS的详细的阶段过程</li>
</ul>
</li>
<li><p>java -XX:+PrintFlagsInitial 默认参数值</p>
</li>
<li><p>java -XX:+PrintFlagsFinal 最终参数值</p>
</li>
<li><p>java -XX:+PrintFlagsFinal | grep xxx 找到对应的参数</p>
</li>
<li><p>java -XX:+PrintFlagsFinal -version |grep GC</p>
</li>
</ol>

        <h2 id="PS-GC日志详解"   >
          <a href="#PS-GC日志详解" class="heading-link"><i class="fas fa-link"></i></a>PS GC日志详解</h2>
      <p>每种垃圾回收器的日志格式是不同的！</p>
<p>PS日志格式</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://pic.downk.cc/item/5f698c07160a154a672007e8.png"  alt="c8ecb28583f3c664174e204aded82a78.png">
      </p>
<p>heap dump部分（内存溢出，会打印堆的信息）：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eden space <span class="number">5632</span>K, <span class="number">94</span>% used [<span class="number">0x00000000ff980000</span>,<span class="number">0x00000000ffeb3e28</span>,<span class="number">0x00000000fff00000</span>)</span><br><span class="line"><span class="comment">//三个地址分别是：内存起始地址、使用空间结束地址、整体空间结束地址</span></span><br><span class="line"><span class="comment">//eden区整体大小5632k，使用了94%，eden区地址是从 第1个地址 开始到 第3个地址 结束，其中从第1个地址到了第2个地址是已经使用的，占94%</span></span><br></pre></td></tr></table></div></figure>

<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://pic.downk.cc/item/5f698c07160a154a672007e2.png"  alt="62119ba3f0733d7ffd4d5b15ef40035b.png">
      </p>
<p>total = eden + 1个survivor</p>

        <h2 id="调优"   >
          <a href="#调优" class="heading-link"><i class="fas fa-link"></i></a>调优</h2>
      
        <h3 id="调优前的基础概念："   >
          <a href="#调优前的基础概念：" class="heading-link"><i class="fas fa-link"></i></a>调优前的基础概念：</h3>
      <ol>
<li>吞吐量：用户代码时间 /（用户代码执行时间 + 垃圾回收时间）</li>
<li>响应时间：STW越短，响应时间越好</li>
</ol>
<p>所谓调优，首先确定，追求啥？吞吐量优先，还是响应时间优先？还是在满足一定的响应时间的情况下，要求达到多大的吞吐量…</p>
<p>问题：</p>
<p>科学计算，吞吐量。数据挖掘，吞吐量。吞吐量优先的一般：（PS + PO）</p>
<p>响应时间：网站 GUI API （1.8 G1）</p>

        <h3 id="什么是调优？"   >
          <a href="#什么是调优？" class="heading-link"><i class="fas fa-link"></i></a>什么是调优？</h3>
      <ol>
<li>根据需求进行JVM规划和预调优</li>
<li>优化运行JVM运行环境（慢，卡顿）</li>
<li>解决JVM运行过程中出现的各种问题(OOM)</li>
</ol>

        <h3 id="解决JVM运行中的问题"   >
          <a href="#解决JVM运行中的问题" class="heading-link"><i class="fas fa-link"></i></a>解决JVM运行中的问题</h3>
      
        <h4 id="一个案例理解常用工具"   >
          <a href="#一个案例理解常用工具" class="heading-link"><i class="fas fa-link"></i></a>一个案例理解常用工具</h4>
      <ol>
<li>测试代码：</li>
</ol>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.jvm.gc;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line">   <span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line">   <span class="keyword">import</span> java.util.Date;</span><br><span class="line">   <span class="keyword">import</span> java.util.List;</span><br><span class="line">   <span class="keyword">import</span> java.util.concurrent.ScheduledThreadPoolExecutor;</span><br><span class="line">   <span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line">   <span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 从数据库中读取信用数据，套用模型，并把结果进行记录和传输</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T15_FullGC_Problem01</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CardInfo</span> </span>&#123;</span><br><span class="line">           BigDecimal price = <span class="keyword">new</span> BigDecimal(<span class="number">0.0</span>);</span><br><span class="line">           String name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">           <span class="keyword">int</span> age = <span class="number">5</span>;</span><br><span class="line">           Date birthdate = <span class="keyword">new</span> Date();</span><br><span class="line">   </span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> ScheduledThreadPoolExecutor executor = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">50</span>,</span><br><span class="line">               <span class="keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy());</span><br><span class="line">   </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">           executor.setMaximumPoolSize(<span class="number">50</span>);</span><br><span class="line">   </span><br><span class="line">           <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">               modelFit();</span><br><span class="line">               Thread.sleep(<span class="number">100</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">modelFit</span><span class="params">()</span></span>&#123;</span><br><span class="line">           List&lt;CardInfo&gt; taskList = getAllCardInfo();</span><br><span class="line">           taskList.forEach(info -&gt; &#123;</span><br><span class="line">               <span class="comment">// do something</span></span><br><span class="line">               executor.scheduleWithFixedDelay(() -&gt; &#123;</span><br><span class="line">                   <span class="comment">//do sth with info</span></span><br><span class="line">                   info.m();</span><br><span class="line">   </span><br><span class="line">               &#125;, <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;CardInfo&gt; <span class="title">getAllCardInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">           List&lt;CardInfo&gt; taskList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   </span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">               CardInfo ci = <span class="keyword">new</span> CardInfo();</span><br><span class="line">               taskList.add(ci);</span><br><span class="line">           &#125;</span><br><span class="line">   </span><br><span class="line">           <span class="keyword">return</span> taskList;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>

<p>使用命令运行 java -Xms200M -Xmx200M -XX:+PrintGC com.mashibing.jvm.gc.T15_FullGC_Problem01</p>
<ul>
<li>一般是运维团队首先受到报警信息（CPU Memory），如何定位问题</li>
</ul>
<ol>
<li><p>传统命令行，<strong>top</strong>命令观察到问题：内存不断增长 CPU占用率居高不下</p>
</li>
<li><p>top -Hp 观察进程中的线程，哪个线程CPU和内存占比高</p>
</li>
<li><p><strong>jps</strong>定位具体java进程； <strong>jstack</strong> 定位线程状况，重点关注：WAITING BLOCKED<br>例如：<br>waiting on &lt;0x0000000088ca3310&gt; (a java.lang.Object)<br>假如有一个进程中100个线程，很多线程都在waiting on <xx> ，一定要找到是哪个线程持有这把锁<br>怎么找？搜索jstack dump的信息，找<xx> ，看哪个线程持有这把锁，这个线程状态可能是RUNNABLE</p>
</li>
<li><p>为什么阿里规范里规定，线程的名称（尤其是线程池）都要写有意义的名称<br>怎么样自定义线程池里的线程名称？（自定义ThreadFactory）</p>
</li>
<li><p><strong>jinfo</strong> pid </p>
</li>
<li><p><strong>jstat</strong> -gc 动态观察gc情况 / 阅读GC日志发现频繁GC / arthas观察 / jconsole/jvisualVM/ Jprofiler（最好用）<br>jstat -gc 4655 500 : 每个500个毫秒打印GC的情况<br>如果面试官问你是怎么定位OOM问题的？如果你回答用图形界面（错误）<br>1：已经上线的系统不用图形界面用什么？（cmd line(命令行)、arthas）<br>2：图形界面到底用在什么地方？测试！测试的时候进行监控！（压测观察）</p>
</li>
<li><p><strong>jmap</strong> - histo 4655 | head -20，查找有多少对象产生，线上环境定位可以用</p>
</li>
<li><p>jmap -dump:format=b,file=xxx pid ：<br>线上系统，内存特别大，jmap执行堆转储期间会对进程产生很大影响，甚至卡顿（电商不适合），这时候怎么办？<br>1：设定了参数HeapDump，OOM的时候会自动产生堆转储文件<br>2：很多服务器备份（高可用），停掉这台服务器对其他服务器不影响（首选说法）<br>3：在线定位(一般小点儿公司用不到)</p>
<ul>
<li>我了解jmap一旦执行了堆转储对线上系统影响比较大，所以我们做了隔离，先把那台机器隔离开然后再做这件事</li>
</ul>
</li>
<li><p>java -Xms20M -Xmx20M -XX:+UseParallelGC -XX:+HeapDumpOnOutOfMemoryError com.mashibing.jvm.gc.T15_FullGC_Problem01</p>
</li>
<li><p>使用MAT / jhat /jvisualvm 进行dump文件分析<br> <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/baihuitestsoftware/articles/6406271.html" >https://www.cnblogs.com/baihuitestsoftware/articles/6406271.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </p>
<ul>
<li>jhat -J-mx512M xxx.dump</li>
</ul>
<p>-J-mx512M设定最大使用内存<br><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://192.168.17.11:7000/" >http://192.168.17.11:7000</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>拉到最后：找到对应链接<br>可以使用OQL查找特定问题对象</p>
</li>
<li><p>系统已经oom了怎么到处dump文件？</p>
<ol>
<li>指定XX:+HeapDumpOnOutOfMemoryError参数会自动生成，不过如果是大内存，会很慢</li>
<li>oom后不要重启，使用jmap命令</li>
</ol>
</li>
<li><p>找到代码的问题</p>
<ul>
<li>cpu/内存飚高-&gt;top/jps命令查-&gt;cpu高可能是死循环死锁，用jstat看哪个县城有问题 -频繁GC有对象回收不了用jmap导出来分析</li>
</ul>
</li>
</ol>

        <h5 id="jconsole远程连接"   >
          <a href="#jconsole远程连接" class="heading-link"><i class="fas fa-link"></i></a>jconsole远程连接</h5>
      <ol>
<li>程序启动加入参数：</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.rmi.server.hostname=192.168.17.11 -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=11111 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false XXX</span><br></pre></td></tr></table></div></figure>

<ol start="2">
<li>如果遭遇 Local host name unknown：XXX的错误，修改/etc/hosts文件，把XXX加入进去</li>
</ol>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192.168</span>.<span class="number">17.11</span> basic localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::<span class="number">1</span>         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br></pre></td></tr></table></div></figure>

<ol start="3">
<li>关闭linux防火墙（实战中应该打开对应端口）</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service iptables stop</span><br><span class="line">chkconfig iptables off #永久关闭</span><br></pre></td></tr></table></div></figure>
<ol start="4">
<li>windows上打开 jconsole远程连接 192.168.17.11:11111</li>
</ol>

        <h5 id="jvisualvm远程连接"   >
          <a href="#jvisualvm远程连接" class="heading-link"><i class="fas fa-link"></i></a>jvisualvm远程连接</h5>
      <p> <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/liugh/p/7620336.html" >https://www.cnblogs.com/liugh/p/7620336.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> （简单做法）</p>

        <h5 id="jprofiler-收费"   >
          <a href="#jprofiler-收费" class="heading-link"><i class="fas fa-link"></i></a>jprofiler (收费)</h5>
      
        <h5 id="arthas在线排查工具"   >
          <a href="#arthas在线排查工具" class="heading-link"><i class="fas fa-link"></i></a>arthas在线排查工具</h5>
      <ul>
<li>为什么需要在线排查？<br> 在生产上我们经常会碰到一些不好排查的问题，例如线程安全问题，用最简单的threaddump或者heapdump不好查到问题原因。为了排查这些问题，有时我们会临时加一些日志，比如在一些关键的函数里打印出入参，然后重新打包发布，如果打了日志还是没找到问题，继续加日志，重新打包发布。对于上线流程复杂而且审核比较严的公司，从改代码到上线需要层层的流转，会大大影响问题排查的进度。 </li>
<li>jvm观察jvm信息</li>
<li>thread观察定位线程问题</li>
<li>dashboard 观察系统情况</li>
<li>heapdump + jhat分析</li>
<li>jad反编译<br> 动态代理生成类的问题定位<br> 第三方的类（观察代码）<br> 版本问题（确定自己最新提交的版本是不是被使用）</li>
<li>redefine 热替换<br> 目前有些限制条件：只能改方法实现（方法已经运行完成），不能改方法名， 不能改属性</li>
<li>sc  - search class</li>
<li>watch  - watch method</li>
<li>没有包含的功能：jmap（查找有多少对象产生未包含）</li>
</ul>

        <h3 id="GC算法的基础概念"   >
          <a href="#GC算法的基础概念" class="heading-link"><i class="fas fa-link"></i></a>GC算法的基础概念</h3>
      <ul>
<li>Card Table<br>由于做YGC时，需要扫描整个OLD区，效率非常低，所以JVM设计了CardTable， 如果一个OLD区CardTable中有对象指向Y区，就将它设为Dirty（脏的），下次扫描时，只需要扫描Dirty Card<br>在结构上，Card Table用BitMap来实现</li>
</ul>

        <h3 id="三色标记算法"   >
          <a href="#三色标记算法" class="heading-link"><i class="fas fa-link"></i></a>三色标记算法</h3>
      <ul>
<li>白色：未被标记的对象</li>
<li>灰色：自身被标记，成员变量（它引用的对象）未被标记</li>
<li>黑色：自身和成员变量都被标记</li>
</ul>

        <h4 id="漏标问题及解决方案"   >
          <a href="#漏标问题及解决方案" class="heading-link"><i class="fas fa-link"></i></a>漏标问题及解决方案</h4>
      <p>漏标是指，当黑色指向白色，指向白色的其他引用没了，此时白色是存活对象但是没有被标记，就会被当成垃圾回收掉。<br>解决：</p>
<ul>
<li>incremental update – 增量更新，跟踪引用的增加，把黑色重新标记为灰色（CMS使用这种方式）</li>
<li>SATB – 关注引用的删除，当引用消失时，把这个引用放到GC的堆栈，保证消失的引用还能被GC扫描到（G1使用）</li>
<li>为什么G1使用SATB？<ol>
<li>因为第一种方式标记为灰色之后，还要重新扫描，效率低</li>
<li>灰色指向白色的引用消失时，如果没有黑色指向白色，引用会被push到堆栈，下次扫描时拿到这个引用，由于有RSet，不需要扫描整个堆去查找指向白色的引用，SATB配合RSet效率高</li>
</ol>
</li>
</ul>

        <h3 id="CMS"   >
          <a href="#CMS" class="heading-link"><i class="fas fa-link"></i></a>CMS</h3>
      
        <h4 id="CMS的问题"   >
          <a href="#CMS的问题" class="heading-link"><i class="fas fa-link"></i></a>CMS的问题</h4>
      <ol>
<li><p>Memory Fragmentation 内存碎片化</p>
<blockquote>
<p>-XX:+UseCMSCompactAtFullCollection<br>-XX:CMSFullGCsBeforeCompaction 默认为0 指的是经过多少次FGC才进行压缩</p>
</blockquote>
</li>
<li><p>Floating Garbage 浮动垃圾</p>
<blockquote>
<p>Concurrent Mode Failure<br>产生：if the concurrent collector is unable to finish reclaiming the unreachable objects before the tenured generation fills up, or if an allocation cannot be satisfiedwith the available free space blocks in the tenured generation, then theapplication is paused and the collection is completed with all the applicationthreads stopped</p>
<p>解决方案：<strong>降低触发CMS的阈值</strong></p>
<p>PromotionFailed</p>
<p>解决方案类似，保持老年代有足够的空间</p>
<p>–XX:CMSInitiatingOccupancyFraction 92% 可以降低这个值，让CMS保持老年代足够的空间</p>
</blockquote>
</li>
</ol>

        <h4 id="CMS日志分析"   >
          <a href="#CMS日志分析" class="heading-link"><i class="fas fa-link"></i></a>CMS日志分析</h4>
      <p>执行命令：java -Xms20M -Xmx20M -XX:+PrintGCDetails -XX:+UseConcMarkSweepGC com.mashibing.jvm.gc.T15_FullGC_Problem01</p>
<p>[GC (Allocation Failure) [ParNew: 6144K-&gt;640K(6144K), 0.0265885 secs] 6585K-&gt;2770K(19840K), 0.0268035 secs] [Times: user=0.02 sys=0.00, real=0.02 secs] </p>
<blockquote>
<p>ParNew：年轻代收集器</p>
<p>6144-&gt;640：收集前后的对比</p>
<p>（6144）：整个年轻代容量</p>
<p>6585 -&gt; 2770：整个堆的情况</p>
<p>（19840）：整个堆大小</p>
</blockquote>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[GC (CMS Initial Mark) [<span class="number">1</span> CMS-initial-mark: <span class="number">8511</span>K(<span class="number">13696</span>K)] <span class="number">9866</span>K(<span class="number">19840</span>K), <span class="number">0.0040321</span> secs] [Times: user=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">	<span class="comment">//8511 (13696) : 老年代使用（最大）</span></span><br><span class="line">	<span class="comment">//9866 (19840) : 整个堆使用（最大）</span></span><br><span class="line">[CMS-concurrent-mark-start]</span><br><span class="line">[CMS-concurrent-mark: <span class="number">0.018</span>/<span class="number">0.018</span> secs] [Times: user=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.02</span> secs] </span><br><span class="line">	<span class="comment">//这里的时间意义不大，因为是并发执行</span></span><br><span class="line">[CMS-concurrent-preclean-start]</span><br><span class="line">[CMS-concurrent-preclean: <span class="number">0.000</span>/<span class="number">0.000</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">	<span class="comment">//标记Card为Dirty，也称为Card Marking</span></span><br><span class="line">[GC (CMS Final Remark) [YG occupancy: 1597 K (6144 K)][Rescan (parallel) , 0.0008396 secs][weak refs processing, 0.0000138 secs][class unloading, 0.0005404 secs][scrub symbol table, 0.0006169 secs][scrub string table, 0.0004903 secs][1 CMS-remark: 8511K(13696K)] 10108K(19840K), 0.0039567 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">	<span class="comment">//STW阶段，YG occupancy:年轻代占用及容量</span></span><br><span class="line">	<span class="comment">//[Rescan (parallel)：STW下的存活对象标记</span></span><br><span class="line">	<span class="comment">//weak refs processing: 弱引用处理</span></span><br><span class="line">	<span class="comment">//class unloading: 卸载用不到的class</span></span><br><span class="line">	<span class="comment">//scrub symbol(string) table: </span></span><br><span class="line">		<span class="comment">//cleaning up symbol and string tables which hold class-level metadata and </span></span><br><span class="line">		<span class="comment">//internalized string respectively</span></span><br><span class="line">	<span class="comment">//CMS-remark: 8511K(13696K): 阶段过后的老年代占用及容量</span></span><br><span class="line">	<span class="comment">//10108K(19840K): 阶段过后的堆占用及容量</span></span><br><span class="line"></span><br><span class="line">[CMS-concurrent-sweep-start]</span><br><span class="line">[CMS-concurrent-sweep: <span class="number">0.005</span>/<span class="number">0.005</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">	<span class="comment">//标记已经完成，进行并发清理</span></span><br><span class="line">[CMS-concurrent-reset-start]</span><br><span class="line">[CMS-concurrent-reset: <span class="number">0.000</span>/<span class="number">0.000</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs]</span><br><span class="line">	<span class="comment">//重置内部结构，为下次GC做准备</span></span><br></pre></td></tr></table></div></figure>




        <h3 id="G1"   >
          <a href="#G1" class="heading-link"><i class="fas fa-link"></i></a>G1</h3>
      <ol>
<li>▪<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.oracle.com/technical-resources/articles/java/g1gc.html" >https://www.oracle.com/technical-resources/articles/java/g1gc.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ol>

        <h4 id="G1逻辑分层，物理不分层"   >
          <a href="#G1逻辑分层，物理不分层" class="heading-link"><i class="fas fa-link"></i></a>G1逻辑分层，物理不分层</h4>
      <p>G1吧内存分为一小块一小块的区域，old区存放老年对象；Survivor区存放存活对象；Eden区存放新生对象；Humongous存放大对象。某一个区域可能是年轻代也可能是老年代，但是在同一时刻只能属于某个时代</p>

        <h4 id="G1特点"   >
          <a href="#G1特点" class="heading-link"><i class="fas fa-link"></i></a>G1特点</h4>
      <ul>
<li>并发收集</li>
<li>压缩空闲空间不会延长GC的暂停时间</li>
<li>更容易的预测GC暂停时间</li>
<li>适用于不需要很高吞吐量的场景</li>
<li>G1的内存区域不是固定的E或O，可能是年轻代也可能是老年代，但是在同一时刻只能属于某个时代</li>
<li>新老年代比例是动态的，最好不要手工指定，因为这是G1预测停顿时间的基准</li>
</ul>

        <h4 id="CSet"   >
          <a href="#CSet" class="heading-link"><i class="fas fa-link"></i></a>CSet</h4>
      <p>有哪些需要被回收，会收集到表格里</p>

        <h4 id="RSet"   >
          <a href="#RSet" class="heading-link"><i class="fas fa-link"></i></a>RSet</h4>
      <p>每一个Region（区域）里面都会有一个hash表，记录了其他Region中的对象到本Region的引用<br>作用：使得垃圾回收器不需要扫描整个堆找到谁引用了当前分区中的对象，只需要扫描RSet即可</p>

        <h4 id="G1日志详解"   >
          <a href="#G1日志详解" class="heading-link"><i class="fas fa-link"></i></a>G1日志详解</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[<span class="function">GC <span class="title">pause</span> <span class="params">(G1 Evacuation Pause)</span> <span class="params">(young)</span> <span class="params">(initial-mark)</span>, 0.0015790 secs]</span></span><br><span class="line"><span class="function"><span class="comment">//young -&gt; 年轻代 Evacuation-&gt; 复制存活对象 </span></span></span><br><span class="line"><span class="function"><span class="comment">//initial-mark 混合回收的阶段，这里是YGC混合老年代回收</span></span></span><br><span class="line"><span class="function">   [Parallel Time: 1.5 ms, GC Workers: 1] <span class="comment">//一个GC线程</span></span></span><br><span class="line"><span class="function">      [GC Worker <span class="title">Start</span> <span class="params">(ms)</span>:  92635.7]</span></span><br><span class="line"><span class="function">      [Ext Root <span class="title">Scanning</span> <span class="params">(ms)</span>:  1.1]</span></span><br><span class="line"><span class="function">      [Update <span class="title">RS</span> <span class="params">(ms)</span>:  0.0]</span></span><br><span class="line"><span class="function">         [Processed Buffers:  1]</span></span><br><span class="line"><span class="function">      [Scan <span class="title">RS</span> <span class="params">(ms)</span>:  0.0]</span></span><br><span class="line"><span class="function">      [Code Root <span class="title">Scanning</span> <span class="params">(ms)</span>:  0.0]</span></span><br><span class="line"><span class="function">      [Object <span class="title">Copy</span> <span class="params">(ms)</span>:  0.1]</span></span><br><span class="line"><span class="function">      [<span class="title">Termination</span> <span class="params">(ms)</span>:  0.0]</span></span><br><span class="line"><span class="function">         [Termination Attempts:  1]</span></span><br><span class="line"><span class="function">      [GC Worker <span class="title">Other</span> <span class="params">(ms)</span>:  0.0]</span></span><br><span class="line"><span class="function">      [GC Worker <span class="title">Total</span> <span class="params">(ms)</span>:  1.2]</span></span><br><span class="line"><span class="function">      [GC Worker <span class="title">End</span> <span class="params">(ms)</span>:  92636.9]</span></span><br><span class="line"><span class="function">   [Code Root Fixup: 0.0 ms]</span></span><br><span class="line"><span class="function">   [Code Root Purge: 0.0 ms]</span></span><br><span class="line"><span class="function">   [Clear CT: 0.0 ms]</span></span><br><span class="line"><span class="function">   [Other: 0.1 ms]</span></span><br><span class="line"><span class="function">      [Choose CSet: 0.0 ms]</span></span><br><span class="line"><span class="function">      [Ref Proc: 0.0 ms]</span></span><br><span class="line"><span class="function">      [Ref Enq: 0.0 ms]</span></span><br><span class="line"><span class="function">      [Redirty Cards: 0.0 ms]</span></span><br><span class="line"><span class="function">      [Humongous Register: 0.0 ms]</span></span><br><span class="line"><span class="function">      [Humongous Reclaim: 0.0 ms]</span></span><br><span class="line"><span class="function">      [Free CSet: 0.0 ms]</span></span><br><span class="line"><span class="function">   [Eden: 0.0<span class="title">B</span><span class="params">(<span class="number">1024.0</span>K)</span>-&gt;0.0<span class="title">B</span><span class="params">(<span class="number">1024.0</span>K)</span> Survivors: 0.0B-&gt;0.0B Heap: 18.8<span class="title">M</span><span class="params">(<span class="number">20.0</span>M)</span>-&gt;18.8<span class="title">M</span><span class="params">(<span class="number">20.0</span>M)</span>]</span></span><br><span class="line"><span class="function"> [Times: user</span>=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line"><span class="comment">//以下是混合回收其他阶段</span></span><br><span class="line">[GC concurrent-root-region-scan-start]</span><br><span class="line">[GC concurrent-root-region-scan-end, <span class="number">0.0000078</span> secs]</span><br><span class="line">[GC concurrent-mark-start]</span><br><span class="line"><span class="comment">//无法evacuation，进行FGC</span></span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(Allocation Failure)</span>  18M-&gt;18<span class="title">M</span><span class="params">(<span class="number">20</span>M)</span>, 0.0719656 secs]</span></span><br><span class="line"><span class="function">   [Eden: 0.0<span class="title">B</span><span class="params">(<span class="number">1024.0</span>K)</span>-&gt;0.0<span class="title">B</span><span class="params">(<span class="number">1024.0</span>K)</span> Survivors: 0.0B-&gt;0.0B Heap: 18.8<span class="title">M</span><span class="params">(<span class="number">20.0</span>M)</span>-&gt;18.8<span class="title">M</span><span class="params">(<span class="number">20.0</span>M)</span>], [Metaspace: 38</span></span><br><span class="line"><span class="function">76K-&gt;3876<span class="title">K</span><span class="params">(<span class="number">1056768</span>K)</span>] [Times: user</span>=<span class="number">0.07</span> sys=<span class="number">0.00</span>, real=<span class="number">0.07</span> secs]</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>





        <h3 id="GC常用参数"   >
          <a href="#GC常用参数" class="heading-link"><i class="fas fa-link"></i></a>GC常用参数</h3>
      <ul>
<li>-Xmn -Xms -Xmx -Xss<br>年轻代 最小堆 最大堆 栈空间</li>
<li>-XX:+UseTLAB<br>使用TLAB，默认打开</li>
<li>-XX:+PrintTLAB<br>打印TLAB的使用情况</li>
<li>-XX:TLABSize<br>设置TLAB大小<pre><code>  这三个一般不用动</code></pre>
</li>
<li>-XX:+DisableExplictGC<br>System.gc()不管用 ，FGC。线上系统一般都要设置</li>
<li>-XX:+PrintGC<br>打印GC信息</li>
<li>-XX:+PrintGCDetails<br>打印GC的详细信息</li>
<li>-XX:+PrintHeapAtGC<br>GC打印堆栈情况</li>
<li>-XX:+PrintGCTimeStamps<br>发生GC的系统时间</li>
<li>-XX:+PrintGCApplicationConcurrentTime (重要性低)<br>打印应用程序时间</li>
<li>-XX:+PrintGCApplicationStoppedTime （重要性低）<br>打印暂停时长</li>
<li>-XX:+PrintReferenceGC （重要性低）<br>记录回收了多少种不同引用类型的引用</li>
<li>-verbose:class<br>类加载详细过程</li>
<li>-XX:+PrintVMOptions<br>打印JVM的参数</li>
<li>-XX:+<strong>PrintFlagsFinal</strong>  -XX:+PrintFlagsInitial<br>  分别是最终的初始化/默认参数<br>必须会用</li>
<li>-Xloggc:opt/log/gc.log<br>记录GC日志</li>
<li>-XX:MaxTenuringThreshold<br>GC升代年龄，最大值15</li>
<li>-XX:PreBlockSpin 锁自旋次数 -XX:CompileThreshold 热点代码检测参数 逃逸分析 标量替换 …<br>这些不建议设置</li>
</ul>

        <h3 id="Parallel常用参数"   >
          <a href="#Parallel常用参数" class="heading-link"><i class="fas fa-link"></i></a>Parallel常用参数</h3>
      <ul>
<li>-XX:SurvivorRatio<br>Survivor区比例，默认8:1:1，可以调，很少动</li>
<li>-XX:PreTenureSizeThreshold<br>大对象到底多大，通过这个指定</li>
<li>-XX:MaxTenuringThreshold<br>GC升代年龄，最大值15</li>
<li>-XX:+ParallelGCThreads<br>并行收集器的线程数，同样适用于CMS，一般设为和CPU核数相同。一般不会调，会自动检测设置</li>
<li>-XX:+UseAdaptiveSizePolicy<br>自动选择各区大小比例</li>
</ul>

        <h3 id="CMS常用参数"   >
          <a href="#CMS常用参数" class="heading-link"><i class="fas fa-link"></i></a>CMS常用参数</h3>
      <ul>
<li>-XX:+UseConcMarkSweepGC<br>CMS启动</li>
<li>-XX:ParallelCMSThreads<br>CMS线程数量，默认是核数的一半</li>
<li>-XX:CMSInitiatingOccupancyFraction<br>使用多少比例的老年代后开始CMS收集，默认是68%(近似值)，如果频繁发生SerialOld卡顿，应该调小，（频繁CMS回收）</li>
<li>-XX:+UseCMSCompactAtFullCollection<br>在FGC时进行压缩</li>
<li>-XX:CMSFullGCsBeforeCompaction<br>多少次FGC之后进行压缩</li>
<li>-XX:+CMSClassUnloadingEnabled<br> 回收永久代（1.8之前的）</li>
<li>-XX:CMSInitiatingPermOccupancyFraction<br>达到什么比例时进行Perm回收（1.8之前的）</li>
<li>GCTimeRatio<br>设置GC时间占用程序运行时间的百分比，是一个建议时间，GC会尝试用各种手段达到这个时间</li>
<li>-XX:MaxGCPauseMillis<br>停顿时间，是一个建议时间，GC会尝试用各种手段达到这个时间，比如减小年轻代</li>
</ul>

        <h3 id="G1常用参数"   >
          <a href="#G1常用参数" class="heading-link"><i class="fas fa-link"></i></a>G1常用参数</h3>
      <ul>
<li>-XX:+UseG1GC<br>  使用G1 GC</li>
<li>-XX:MaxGCPauseMillis<br>停顿时间，是一个建议时间，G1会尝试调整Young区的块数来达到这个值</li>
<li>-XX:GCPauseIntervalMillis<br>？GC的间隔时间，再查一下</li>
<li>-XX:+G1HeapRegionSize<br>分区大小，建议逐渐增大该值，1 2 4 8 16 32。<br>随着size增加，垃圾的存活时间更长，GC间隔更长，但每次GC的时间也会更长<br>ZGC做了改进（动态区块大小）</li>
<li>G1NewSizePercent<br>新生代最小比例，默认为5%</li>
<li>G1MaxNewSizePercent<br>新生代最大比例，默认为60%</li>
<li>GCTimeRatio<br>GC时间建议比例，G1会根据这个值调整堆空间</li>
<li>ConcGCThreads<br>线程数量</li>
<li>InitiatingHeapOccupancyPercent<br>启动G1的堆空间占用比例</li>
</ul>

        <h3 id="参考资料"   >
          <a href="#参考资料" class="heading-link"><i class="fas fa-link"></i></a>参考资料</h3>
      <ol>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blogs.oracle.com/jonthecollector/our-collectors" >https://blogs.oracle.com/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blogs.oracle.com/jonthecollector/our-collectors" >jonthecollector</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blogs.oracle.com/jonthecollector/our-collectors" >/our-collectors</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html" >https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp" >http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li>JVM调优参考文档：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/13/gctuning/introduction-garbage-collection-tuning.html#GUID-8A443184-7E07-4B71-9777-4F12947C8184" >https://docs.oracle.com/en/java/javase/13/gctuning/introduction-garbage-collection-tuning.html#GUID-8A443184-7E07-4B71-9777-4F12947C8184</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/nxlhero/p/11660854.html" >https://www.cnblogs.com/nxlhero/p/11660854.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 在线排查工具</li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.jianshu.com/p/507f7e0cc3a3" >https://www.jianshu.com/p/507f7e0cc3a3</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> arthas常用命令</li>
<li>Arthas手册：<ol>
<li>启动arthas java -jar arthas-boot.jar</li>
<li>绑定java进程</li>
<li>dashboard命令观察系统整体情况</li>
<li>help 查看帮助</li>
<li>help xx 查看具体命令帮助</li>
</ol>
</li>
<li>jmap命令参考： <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.jianshu.com/p/507f7e0cc3a3" >https://www.jianshu.com/p/507f7e0cc3a3</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> <ol>
<li>jmap -heap pid</li>
<li>jmap -histo pid</li>
<li>jmap -clstats pid</li>
</ol>
</li>
</ol>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://bugordemo.github.io">hyf</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://bugordemo.github.io/2020/09/22/GC%E5%92%8CGC-Tuning/">https://bugordemo.github.io/2020/09/22/GC%E5%92%8CGC-Tuning/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://bugordemo.github.io/tags/JVM/">JVM</a></span></div><div class="post-reward reward"><div class="reward-button">请我喝杯咖啡~</div><div class="reward-qrcode"><span class="reward-qrcode-alipay"><img class="reward-qrcode-alipay__img" src="/assets/alipay.jpg"><div class="reward-qrcode-alipay__text">支付宝打赏</div></span><span class="reward-qrcode-wechat"><img class="reward-qrcode-wechat__img" src="/assets/wechat.jpg"><div class="reward-qrcode-wechat__text">微信打赏</div></span></div></div><nav class="post-paginator paginator"><div class="paginator-next"><a class="paginator-next__link" href="/2020/09/22/java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%92%8C%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"><span class="paginator-prev__text">java运行时数据区和常用指令</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#GC%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">
          GC的基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%83%E5%9C%BE"><span class="toc-number">1.1.</span> <span class="toc-text">
          1.什么是垃圾</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E5%9E%83%E5%9C%BE"><span class="toc-number">1.2.</span> <span class="toc-text">
          2.如何定位垃圾</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.</span> <span class="toc-text">
          3.常见的垃圾回收算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-JVM%E5%86%85%E5%AD%98%E5%88%86%E4%BB%A3%E6%A8%A1%E5%9E%8B%EF%BC%88%E7%94%A8%E4%BA%8E%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-number">1.4.</span> <span class="toc-text">
          4.JVM内存分代模型（用于分代垃圾回收算法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">1.5.</span> <span class="toc-text">
          5.常见的垃圾回收器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%BB%84%E5%90%88%E5%8F%82%E6%95%B0%E8%AE%BE%E5%AE%9A%EF%BC%9A-1-8"><span class="toc-number">2.</span> <span class="toc-text">
          常见垃圾回收器组合参数设定：(1.8)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E8%B0%83%E4%BC%98%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%8C%E4%BA%86%E8%A7%A3JVM%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="toc-number">3.</span> <span class="toc-text">
          JVM调优第一步，了解JVM常用命令行参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PS-GC%E6%97%A5%E5%BF%97%E8%AF%A6%E8%A7%A3"><span class="toc-number">4.</span> <span class="toc-text">
          PS GC日志详解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E4%BC%98"><span class="toc-number">5.</span> <span class="toc-text">
          调优</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E4%BC%98%E5%89%8D%E7%9A%84%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-number">5.1.</span> <span class="toc-text">
          调优前的基础概念：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%B0%83%E4%BC%98%EF%BC%9F"><span class="toc-number">5.2.</span> <span class="toc-text">
          什么是调优？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3JVM%E8%BF%90%E8%A1%8C%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">5.3.</span> <span class="toc-text">
          解决JVM运行中的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E6%A1%88%E4%BE%8B%E7%90%86%E8%A7%A3%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="toc-number">5.3.1.</span> <span class="toc-text">
          一个案例理解常用工具</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#jconsole%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5"><span class="toc-number">5.3.1.1.</span> <span class="toc-text">
          jconsole远程连接</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#jvisualvm%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5"><span class="toc-number">5.3.1.2.</span> <span class="toc-text">
          jvisualvm远程连接</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#jprofiler-%E6%94%B6%E8%B4%B9"><span class="toc-number">5.3.1.3.</span> <span class="toc-text">
          jprofiler (收费)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#arthas%E5%9C%A8%E7%BA%BF%E6%8E%92%E6%9F%A5%E5%B7%A5%E5%85%B7"><span class="toc-number">5.3.1.4.</span> <span class="toc-text">
          arthas在线排查工具</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">5.4.</span> <span class="toc-text">
          GC算法的基础概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95"><span class="toc-number">5.5.</span> <span class="toc-text">
          三色标记算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%8F%E6%A0%87%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">5.5.1.</span> <span class="toc-text">
          漏标问题及解决方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMS"><span class="toc-number">5.6.</span> <span class="toc-text">
          CMS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CMS%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">5.6.1.</span> <span class="toc-text">
          CMS的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CMS%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90"><span class="toc-number">5.6.2.</span> <span class="toc-text">
          CMS日志分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G1"><span class="toc-number">5.7.</span> <span class="toc-text">
          G1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#G1%E9%80%BB%E8%BE%91%E5%88%86%E5%B1%82%EF%BC%8C%E7%89%A9%E7%90%86%E4%B8%8D%E5%88%86%E5%B1%82"><span class="toc-number">5.7.1.</span> <span class="toc-text">
          G1逻辑分层，物理不分层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G1%E7%89%B9%E7%82%B9"><span class="toc-number">5.7.2.</span> <span class="toc-text">
          G1特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSet"><span class="toc-number">5.7.3.</span> <span class="toc-text">
          CSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RSet"><span class="toc-number">5.7.4.</span> <span class="toc-text">
          RSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G1%E6%97%A5%E5%BF%97%E8%AF%A6%E8%A7%A3"><span class="toc-number">5.7.5.</span> <span class="toc-text">
          G1日志详解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0"><span class="toc-number">5.8.</span> <span class="toc-text">
          GC常用参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parallel%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0"><span class="toc-number">5.9.</span> <span class="toc-text">
          Parallel常用参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMS%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0"><span class="toc-number">5.10.</span> <span class="toc-text">
          CMS常用参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G1%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0"><span class="toc-number">5.11.</span> <span class="toc-text">
          G1常用参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">5.12.</span> <span class="toc-text">
          参考资料</span></a></li></ol></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="https://wx2.sbimg.cn/2020/09/22/GJ1jY.md.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">write code and love life</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/bugORdemo" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="NullPointerEXC-H" target="_blank" rel="noopener" data-popover="微信" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weixin"></i></span></a><a class="sidebar-ov-social-item" href="798968439" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">7</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">2</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">3</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2020</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span><a href="https://github.com/bugORdemo" rel="noopener" target="_blank">bugORdemo</a></span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v5.2.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.1.1</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/ribbon.js@latest/dist/ribbon.min.js" size="120" alpha="0.6" zIndex="-1"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lazyload@2.0.0-rc.2/lazyload.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@latest/pjax.min.js"></script><script>window.addEventListener('DOMContentLoaded', function () {
  var pjax = new Pjax({"selectors":["head title","#main",".pjax-reload"],"history":true,"scrollTo":false,"scrollRestoration":false,"cacheBust":false,"debug":false,"currentUrlFullReload":false,"timeout":0});
  // 加载进度条的计时器
  var loadingTimer = null;

  // 重置页面 Y 方向上的滚动偏移量
  document.addEventListener('pjax:send', function () {
    $('.header-nav-menu').removeClass('show');
    if (CONFIG.pjax && CONFIG.pjax.avoidBanner) {
      $('html').velocity('scroll', {
        duration: 500,
        offset: $('#header').height(),
        easing: 'easeInOutCubic'
      });
    }

    var loadingBarWidth = 20;
    var MAX_LOADING_WIDTH = 95;

    $('.loading-bar').addClass('loading');
    $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    clearInterval(loadingTimer);
    loadingTimer = setInterval(function () {
      loadingBarWidth += 3;
      if (loadingBarWidth > MAX_LOADING_WIDTH) {
        loadingBarWidth = MAX_LOADING_WIDTH;
      }
      $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    }, 500);
  }, false);

  window.addEventListener('pjax:complete', function () {
    clearInterval(loadingTimer);
    $('.loading-bar__progress').css('width', '100%');
    $('.loading-bar').removeClass('loading');
    setTimeout(function () {
      $('.loading-bar__progress').css('width', '0');
    }, 400);
    $('link[rel=prefetch], script[data-pjax-rm]').each(function () {
      $(this).remove();
    });
    $('script[data-pjax], #pjax-reload script').each(function () {
      $(this).parent().append($(this).remove());
    });

    if (Stun.utils.pjaxReloadBoot) {
      Stun.utils.pjaxReloadBoot();
    }
    if (Stun.utils.pjaxReloadScroll) {
      Stun.utils.pjaxReloadScroll();
    }
    if (Stun.utils.pjaxReloadSidebar) {
      Stun.utils.pjaxReloadSidebar();
    }
    if (false) {
      if (Stun.utils.pjaxReloadHeader) {
        Stun.utils.pjaxReloadHeader();
      }
      if (Stun.utils.pjaxReloadScrollIcon) {
        Stun.utils.pjaxReloadScrollIcon();
      }
      if (Stun.utils.pjaxReloadLocalSearch) {
        Stun.utils.pjaxReloadLocalSearch();
      }
    }
  }, false);
}, false);</script><div id="pjax-reload"><script src="https://cdn.jsdelivr.net/npm/quicklink@1.0.1/dist/quicklink.umd.js"></script><script>function initQuicklink() {
  quicklink({
    timeout: '10000',
    priority: true,
    ignores: [uri => uri.includes('#'), uri => uri === 'https://bugordemo.github.io/2020/09/22/GC%E5%92%8CGC-Tuning/', /\/api\/?/,uri => uri.includes('.xml'),uri => uri.includes('.zip'),(uri, el) => el.hasAttribute('nofollow'),(uri, el) => el.hasAttribute('noprefetch')]
  });
}

if (true || false) {
  initQuicklink();
} else {
  window.addEventListener('DOMContentLoaded', initQuicklink, false);
}</script><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script></div><script src="/js/utils.js?v=2.1.1"></script><script src="/js/stun-boot.js?v=2.1.1"></script><script src="/js/scroll.js?v=2.1.1"></script><script src="/js/header.js?v=2.1.1"></script><script src="/js/sidebar.js?v=2.1.1"></script></body></html>